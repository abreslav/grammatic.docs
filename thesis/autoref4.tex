\renewcommand{\thepart}{4}
\afsubsection{В четвертой главе} описан метод, позволяющий автоматически расширять предметно-ориентированные языки механизмами композиции, основанными на шаблонах и аспектах аналогичных использованным в языке \GRM{}. 

Механизм шаблонов \GRM{} обобщается для произвольного языка следующим образом. Выделяется набор \term{базовых понятий} (синтаксических категорий или классов в целевой мета-модели), характеризующих такой механизм в любом языке: \term{шаблон}, \term{параметр}, \term{шаблонное выражение}, \term{применение шаблона}, \term{использование шаблонного параметра}. Для каждого конкретного языка этот набор дополняется конкретными типами шаблонных выражений, соответствующих конструкциям данного языка. Шаблонные версии конструкций допускают использование шаблонных параметров и применений шаблонов вместо тех или иных своих частей. 

Семантика шаблонов определяется алгоритмом разворачивания, который обозначается $\Inst{\gamma}{\bullet}$, где \term{среда} $\gamma$ сопоставляет шаблонным параметрам фактические значения. Для применений базовых понятий этот алгоритм работает одинаково вне зависимости от конкретного языка, а для специфичных шаблонных выражений создаются экземпляры соответствующих конструкций языка и алгоритм вызывается рекурсивно на подвыражениях. Конечность такой процедуры обеспечивается тем, что шаблонам запрещено вызывать себя рекурсивно, и результирующие объекты, таким образом, всегда конечны. Время работы алгоритма разворачивания линейно от размера входных данных.

Для того, чтобы диагностика ошибок происходила в терминах исходной спецификации, содержащей шаблоны, а не в терминах результата разворачивания, необходимо иметь возможность убедиться в корректности результата, не осуществляя разворачивания. Эта задача решается с помощью системы типов, которая строится следующим образом: правила типизации для базовых понятий фиксированы; наиболее важные правила приведены на \figref{TmpTypes}.
\begin{figure}[htbp]
	\centering
$$
\trule{}{\Gamma \cup \{v : \tau\} \vdash \ang{?v} : \tau}{var}
$$ 
$$
\trule{
	\Gamma \cup \bigcup\limits_{i=1}^{n} \{ p_i : \tau_i \} \vdash b : \sigma
}{
	\Gamma \vdash \mathbf{template}\left(
		T \ang{p_1 : \tau_1, \ldots, p_n : \tau_n} \,: \sigma \, \{ b \}
	\right)
}{abstr}
$$ 
$$
\trule{
	\Gamma \vdash \mathbf{template}\left(
		T \ang{p_1 : \tau_1, \ldots, p_n : \tau_n} \,: \sigma \, \{ b \}
	\right)
	&
	\forall i : [1:n].\; \Gamma \vdash a_i : \tau_i \
}{
	\Gamma \vdash \ang{T \, a_1, \ldots, a_n} : \sigma
}{appl}
$$
	\caption{Основные правила системы типов языка шаблонов}\label{TmpTypes}
\end{figure}
Для специфичных шаблонных выражений генерируются новые правила системы типов, отражающие структурные ограничения, накладываемые целевой мета-моделью исходного языка (включая кратность ссылок).

Для построенных таким образом алгоритма $\Inst{\gamma}{\bullet}$ и системы типов доказаны следующие теоремы, показывающие, что система типов гарантирует корректность результата разворачивания.

\begin{Th}[О сохранении типов]
Если среда $\gamma$ согласована с контекстом $\Gamma$ и $\Gamma \vdash e : \tau$, то $\Gamma \vdash \Inst{\gamma}{e} : \tau$. Другими словами, преобразование $\Inst{}{\bullet}$ сохраняет типы.
\end{Th}

\begin{Th}[О нормализации]
Если среда $\gamma$ согласована с контекстом $\Gamma$ и $\Gamma \vdash e : \tau$, то вычисление $\Inst{\gamma}{e}$ заканчивается за конечное количество шагов, и результат не содержит применений шаблонов и шаблонных параметров.
\end{Th}

Аналогично описанному выше строится алгоритм реконструкции типов, позволяющий пользователю не декларировать типы шаблонов и их параметров явно.

\begin{table}[htb]
	\centering
\newcommand{\dissonly}[1]{}
\input{templates.table.tex}
	\caption{Поддержка шаблонов}\label{TmpTable}
\end{table}



Поддержка аспектов строится на тех же принципах, что и поддержка шаблонов, причем многие конструкции, генерируемые для поддержки шаблонов используются также и для аспектов. Основные отличия лежат в области семантики, которая в случае аспектов описывается двумя алгоритмами: сопоставление выражения $e$ исходного языка с образцом (срезом) $p$, обозначаемое $\match{e}{p}$, и применение аспектного правила $\mathcal{R}$ в случае успешного сопоставления, обозначаемое $\rapply{\mathcal{R}}{e}$.

Операция сопоставления является в некотором смысле обратной к разворачиванию шаблона: вместо того, чтобы заменять вхождения переменных их значениями, она должна найти значения переменных, удовлетворяющие данному образцу. Основной интерес представляет алгоритм сопоставления коллекций (списков и множеств) в случае использования подстановочных знаков, допускающих сопоставление с частью коллекции. В случае списков для решения этой задачи применяется перебор с возвратами, а в случае множеств задача сводится к поиску максимальных паросочетаний в друдольных графах. В литературе показано, что задача сопоставления образцов является $NP$-полной при наличии переменных и неупорядоченных коллекций, и используемый алгоритм имеет экспоненциальную оценку времени работы в худшем случае, однако этот алгоритм показывает вполне приемлемые результаты на практике, что было установлено в процессе использования аспектов, реализованных в \GRM{}.

Применение аспектного правила сводится к замене объектов, сопоставленных переменным, другими объектами, полученными при разворачивании соответствующих шаблонов. В общем случае смысл имеют только советы с ключевым словом \code{instead}, то есть заменяющие, а не добавляющие, поскольку понятия вставки до и после могут не иметь смысла в конкретном языке. Тем не менее, если эти понятия имеют смысл, они легко реализуются через замену.

Система типов, используемая для статического контроля корректности результатов применения аспектов базируется на системе типов для шаблонов с той лишь разницей, что в случае аспектов требуется соответствие между типом переменной и шаблонным выражением, которым значения этой переменной будут заменены, что выражается следующим правилом:
$$
	\infer[aspect]{
		(\mathbf{instead} \; v \, : \, t) \in Allowed(\mathcal{R})
	}{
		\mathcal{R} = \langle p, T, V \rangle &
		p \vdash v : \tau &
		\Gamma(p) \vdash t : \sigma &
		\sigma \preceq \tau
	}
$$
Здесь $Allowed(\mathcal{R})$ обозначает множество всех корректных пар ``переменная-шаблонное выражение''.

\begin{table}[htb]
	\centering
\newcommand{\dissonly}[1]{}
\input{aspects.table.tex}
	\caption{Поддержка аспектов}\label{AspTable}
\end{table}

В качестве примера применения описанного метода разработано расширение языка описания мета-моделей \tool{Emfatic}, добавляющее в данный язык поддержку композиции с помощью шаблонов и аспектов.
