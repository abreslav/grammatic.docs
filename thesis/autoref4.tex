\renewcommand{\thepart}{4}
\afsubsection{В четвертой главе} описан метод, позволяющий автоматически расширять предметно-ориентированные языки механизмами композиции, основанными на шаблонах и аспектах, аналогичными использованным в языке \GRM{}. Описывается подход к расширению целевой мета-модели и нотации соответствующими конструкциями, а также алгоритмы проверки типов, разворачивания шаблонов и применения аспектов, работающие с языками, расширенными таким образом.

Для поддержки шаблонов в язык вводятся следующие \term{базовые понятия}: \term{шаблон}, \term{параметр}, \term{шаблонное выражение}, \term{применение шаблона}, \term{использование шаблонного параметра}. Для каждого конкретного языка этот набор дополняется специфичными типами шаблонных выражений, соответствующих конструкциям данного языка. Шаблонные версии конструкций допускают использование шаблонных параметров и применений шаблонов вместо тех или иных своих частей. 

Семантика шаблонов определяется алгоритмом разворачивания, который обозначается $\Inst{\gamma}{\bullet}$, где \term{среда} $\gamma$ сопоставляет шаблонным параметрам фактические значения. Для применений базовых понятий этот алгоритм работает одинаково вне зависимости от конкретного языка, а для специфичных шаблонных выражений создаются экземпляры соответствующих конструкций языка и алгоритм вызывается рекурсивно на подвыражениях.

Диагностику ошибок необходимо производить до разворачивания шаблонов, чтобы избежать появления сообщений об ошибках, ссылающихся на результаты разворачивания, которых разработчик не видит. Эта задача решается с помощью системы типов, использующей классы мета-модели исходного языка и соответствующие ограничения на кратность ссылок для того, чтобы удостовериться, что результат разворачивания будет корректным экземпляром этой мета-модели. 
Также построен алгоритм реконструкции типов, позволяющий пользователю не декларировать типы шаблонов и их параметров явно. Следующие теоремы показывают, что система типов гарантирует корректность результата разворачивания.

\begin{Th}[О сохранении типов]
Если среда $\gamma$ согласована с контекстом $\Gamma$ и $\Gamma \vdash e : \tau$, то $\Gamma \vdash \Inst{\gamma}{e} : \tau$. Другими словами, преобразование $\Inst{}{\bullet}$ сохраняет типы.
\end{Th}

\begin{Th}[О нормализации]
Если среда $\gamma$ согласована с контекстом $\Gamma$ и $\Gamma \vdash e : \tau$, то вычисление $\Inst{\gamma}{e}$ заканчивается за конечное количество шагов, и результат не содержит применений шаблонов и шаблонных параметров.
\end{Th}

Поддержка аспектов базируется на тех же понятиях, что и поддержка шаблонов: параметры соответствуют переменным и подстановочным знакам, а шаблонные выражения --- срезам; дополнительно вводится понятие \term{аспектного правила}, объединяющего срезы и советы. Семантика аспектов описывается двумя алгоритмами: сопоставление выражения $e$ исходного языка с образцом (срезом) $p$, обозначаемое $\match{e}{p}$, и применение аспектного правила $\mathcal{R}$ в случае успешного сопоставления, обозначаемое $\rapply{\mathcal{R}}{e}$.

В литературе показано, что задача сопоставления с образцом является $NP$-полной при наличии переменных и неупорядоченных коллекций (множеств), таким образом, соответствующий алгоритм имеет экспоненциальную оценку времени работы в худшем случае, однако реализация, использованная, в частности, в \GRM{} не вызывает проблем с быстродействием на практике. В случае списков для решения задачи сопоставления применяется перебор с возвратами, а в случае множеств задача сводится к поиску максимальных паросочетаний в друдольных графах. 

Применение аспектного правила сводится к замене объектов, сопоставленных переменным, другими объектами, полученными при разворачивании соответствующих шаблонов. Если для конкретного языка имеют смысл понятия вставки до или после точки встраивания, они легко реализуются через замену.
Для статического контроля корректности результатов система типов пополняется правилом, проверяющим соответствие между типом переменной и шаблонным выражением, которым значения этой переменной будут заменены.

\begin{table}[htb]
	\centering
\newcommand{\dissonly}[1]{}
\input{templates.table.tex}
	\caption{Средства автоматизации разработки механизмов шаблонов}\label{TmpTable}
\end{table}

Результаты сравнения предложенного подхода с уже существующими приведены в таблицах \ref{TmpTable} и \ref{AspTable}. 
Из \tabref{TmpTable} видно, что шаблоны, построенные описанным методом, не поддерживают только управляющую логику (условия, циклы) в теле шаблона\footnote{Речь идет об операциях, выполняемых в процессе разворачивания, а не о конструкциях исходного языка.}. Данная функциональность затрудняет статический контроль корректности, поэтому ее поддерживают только подходы, не осуществляющие такого контроля или привязанные к одному языку программирования. Таким образом, наличие управляющей логики в шаблонах принесено в жертву универсальности подхода и гарантиям корректности. 

Сходной функциональностью обладает проект \tool{Reuseware}, однако для применения шаблонов в этом случае требуется как расширение исходного языка, так и применение дополнительного языка композиции, который не требуется в случае использования предлагаемого подхода\footnote{В \tabref{TmpTable} это свойство обозначено термином ``Замкнутость''.}.

\begin{table}[htb]
	\centering
\newcommand{\dissonly}[1]{}
\input{aspects.table.tex}
	\caption{Средства автоматизации разработки механизмов аспектов}\label{AspTable}
\end{table}

В случае аспектов, как видно из \tabref{AspTable}, существующие подходы либо не автоматизируют процесс разработки механизма, предлагая лишь методологию ручной разработки, либо не поддерживают незнания (obliviousness), не имеют специализированного языка срезов или привязаны к конкретной платформе\footnote{ Виртуальные машины в данном случае тоже считаются платформами. Заметим, что платформенно-зависимые подходы, как правило, поддерживают динамическую семантику аспектов, которая в настоящей работе не рассматривается.}. 

Описанный выше метод был применен для расширения языка описания мета-моделей, аналогичного \tool{Emfatic}, в результате чего был получен язык, сравнимый по функциональности, касающейся декларативных описаний (в рассматриваемом языке нет тел методов), с \tool{C++} в части шаблонов и \tool{AspectJ} в части аспектов.