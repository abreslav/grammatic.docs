\afsubsection{Вторая глава} описывает предметно-ориентированный язык \GRM{}, предназначенный для описания текстового синтаксиса, поддерживающий композицию с помощью модулей, шаблонов и аспектов. Этот язык используется как обобщенная 
нотация, которую можно применять при разработке различных инструментов, основанных на контекстно-свободных грамматиках. Реализация данного языка представляет собой библиотеку, позволяющую транслировать текстовые описания грамматик во внутреннее объектно-ориентированное представление, которое в дальнейшем используется различными генераторами для построения тех или иных программных средств, таких как синтаксические анализаторы и компоненты интегрированных сред разработки.

Основными конструкциями данного языка являются правила контекстно-свободной грамматики. Каждое правило включает одну или несколько продукций, описывающих один нетерминальный символ. При этом используются операции расширенной нотации BNF (см. \tabref{operations}). 
\begin{figure}[htbp]
\center
	\begin{tabular}{|c|l|}
	\hline
	\bf Нотация & \bf Значение \\
	\hline
	\code{\#empty} & Пустое выражение \\
	\code{a} & Ссылка на символ a \\
	\code{a b} & Последовательность \\
	\code{a | b} & Альтернатива \\
	\code{a*} & Итерация от 0 до бесконечности \\
	\code{a+} & Итерация от 1 до бесконечности \\
	\code{a?} & Итерация от 0 до 1 \\
	\code{['a'--'z']} & Множество символов от 'a' до 'z' \\
	\code{'abc'} & Строка символов 'abc' \\
	\code{(a | b) c} & Круглые скобки для группировки выражений \\
	\hline
	\end{tabular}
	\caption{Выражения \GRM{}}\label{operations}
\end{figure}
С помощью этих операций можно эффективно описать не только синтаксическую, но и лексическую структуру языка, поэтому терминальным алфавитом в спецификациях \GRM{} всегда считается Unicode, а лексические правила задаются в виде продукций для соответствующих нетерминальных символов. Пример использования \GRM{} для описания простого языка арифметических выражений приведен в \lstref{ArithSyn}.
\begin{lstlisting}[float=htbp,label=ArithSyn,caption=Грамматика языка арифметических выражений]
	INT : ['0'--'9']+;
	VAR : ['a'--'z''A'--'Z''_']['a'--'z''A'--'Z''_''0'--'9']*;
	expr
		: expr '+' expr
		: expr '*' expr
		: '(' expr ')'
		: INT
		: VAR
		;
\end{lstlisting}

Большинство инструментов, основанных на контекстно-свободных грамматиках, используют дополнительные средства (\term{метаданные}) для описания семантики или других свойств языков. В языке \GRM{} этот подход обобщается за счет введения произвольных аннотаций, которые могут быть добавлены к любому элементу грамматики: символу, продукции, выражению и т.д. Каждая аннотация состоит из \term{атрибутов}, записываемых в форме ``имя = значение''. Предопределенные типы значений приведены в \tabref{valtypes}; разработчик может определять собственные типы значений.
\begin{figure}[htbp]
\center
	\begin{tabular}{|c|l|}
	\hline
	\bf Нотация & \bf Значение \\
	\hline
	\code{'abc'} & Строка \\
	\code{10} & Целое число \\
	\code{abc} & Идентификатор \\
	\code{\{ a = b; c = 10\}} & Аннотация \\
	\code{ \{\{ a, b, c ; \}\} } & Последовательность \\
	\code{ \texttt{<}< s | (a b)* >\texttt{>} } & Грамматическое выражение \\
	\hline
	\end{tabular}
	\caption{Предопределенные типы значений атрибутов}\label{valtypes}
\end{figure}
Семантика аннотаций в \GRM{} не зафиксирована, что позволяет различным генераторам использовать их для различных целей, таких как описание атрибутной трансляции, классификация лексем для подсветки синтаксиса или спецификация правил автоматического форматирования кода.

Для повторного использования грамматик и их фрагментов применяются механизмы модулей, шаблонов и аспектов. Модули обеспечивают разделение спецификации на несколько физических файлов, имеющих собственные пространства имен символов. Включение одного модуля другим происходит с помощью директивы цитирования \code{import}, синтаксис которой иллюстрируется следующим примером:
\begin{lstlisting}
import 'a/b/c/d.grammar' {A, B as C};

B : A C*;
\end{lstlisting}  
Директива \code{import} принимает два аргумента: идентификатор импортируемого файла в одинарных кавычках и список импортируемых символов в фигурных скобках, который может быть заменен символом ``*'', если требуется импортировать все символы из данного модуля. Идентификатором файла является его имя в \term{виртуальной файловой системе}, конфигурация которой подается на вход транслятору \GRM{} вместе с файлом основной грамматики. Ключевое слово \code{as} в списке импортируемых символов для использования импортированного символа под другим именем.

Шаблоны (типизированные макроопределения) позволяют повторно использовать фрагменты грамматики, внося в них некоторые изменения, посредством подстановки на место параметров шаблона реальных значений. Проиллюстрируем описание шаблона следующим примером:
\begin{lstlisting}
template List<element : Expression, sep : Expression> : Expression {
	<?element> (<?sep> <?element>)*
}
\end{lstlisting}
Данный шаблон описывает грамматические выражения, задающие списки элементов, чередующихся с разделителем, например ``\code{INT ('*' INT)*}''. Здесь \code{List} --- имя шаблона, после него в угловых скобках следует список параметров с типами, позволяющими контролировать корректность результата разворачивания шаблона. В теле шаблона параметры можно использовать на вместо тех или иных фрагментов спецификации, указывая имена в угловых скобках со знаком вопроса (например, ``\code{<?sep>}''). Шаблон можно использовать, указав в угловых скобках его имя и аргументы, занимающие места формальных параметров, например, выражение \code{<List INT, '*'>} будет развернуто в \code{INT ('*' INT)*}. Результатом применения шаблона может быть не только грамматическое выражение, но и любая другая конструкция языка \GRM{}, например, одно или несколько правил. Это позволяет реализовать с помощью шаблонов концепцию \term{параметрических модулей}. 

Еще одним механизмом композиции, реализованным в \GRM{} являются аспекты. 
%Этот механизм обеспечивает выполнение двух основополагающих свойств:
%\begin{itemize}
%\item \term{Незнание} --- отсутствие необходимости специальным образом обозначать или иначе подготавливать участок программы, в который будет внесено изменение с помощью аспектов (``\term{совет}''). Другими словами, наличие аспекта не влияет на структуру программы, в которую он встраивается, то есть программа \term{не знает} о существовании аспекта.
%\item \term{Квантификация} --- возможность встроить один и тот же совет в несколько участков программы, описанных некоторым выражением. Это выражение играет роль \term{квантора} (аналогично квантору всеобщности в логике предикатов).
%\end{itemize}
Основополагающие понятия аспектно-ориентированного программирования реализуются в \GRM{} следующим образом:
\begin{itemize}
\item \term{Точками встраивания} (join points) являются все элементы языка \GRM{}, такие как символы, различные выражения, продукции и аннотации.
\item \term{Срезы} (point-cuts), обеспечивающие квантификацию (quantification), описываются в виде образцов (patterns), использующих как конструкции из \tabref{operations}, так и переменные, с которыми связываются конкретные фрагменты сопоставляемых выражений. Кроме того, используются \term{подстановочные знаки}, соответствующие произвольным конструкциям одного определенного типа (например, произвольным выражениям или произвольным символам).
\item \term{Советы} (advice), описывающие изменения, привносимые в точках встраивания, позволяют встраивать результаты разворачивания данных шаблонных выражений до, после или вместо фрагментов точек встраивания.
\end{itemize}
Приведем пример \term{аспектного правила}, использующего данные понятия:
\begin{lstlisting}
example : .. e=example  .. ;
	instead ?e : '(' <?e> ')' ;
\end{lstlisting}
Данный пример заменяет рекурсивное вхождение символа \code{example} в правой части на тот же символ, заключенный в скобки. Другой способ записать то же преобразование использует вставку элементов до и после символа:
\begin{lstlisting}
example : .. e=example  .. ;
	before ?e : '(';
	after  ?e : ')';
\end{lstlisting}

С помощью аспектов достигается повторное использование  и расширение спецификаций, в которых не предусмотрены такие возможности (например, эти спецификации не являются шаблонными). Кроме того, этот механизм позволяет разделять спецификацию на фрагменты с различным назначением, например, отделять метаданные для различных генераторов от грамматических правил.

\begin{table}[htb]
	\centering
\newcommand{\dissonly}[1]{}
\input{grammatic.table.tex}
	\caption{Сравнение \GRM{} с существующими инструментами}\label{GrmTable}
\end{table}


Целесообразность использования описанных механизмов композиции продемонстрирована на примере описания синтаксиса языка SQL92 и нескольких его диалектов, а также самого языка \GRM{}. В обоих случаях удается сократить объем спецификации и ослабить зависимости между модулями по сравнению с другими инструментами.
