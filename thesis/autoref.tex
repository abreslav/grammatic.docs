\documentclass[12pt,a4paper]{article}

\usepackage{afterpage,fullpage,amsfonts,amsthm,amssymb,amsmath,indentfirst}

\usepackage{ucs}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}

\usepackage[english,russian]{babel}


%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{cmap}
\usepackage{url}
\usepackage{proof}
\usepackage[
	colorlinks=true,
	linkcolor=blue,
	citecolor=blue,
	urlcolor=blue
]{hyperref}

\usepackage{listings}

\renewcommand{\lstlistingname}{Листинг}

\lstset{
	inputencoding=utf8x, 
	extendedchars=\true, 
	basicstyle=\ttfamily\footnotesize,
	keywordstyle=\sffamily\bfseries,
	stringstyle=\sffamily,
	tabsize=4,
	captionpos=b,
	showstringspaces=false,
	xleftmargin=1cm,
}

\newcommand{\figref}[1]{Рис.~\ref{#1}}
\newcommand{\lstref}[1]{Лист.~\ref{#1}}
\newcommand{\tabref}[1]{Таб.~\ref{#1}}
\newcommand{\term}[1]{\emph{#1}}
\newcommand{\code}[1]{\mbox{\texttt{#1}}}
\newcommand{\tool}[1]{\textsc{#1}}

\theoremstyle{definition}
\newtheorem{Def}{Определение~}[part]
\theoremstyle{plain}
\newtheorem{Th}{Теорема~}[part]
\newtheorem{Lemm}[Th]{Лемма~}
\newtheorem{Prop}[Th]{Предложение~}
\newtheorem{Cor}{Следствие~}[Th]
\newtheorem{Note}{Замечание~}[part]
\newtheorem{Ex}{Пример~}[part]
\renewcommand{\proofname}{Доказательство}

\renewcommand{\theLemm}{\thepart.\arabic{Lemm}}
\renewcommand{\theTh}{\thepart.\arabic{Th}}
\renewcommand{\theProp}{\thepart.\arabic{Prop}}
\renewcommand{\theCor}{\theTh.\arabic{Cor}}
\renewcommand{\theNote}{\thepart.\arabic{Note}}
\renewcommand{\tablename}{Таблица}
\renewcommand{\lstlistingname}{Листинг}
\renewcommand{\figurename}{Рис.}
\renewcommand{\baselinestretch}{1.23}

\newcommand{\GRM}{\tool{Grammatic}}
\newcommand{\ATF}{\tool{Grammatic$^{SDT}$}}
%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\Inst}[2]{\mathcal{I}_{#1} \left[ #2 \right]}%
\newcommand{\trule}[3]{%
\infer[\mbox{#3}]{#2}{#1}%(\mbox{\textsc{#3}})%
}
\newcommand{\ang}[1]{\mathsf{<}#1\mathsf{>}}
\newcommand{\match}[2]{#1 \; \mathbf{match} \; #2}
\newcommand{\rapply}[2]{#1@#2}
%%%%%%%%%%%%%%%%%%%%%%%%%%

\voffset=-5mm
\rightmargin=0pt

%\input ../sty/aut14.cli
\input{aut14.cli}
\makeatletter
\def\paragraph{\@startsection{paragraph}{4}{\z@}%
{2ex plus 0.2ex minus.1ex}{-1em}{\reset@font\bf}}
 \makeatother
\date{}
\catcode`@ = 11 \catcode`@ = 12
\def\hiphantom#1{\underline{\phantom{#1}}}

\sloppy

\selectlanguage{russian} \makeatletter
\renewcommand{\@oddhead}{\hfill{\large \thepage}\hfill}
\renewcommand{\@oddfoot}{}
\renewcommand{\@evenhead}{\hfill{\large \thepage}\hfill}
\renewcommand{\@evenfoot}{}
%\renewcommand{\@makefntext}[1]{\parindent=1em\noindent
% \hbox to 1.8 em {\hss\Large$^{\@thefnmark}$}#1}
\makeatother \large
%title

\newcommand{\afsection}[1]{\par \begin{center}\textbf{\MakeUppercase{#1}}\end{center}}
\newcommand{\afsubsection}[1]{\par \underline{\textbf{#1}}}

\newcommand{\myignore}[1]{}
\begin{document}

\newpage
\begin{titlepage}
%\newlength{\onefourth}
%\setlength{\onefourth}{.25\textheight}
%\begin{center}
%САНКТ-ПЕТЕРБУРГСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ
%\end{center}
\vskip 4ex
\bigskip
\bigskip
\rightline{На правах рукописи}
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\begin{center}
Бреслав Андрей Андреевич\\ \vskip 4ex
\end{center}
\bigskip
\bigskip

\begin{center}
\MakeUppercase{\bf Механизмы композиции в предметно-ориентированных языках}
\vskip 15ex Специальность 05.13.11~--- Математическое и
программное обеспечение вычислительных машин, комплексов и
компьютерных сетей\\ \vskip 10ex
 \MakeUppercase{Автореферат}\\
 диссертации на соискание ученой степени\\
 кандидата технических наук
  \vfill Санкт-Петербург~--- 2010
\end{center}
\end{titlepage}


\thispagestyle{empty}
\addtocounter{page}{1}
%title1

\newpage

\thispagestyle{empty}
%\begin{center}
\noindent 
Работа выполнена в Санкт-Петербургском государственном университете информационных технологий, механики и оптики (СПбГУ ИТМО).
%\end{center}

\vspace*{\fill}

\noindent
\begin{tabular}{ll}
Научный руководитель:  & доктор физико-математических наук,  				 \\
                       & профессор Попов Игорь Юрьевич         				 \\
                       & \\
Официальные оппоненты: & доктор технических наук,   				 \\
                       & профессор Гатчин Юрий Арменакович         \\
                       \\
                       & кандидат физико-математических наук,\\
                       & старший научный сотрудник\\
                       & Новиков Федор Александрович\\
                       & \\
Ведущая организация:   & Санкт-Петербургский Академический \\ 
					   & университет -- научно-образовательный \\
					   & центр нанотехнологий РАН\\
\end{tabular}

\vspace*{\fill}

\noindent
Защита диссертации состоится ``\ \ \ '' \hspace{1mm} \ \ \ \ \ \ \ \ \ \ \ \ 
2010 г. в \ \ \ \ \  час.  на заседании диссертационного совета 
Д 212.227.06 
при Санкт-Петербургском государственном университете информационных технологий, механики и оптики 
по адресу: 197101, Санкт-Петербург, Кронверкский пр., д. 49.


\vspace{1cm}

\noindent
С диссертацией можно ознакомиться в библиотеке
Санкт-Петербургского государственного университета информационных технологий, механики и оптики.


\vspace{1cm}

%\begin{center}
%\noindent
\noindent
Автореферат разослан \hspace{2mm}``\ \ \ '' \hspace{1mm}
\ \ \ \ \ \ \ \ \ \ \ \  2010 г.
%\end{center}


\vspace*{\fill}
\noindent Ученый секретарь
диссертационного совета, \hspace*{\fill}Лисицына Л. С.\\
доктор технических наук, профессор

%\vspace{-2mm}
% \noindent профессор \hspace*{\fill} \hspace*{\fill}



\setlength{\topmargin}{-5mm} \makeatletter
\renewcommand{\@oddhead}{\hfill{\large \thepage}\hfill}
\renewcommand{\@oddfoot}{}
\renewcommand{\@evenhead}{\hfill{\large \thepage}\hfill}
\renewcommand{\@evenfoot}{}
\makeatother

\newpage
\afsection{Общая характеристика работы}

\input{intro.tex}

\newpage
\afsection{Содержание работы}

\afsubsection{Во введении} обосновывается актуальность проблемы, формулируются цель и задачи исследования, отмечаются научная новизна и практическая значимость результатов, перечисляются основные положения, выносимые на защиту.

\afsubsection{Первая глава} посвящена обзору существующих подходов к автоматизации разработки предметно-ориентированных языков. Долгое время в этой области доминировали инструменты, предназначенные для разработки трансляторов текстовых языков, основанные на принципах синтаксически управляемой атрибутной трансляции. Наиболее популярными инструментами этого семейства являются \tool{Yacc}, \tool{Bison} и \tool{ANTLR}. Такие инструменты подразумевают описание синтаксиса языка с помощью контекстно-свободной грамматики, с продукциями которой ассоциированы правила вычисления атрибутов, описывающих семантические свойства предложений языка. С помощью атрибутов могут быть реализованы все стадии семантического анализа от разрешения имен до преобразования в машинный код. 

Основным недостатком традиционных средств разработки трансляторов применительно к созданию предметно-ориентированных языков является трудоемкость разработки. Это вызвано в первую очередь тем, что такие инструменты создавались как универсальные средства разработки языков программирования и не предназначены для быстрого решения типичных задач, возникающих при создании небольших языков.

Распространенным способом решения проблемы быстрой разработки ПОЯ является встраивание таких языков в языки общего назначения. При этом используются встроенные в язык общего назначения средства мета-программирования или гибкие синтаксические конструкции. Чаще всего ПОЯ встраиваются в динамические языки, такие как \tool{Ruby} или \tool{Groovy}, и в языки с гибкой системой типов, такие как \tool{Haskell} или \tool{Scala}. Основным недостатком данного подхода является привязка к тому или иному языку общего назначения: ПОЯ, легко встраиваемый в один язык, может быть практически невозможно встроить в другой. Это затрудняет повторное использование ПОЯ и приводит к смешиванию уровней абстракции: аспекты реализации сильно влияют на высокоуровневое описание предметной области.

Другое направление в развитии средств разработки языков основано на использовании графического синтаксиса вместо текстового. Толчок к развитию этого направление дал UML, унифицированный язык моделирования. Чаще всего нотации таких языков используют диаграммы, представляющие собой графы с различными типами вершин и ребер, уложенные на плоскости. Такие языки показали высокую эффективность при решении определенного круга задач, но они не заменяют текстовых языков, в частности, потому, что требуют серьезной инструментальной поддержки, что создает трудности с совместимостью и переносимостью. Следует отметить также, что в области графического синтаксиса существует подход, реализованный в проекте \tool{MPS}, объединившим сильные стороны текстового и графического синтаксиса. Однако в настоящее время этот подход также требует серьезной инструментальной поддержки, что создает препятствия к его использованию в индустрии.

С развитием идеи предметно-ориентированных языков стали появляться инструменты, ориентированные на быструю разработку автономного транслятора вместе с интегрированной средой разработки. Преимущества этих инструментов состоят в том, что они, во-первых, позволяют создавать простые трансляторы с минимальными затратами времени, а во-вторых, автоматически генерируют расширения для той или иной интегрированной среды, облегчающие разработчику создание и поддержку программ на новом языке. Как правило, такие инструменты ориентированы на решение типичных проблем, и реализация поддержки более сложных механизмов с их помощью затруднительна, однако на практике оказывается, что простота и скорость разработки являются очень весомым фактором, и именно этим инструментам отдают предпочтение разработчики. Возникает необходимость расширять возможности подобных средств, не увеличивая нагрузки на программиста, то есть идет о полной или практически полной автоматизации разработки тех или иных механизмов в языке. Одним из таких механизмов является композиция, обеспечивающая повторное использование спецификаций, основными примерами универсальных механизмов такого рода являются шаблоны (статически проверяемые макроопределения) и аспекты. Существующие подходы к автоматизации разработки таких механизмов не позволяют автоматически получать языки, поддерживающие их в полном объеме.

\afsubsection{Вторая глава} описывает предметно-ориентированный язык \GRM{}, предназначенный для описания текстового синтаксиса, поддерживающий композицию с помощью модулей, шаблонов и аспектов. Этот язык используется как обобщенная 
, которую можно применять для при разработке различных инструментов, основанных на контекстно-свободных грамматиках. Реализация данного языка представляет собой библиотеку, позволяющую транслировать текстовые описания грамматик во внутреннее объектно-ориентированное представление, которое в дальнейшем используется различными генераторами для построения тех или иных компонент ПО, таких как синтаксические анализаторы и компоненты интегрированных сред разработки.

Основными конструкциями данного языка являются правила контекстно-свободной грамматики. Каждое правило включает одну или несколько продукций, описывающих один нетерминальный символ. При этом используются операции расширенной нотации BNF (см. \tabref{operations}). 
\begin{figure}[htbp]
\center
	\begin{tabular}{|c|l|}
	\hline
	\bf Нотация & \bf Значение \\
	\hline
	\code{\#empty} & Пустое выражение \\
	\code{a} & Ссылка на символ a \\
	\code{a b} & Последовательность \\
	\code{a | b} & Альтернатива \\
	\code{a*} & Итерация от 0 до бесконечности \\
	\code{a+} & Итерация от 1 до бесконечности \\
	\code{a?} & Итерация от 0 до 1 \\
	\code{['a'--'z']} & Множество символов от 'a' до 'z' \\
	\code{'abc'} & Строка символов 'abc' \\
	\code{(a | b) c} & Круглые скобки для группировки выражений \\
	\hline
	\end{tabular}
	\caption{Выражения \GRM{}}\label{operations}
\end{figure}
С помощью этих операций можно эффективно описать не только синтаксическую, но и лексическую структуру языка, поэтому терминальным алфавитом в спецификациях \GRM{} всегда считается Unicode, а лексические правила задаются в виде продукций для соответствующих нетерминальных символов. Пример использования \GRM{} для описания простого языка арифметических выражений приведен в \lstref{ArithSyn}.
\begin{lstlisting}[float=htbp,label=ArithSyn,caption=Синтаксис языка арифметических выражений]
	INT : ['0'--'9']+;
	VAR : ['a'--'z''A'--'Z''_']['a'--'z''A'--'Z''_''0'--'9']*;
	expr
		: expr '+' expr
		: expr '*' expr
		: '(' expr ')'
		: INT
		: VAR
		;
\end{lstlisting}

Большинство инструментов, основанных на контекстно-свободных грамматиках, используют дополнительные средства (\term{метаданные}) для описания семантики или других свойств языков. В языке \GRM{} этот подход обобщается за счет введения произвольных аннотаций, которые могут быть добавлены к любому элементу грамматики: символу, продукции, выражению и т.д. Каждая аннотация состоит из \term{атрибутов}, записываемых в форме ``имя = значение''. Предопределенные типы значений приведены в \tabref{valtypes}; разработчик может определять собственные типы значений.
\begin{figure}[htbp]
\center
	\begin{tabular}{|c|l|}
	\hline
	\bf Нотация & \bf Значение \\
	\hline
	\code{'abc'} & Строка \\
	\code{10} & Целое число \\
	\code{abc} & Идентификатор \\
	\code{\{ a = b; c = 10\}} & Аннотация \\
	\code{ \{\{ a, b, c ; \}\} } & Последовательность \\
	\code{ \texttt{<}< s | (a b)* >\texttt{>} } & Грамматическое выражение \\
	\hline
	\end{tabular}
	\caption{Предопределенные типы значений атрибутов}\label{valtypes}
\end{figure}
Семантика аннотаций в \GRM{} не зафиксирована, что позволяет различным генераторам использовать их для различных целей, таких как описание атрибутной трансляции, классификация лексем для подсветки синтаксиса или спецификация правил автоматического форматирования кода.

Для повторного использования грамматик и их фрагментов применяются механизмы модулей, шаблонов и аспектов. Модули обеспечивают разделение спецификации на несколько физических файлов, имеющих собственные пространства имен символов. Включение одного модуля другим происходит с помощью директивы цитирования \code{import}, синтаксис которой иллюстрируется следующим примером:
\begin{lstlisting}
import 'a/b/c/d.grammar' {A, B as C};

B : A C*;
\end{lstlisting}  
Директива \code{import} принимает два аргумента: идентификатор импортируемого файла в одинарных кавычках и список импортируемых символов в фигурных скобках, который может быть заменен символом ``*'', если требуется импортировать все символы из данного модуля. Идентификатором файла является его имя в \term{виртуальной файловой системе}, конфигурация которой подается на вход транслятору \GRM{} вместе с файлом основной грамматики. Ключевое слово \code{as} в списке импортируемых символов для использования импортированного символа под другим именем.

Шаблоны (типизированные макроопределения) позволяют повторно использовать фрагменты грамматики, внося в них некоторые изменения, посредством подстановки на место параметров шаблона реальных значений. Проиллюстрируем описание шаблона следующим примером:
\begin{lstlisting}
template List<element : Expression, sep : Expression> : Expression {
	<?element> (<?sep> <?element>)*
}
\end{lstlisting}
Данный шаблон описывает грамматические выражения, задающие списки элементов, чередующихся с разделителем, например ``\code{INT ('*' INT)*}''. Здесь \code{List} --- имя шаблона, после него в угловых скобках следует список параметров с типами, позволяющими контролировать корректность результата разворачивания шаблона. В теле шаблона параметры можно использовать на вместо тех или иных фрагментов спецификации, указывая имена в угловых скобках со знаком вопроса (например, ``\code{<?sep>}''). Шаблон можно использовать, указав в угловых скобках его имя и аргументы, занимающие места формальных параметров, например, выражение \code{<List INT, '*'>} будет развернуто в \code{INT ('*' INT)*}. Результатом применения шаблона может быть не только грамматическое выражение, но и любая другая конструкция языка \GRM{}, например, одно или несколько правил. Это позволяет реализовать с помощью шаблонов концепцию \term{параметрических модулей}. 

Еще одним механизмом композиции, реализованным в \GRM{} являются аспекты. 
%Этот механизм обеспечивает выполнение двух основополагающих свойств:
%\begin{itemize}
%\item \term{Незнание} --- отсутствие необходимости специальным образом обозначать или иначе подготавливать участок программы, в который будет внесено изменение с помощью аспектов (``\term{совет}''). Другими словами, наличие аспекта не влияет на структуру программы, в которую он встраивается, то есть программа \term{не знает} о существовании аспекта.
%\item \term{Квантификация} --- возможность встроить один и тот же совет в несколько участков программы, описанных некоторым выражением. Это выражение играет роль \term{квантора} (аналогично квантору всеобщности в логике предикатов).
%\end{itemize}
Основополагающие понятия аспектно-ориентированного программирования реализуются в \GRM{} следующим образом:
\begin{itemize}
\item \term{Точками встраивания} (join points) являются все элементы языка \GRM{}, такие как символы, различные выражения, продукции и аннотации.
\item \term{Срезы} (point-cuts), обеспечивающие квантификацию (quantification), описываются в виде образцов (patterns), использующих как конструкции из \tabref{operations}, так и переменные, с которыми связываются конкретные фрагменты сопоставляемых выражений. Кроме того, используются подстановочные\term{подстановочные знаки}, соответствующие произвольным конструкциям одного определенного типа (например, произвольным выражениям или произвольным символам).
\item \term{Советы} (advice), описывающие изменения, привносимые в точках встраивания, позволяют встраивать результаты разворачивания данных шаблонных выражений до, после или вместо фрагментов точек встраивания.
\end{itemize}
Приведем пример \term{аспектного правила}, использующего данные понятия:
\begin{lstlisting}
example : .. e=example  .. ;
	instead ?e : '(' <?e> ')' ;
\end{lstlisting}
Данный пример заменяет рекурсивное вхождение символа \code{example} в правой части на тот же символ, заключенный в скобки. Другой способ записать то же преобразование использует вставку элементов до и после символа:
\begin{lstlisting}
example : .. e=example  .. ;
	before ?e : '(';
	after  ?e : ')';
\end{lstlisting}

С помощью аспектов достигается повторное использование  и расширение спецификаций, в которых не предусмотрены такие возможности (например, эти спецификации не являются шаблонными). Кроме того, этот механизм позволяет разделять спецификацию на фрагменты с различным назначением, например, отделять метаданные для различных генераторов от грамматических правил.

Целесообразность использования описанных механизмов композиции продемонстрирована на примере описания синтаксиса языка SQL92 и нескольких его диалектов, а также самого языка \GRM{}. В обоих случаях удается сократить объем спецификации и ослабить зависимости между модулями по сравнению с другими инструментами.
\afsubsection{Третья глава} посвящена описанию генератора трансляторов \ATF{}, построенного на базе языка \GRM{}. Целью создания этого генератора является не только демонстрация возможностей \GRM{}, но и решение задачи генерации кода на разных языках программирования по одной спецификации транслятора. Эта задача важна для разработки предметно-ориентированных языков, поскольку эти языки должны быть легко совместимыми с различными языками реализации, чтобы не ограничивать разработчиков в выборе платформы.

\ATF{} принимает на вход грамматику, аннотированную семантическими действиями, задающими схему L-атрибутной трансляции, и генерирует транслятор. Семантические действия могут использовать следующие операции: (а) чтение и запись атрибута, (б) вызов внешней функции, написанной на языке реализации, (в) передача параметров функциям, осуществляющим разбор. 
Отличительной особенностью \ATF{} является наличие статической проверки типов внутри семантических действий, гарантирующей отсутствие ошибок типизации в сгенерированном коде при условии корректной конфигурации генератора. Этот механизм обеспечивает раннее обнаружение ошибок, допущенных разработчиком транслятора, ускоряя таким образом процесс разработки.
Для генерации кода, непосредственно осуществляющего синтаксический анализ, могут быть использованы различные существующие генераторы, которые можно подключать к \ATF{}. Как правило бывает целесообразным использование различных существующих генераторов для различных языков реализации.

Механизм работы с типами, используемый в \ATF{}, имеет два уровня: \term{абстрактный уровень} выражает свойства общие для всех языков реализации; с помощью типов этого уровня проверяются семантические действия. \term{Конкретный уровень} описывает процесс генерации из типов и функций абстрактного уровня соответствующих элементов языка реализации. Таким образом, для данной спецификации существует ровно одна система типов абстрактного уровня и, возможно, несколько систем конкретного уровня --- как минимум, по одной на каждый язык реализации.

Системы типов абстрактного уровня поддерживают параметрический полиморфизм типов и функций, аналогично \tool{Java} (generics) или \tool{Haskell} (parametric polymorphism), причем поддерживается локальный вывод типов. Спецификация системы типов конкретного уровня позволяет отображать параметрически полиморфные функции сообразно специфике языка реализации: если параметрический полиморфизм не поддерживается, его можно заменить \term{ad hoc} полиморфизмом в той или иной форме, например, сгенерировать множество мономорфных функций --- по одной для каждого значения типовой переменной. 

\ATF{} предоставляет декларативные предметно-ориентированные языки для описания систем типов обоих уровней и программный интерфейс, позволяющий добавлять другие способы описания систем типов. С помощью последнего интерфейса реализована тесная интеграция с системой типов языка \tool{Java}.

Для демонстрации возможностей \ATF{} приведены примеры спецификаций, для которых определены системы типов конкретного уровня для двух языков реализации: \tool{Java} и \tool{C}. Из таких спецификаций можно генерировать код на соответствующих языках, используя один и тот же файл с описанием транслятора. Транслятор языка \GRM{} был реализован с помощью \ATF{} (основным языком реализации является \tool{Java}, а для генерации синтаксического анализатора используется \tool{ANTLR}).

\renewcommand{\thepart}{4}
\afsubsection{В четвертой главе} описан метод, позволяющий автоматически расширять предметно-ориентированные языки механизмами композиции, основанными на шаблонах и аспектах аналогичных использованным в языке \GRM{}. 

Механизм шаблонов \GRM{} обобщается для произвольного языка следующим образом. Выделяется набор \term{базовых понятий} (синтаксических категорий или классов в целевой мета-модели), характеризующих такой механизм в любом языке: \term{шаблон}, \term{параметр}, \term{шаблонное выражение}, \term{применение шаблона}, \term{использование шаблонного параметра}. Для каждого конкретного языка этот набор дополняется конкретными типами шаблонных выражений, соответствующих конструкциям данного языка. Шаблонные версии конструкций допускают использование шаблонных параметров и применений шаблонов вместо тех или иных своих частей. 

Семантика шаблонов определяется алгоритмом разворачивания, который обозначается $\Inst{\gamma}{\bullet}$, где \term{среда} $\gamma$ сопоставляет шаблонным параметрам фактические значения. Для применений базовых понятий этот алгоритм работает одинаково вне зависимости от конкретного языка, а для специфичных шаблонных выражений создаются экземпляры соответствующих конструкций языка и алгоритм вызывается рекурсивно на подвыражениях. Конечность такой процедуры обеспечивается тем, что шаблонам запрещено вызывать себя рекурсивно, и результирующие объекты, таким образом, всегда конечны. Время работы алгоритма разворачивания линейно от размера входных данных.

Для того, чтобы диагностика ошибок происходила в терминах исходной спецификации, содержащей шаблоны, а не в терминах результата разворачивания, необходимо иметь возможность убедиться в корректности результата, не осуществляя разворачивания. Эта задача решается с помощью системы типов, которая строится следующим образом: правила типизации для базовых понятий фиксированы; наиболее важные правила приведены на \figref{TmpTypes}.
\begin{figure}[htbp]
	\centering
$$
\trule{}{\Gamma \cup \{v : \tau\} \vdash \ang{?v} : \tau}{var}
$$ 
$$
\trule{
	\Gamma \cup \bigcup\limits_{i=1}^{n} \{ p_i : \tau_i \} \vdash b : \sigma
}{
	\Gamma \vdash \mathbf{template}\left(
		T \ang{p_1 : \tau_1, \ldots, p_n : \tau_n} \,: \sigma \, \{ b \}
	\right)
}{abstr}
$$ 
$$
\trule{
	\Gamma \vdash \mathbf{template}\left(
		T \ang{p_1 : \tau_1, \ldots, p_n : \tau_n} \,: \sigma \, \{ b \}
	\right)
	&
	\forall i : [1:n].\; \Gamma \vdash a_i : \tau_i \
}{
	\Gamma \vdash \ang{T \, a_1, \ldots, a_n} : \sigma
}{appl}
$$
	\caption{Основные правила системы типов языка шаблонов}\label{TmpTypes}
\end{figure}
Для специфичных шаблонных выражений генерируются новые правила системы типов, отражающие структурные ограничения, накладываемые целевой мета-моделью исходного языка (включая кратность ссылок).

Для построенных таким образом алгоритма $\Inst{\gamma}{\bullet}$ и системы типов доказаны следующие теоремы, показывающие, что система типов гарантирует корректность результата разворачивания.

\begin{Th}[О сохранении типов]
Если среда $\gamma$ согласована с контекстом $\Gamma$ и $\Gamma \vdash e : \tau$, то $\Gamma \vdash \Inst{\gamma}{e} : \tau$. Другими словами, преобразование $\Inst{}{\bullet}$ сохраняет типы.
\end{Th}

\begin{Th}[О нормализации]
Если среда $\gamma$ согласована с контекстом $\Gamma$ и $\Gamma \vdash e : \tau$, то вычисление $\Inst{\gamma}{e}$ заканчивается за конечное количество шагов, и результат не содержит применений шаблонов и шаблонных параметров.
\end{Th}

Аналогично названному выше строится алгоритм реконструкции типов, позволяющий пользователю не декларировать типы шаблонов и их параметров явно.

Поддержка аспектов строится на тех же принципах, что и поддержка шаблонов, причем многие конструкции, генерируемые для поддержки шаблонов используются также и для аспектов. Основные отличия лежат в области семантики, которая в случае аспектов описывается двумя алгоритмами: сопоставление выражения $e$ исходного языка с образцом (срезом) $p$, обозначаемое $\match{e}{p}$, и применение аспектного правила $\mathcal{R}$ в случае успешного сопоставления, обозначаемое $\rapply{\mathcal{R}}{e}$.

Операция сопоставления является в некотором смысле обратной к разворачиванию шаблона: вместо того, чтобы заменять вхождения переменных их значениями, она должна найти значения переменных, удовлетворяющие данному образцу. Основной интерес представляет алгоритм сопоставления коллекций (списков и множеств) в случае использования подстановочных знаков, допускающих сопоставление с частью коллекции. В случае списков для решения этой задачи применяется перебор с возвратами, а в случае множеств задача сводится к поиску максимальных паросочетаний в друдольных графах. В литературе показано, что задача сопоставления образцов является $NP$-полной при наличии переменных и неупорядоченных коллекций, и используемый алгоритм имеет экспоненциальную оценку времени работы в худшем случае, однако этот алгоритм показывает вполне приемлемые результаты на практике, что было установлено в процессе использования аспектов, реализованных в \GRM{}.

Применение аспектного правила сводится к замене объектов, сопоставленных переменным, другими объектами, полученными при разворачивании соответствующих шаблонов. В общем случае смысл имеют только советы с ключевым словом \code{instead}, то есть заменяющие, а не добавляющие, поскольку понятия вставки до и после могут не иметь смысла в конкретном языке. Тем не менее, если эти понятия имеют смысл, они легко реализуются через замену.

Система типов, используемая для статического контроля корректности результатов применения аспектов базируется на системе типов для шаблонов с той лишь разницей, что в случае аспектов требуется соответствие между типом переменной и шаблонным выражением, которым значения этой переменной будут заменены, что выражается следующим правилом:
$$
	\infer[aspect]{
		(\mathbf{instead} \; v \, : \, t) \in Allowed(\mathcal{R})
	}{
		\mathcal{R} = \langle p, T, V \rangle &
		p \vdash v : \tau &
		\Gamma(p) \vdash t : \sigma &
		\sigma \preceq \tau
	}
$$
Здесь $Allowed(\mathcal{R})$ обозначает множество всех корректных пар ``переменная-шаблонное выражение''.

В качестве примера применения описанного метода разработано расширение языка описания мета-моделей \tool{Emfatic}, добавляющее в данный язык поддержку композиции с помощью шаблонов и аспектов.

\afsubsection{Основные результаты диссертационной работы}
\begin{itemize}
\item Разработан предметно-ориентированный язык описания текстового синтаксиса, реализующий механизмы композиции, основанный на использовании модулей, шаблонов и аспектов. Продемонстрирована эффективность механизмов композиции, использованных в данном языке.
\item Разработан генератор трансляторов, поддерживающий проверку типов в семантических действиях и гарантирующий отсутствие ошибок типизации в сгенерированном коде сразу для многих языков реализации.
\item Предложен метод автоматизации разработки предметно-ориентированных языков с поддержкой механизмов композиции, основанных на шаблонах и аспектов.
\item С использованием предложенного подхода созданы расширения языка \tool{Emfatic}.
\end{itemize}

\par
\begin{center}
\afsubsection{Публикации по теме диссертационной работы}
\vspace{-40pt}
\end{center}
\makeatletter
\renewcommand\@biblabel[1]{#1.}
\makeatother
\renewcommand{\refname}{}
\input{autoref.bbl}

\end{document}

