\documentclass[12pt,a4paper]{article}

\usepackage{afterpage,fullpage,amsfonts,amsthm,amssymb,amsmath,indentfirst}

\usepackage{ucs}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}

\usepackage[english,russian]{babel}


%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{proof}
\usepackage[
	colorlinks=true,
	linkcolor=blue,
	citecolor=blue,
	urlcolor=blue
]{hyperref}
\usepackage{listings}

\renewcommand{\lstlistingname}{Листинг}

\lstset{
	inputencoding=utf8x, 
	extendedchars=\true, 
	basicstyle=\ttfamily\footnotesize,
	keywordstyle=\sffamily\bfseries,
	stringstyle=\sffamily,
	tabsize=4,
	captionpos=b,
	showstringspaces=false,
	xleftmargin=1cm,
}

\newcommand{\figref}[1]{Рис.~\ref{#1}}
\newcommand{\lstref}[1]{Лист.~\ref{#1}}
\newcommand{\tabref}[1]{Таб.~\ref{#1}}
\newcommand{\term}[1]{\emph{#1}}
\newcommand{\code}[1]{\mbox{\texttt{#1}}}
\newcommand{\tool}[1]{\textsc{#1}}

\theoremstyle{definition}
\newtheorem{Def}{Определение~}[part]
\theoremstyle{plain}
\newtheorem{Th}{Теорема~}[part]
\newtheorem{Lemm}[Th]{Лемма~}
\newtheorem{Prop}[Th]{Предложение~}
\newtheorem{Cor}{Следствие~}[Th]
\newtheorem{Note}{Замечание~}[part]
\newtheorem{Ex}{Пример~}[part]
\renewcommand{\proofname}{Доказательство}

\renewcommand{\theLemm}{\thepart.\arabic{Lemm}}
\renewcommand{\theTh}{\thepart.\arabic{Th}}
\renewcommand{\theProp}{\thepart.\arabic{Prop}}
\renewcommand{\theCor}{\theTh.\arabic{Cor}}
\renewcommand{\theNote}{\thepart.\arabic{Note}}
\renewcommand{\tablename}{Таблица}
\renewcommand{\lstlistingname}{Листинг}
\renewcommand{\figurename}{Рис.}
\renewcommand{\baselinestretch}{1.23}

\newcommand{\GRM}{\tool{Grammatic}}
\newcommand{\ATF}{\tool{Grammatic$^{SDT}$}}
%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\Inst}[2]{\mathcal{I}_{#1} \left[ #2 \right]}%
\newcommand{\trule}[3]{%
\infer[\mbox{#3}]{#2}{#1}%(\mbox{\textsc{#3}})%
}
\newcommand{\ang}[1]{\mathsf{<}#1\mathsf{>}}
\newcommand{\match}[2]{#1 \; \mathbf{match} \; #2}
\newcommand{\rapply}[2]{#1@#2}
%%%%%%%%%%%%%%%%%%%%%%%%%%

\voffset=-5mm
\rightmargin=0pt

%\input ../sty/aut14.cli
\input{aut14.cli}
\makeatletter
\def\paragraph{\@startsection{paragraph}{4}{\z@}%
{2ex plus 0.2ex minus.1ex}{-1em}{\reset@font\bf}}
 \makeatother
\date{}
\catcode`@ = 11 \catcode`@ = 12
\def\hiphantom#1{\underline{\phantom{#1}}}

\sloppy

\selectlanguage{russian} \makeatletter
\renewcommand{\@oddhead}{\hfill{\large -\thepage-}\hfill}
\renewcommand{\@oddfoot}{}
\renewcommand{\@evenhead}{\hfill{\large -\thepage-}\hfill}
\renewcommand{\@evenfoot}{}
%\renewcommand{\@makefntext}[1]{\parindent=1em\noindent
% \hbox to 1.8 em {\hss\Large$^{\@thefnmark}$}#1}
\makeatother \large
%title

\newcommand{\afsection}[1]{\par \begin{center}\textbf{\MakeUppercase{#1}}\end{center}}
\newcommand{\afsubsection}[1]{\par \textbf{\underline{#1}}}

\begin{document}

Механизмы композиции в предметно-ориентированных языках

и т.д.

\thispagestyle{empty}
\newpage


\setlength{\topmargin}{-5mm} \makeatletter
\renewcommand{\@oddhead}{\hfill{\large -\thepage-}\hfill}
\renewcommand{\@oddfoot}{}
\renewcommand{\@evenhead}{\hfill{\large -\thepage-}\hfill}
\renewcommand{\@evenfoot}{}
\makeatother

\afsection{Общая характеристика работы}

\afsubsection{Актуальность темы.}
Развитие технологии программирования исторически идет по пути повышения уровня абстракции поддерживаемого инструментами, используемыми при разработке программного обеспечения (ПО). Решающим шагом на этом пути являлось создание языков программирования высокого уровня, позволяющих лишь в небольшой степени заботиться об особенностях конкретной аппаратной архитектуры. Повышение уровня абстракции является ключевым фактором, определяющим затраты на разработку, поскольку высокоуровневые инструменты позволяют избегать определенных типов ошибок, повторно использовать разработанные решения и облегчают командную разработку.

С развитием языков высокого уровня неразрывно связан процесс развития автоматизированных инструментов разработки трансляторов, базирующийся на достижениях теории формальных языков и грамматик, в частности алгоритмах преобразования конекстно-свободных грамматик в магазинные автоматы и формализация семантики с помощью атрибутных грамматик.


предметно-ориентированные языки -- еще большее повышение уровня абстракции
непосредственно оперируют понятиями предметной области\\
примеры: SQL, make, graphviz, \TeX.\\
порождающее программирование: краткость, исключение многих ошибок
вручную создаются языки в таких областях как описание трансляторов, бизнес-процессов, компонентного и сервис-ориентированного ПО, безопасности, веб-приложений и т.д.

мотивация специфичной задачи\\
чтобы использовать ПОЯ было выгодно, необходимо, чтобы их разработка требовала малых затрат времени и денег. Это мотивирует автоматизацию разработки. Причем важно, чтобы получающиеся языки были удобны в использовании, иначе выгода от повышения уровня абстракции может быть сведена на нет неудобством языка. Общая цель использования ПОЯ --- повысить качество ПО, поэтому спецификации, написанные с использованием ПОЯ должны сами отвечать таким критериям качества как модульность, повторное использование, которые обеспечиваются механизмами (де-)композиции ПО, такими как модули, полиморфизм и аспекты. Для того, чтобы ПОЯ это могли, нужно, чтобы автоматизированные средства разработки позволяли поддерживать эту функциональность без существенных затрат времени.

\afsubsection{Предметом исследования} являются механизмы композиции, пригодные для использования в предметно-ориентированных языках.

\afsubsection{Целью работы} является исследование и обоснование подходов и методов, позволяющих автоматически расширять предметно-ориентированные языки механизмами композиции, поддерживающими повторное использование.

\afsubsection{Задачи исследования.} Достижение поставленной цели подразумевает решение следующих задач:
\begin{itemize}
\item Сравнительный анализ механизмов композиции, используемых в современных предметно-ориентированных языках, с целью обоснования требований к средствам автоматизации.
\item Проектирование и реализация предметно-ориентированного языка для хорошо изученной области (описание текстового синтаксиса искусственных языков), поддерживающего все основные механизмы композиции в полном объеме, с целью выявления связей между этими механизмами и их характерных особенностей, влияющих на подходы к автоматизации.
\item Демонстрация адекватности разработанного языка нуждам конечных пользователей на примере описания синтаксиса языка структурных запросов к реляционным базам данных SQL и его диалектов.
\item Обобщение рассмотренных механизмов композиции в виде формализованных языковых конструкций. Описание их семантики и соответствующих систем типов.
\item Разработка алгоритмов автоматического расширения языка механизмами композиции, обоснование их корректности.
\item Демонстрация работоспособности предложенного подхода на примере языка описания объектно-ориентированных мета-моделей Emfatic.
\end{itemize}

\afsubsection{Методы исследования} включают методы инженерии программного обеспечения, анализа алгоритмов и программ, аппарат теории типов и теории формальных грамматик.

\afsubsection{Научная новизна} результатов работы состоит в том, что:
\begin{itemize}
\item Спроектирован и реализован предметно-ориентированный язык для описания текстового синтаксиса, поддерживающий композицию спецификаций с помощью модулей, шаблонов (типизированных макроопредений) и аспектов.
\item Предложена формализация механизмов композиции на основе шаблонов и аспектов, и доказаны свойства данной формализации, гарантирующие раннее обнаружение ошибок программиста при использовании этих механизмов.
\item Разработаны и апробированы алгоритмы, позволяющие автоматизировать расширение предметно-ориентированных языков механизмами композиции, основанными на шаблонах и аспектах.
\end{itemize}

\afsubsection{Практическую ценность} работы составляют:
\begin{itemize}
\item Разработанная библиотека, обеспечивающая трансляцию предложенного языка описания текстового синтаксиса.
\item Программные генераторы, использующие данную библиотеку, позволяющие автоматически получать трансляторы и компоненты интегрированной среды разработки.
\item Методика и алгоритмы расширения предметно-ориентированных языков механизмами композиции.
\end{itemize}

\afsubsection{На защиту выносятся следующие положения:} 
\begin{itemize}
\item Предметно-ориентированный язык для описания текстового синтаксиса, поддерживающий композицию спецификаций с помощью модулей, шаблонов и аспектов.
\item Метод, позволяющий автоматически расширить имеющееся описание синтаксиса и семантики предметно-ориентированного языка таким образом, что результирующий язык поддерживает композицию с помощью шаблонов и аспектов.
\end{itemize}

\afsubsection{Достоверность научных результатов и выводов} обеспечивается формальной строгостью описания процесса композиции языков, обоснованностью применения математического аппарата, результатами тестирования алгоритмов и программного обеспечения, а также эмпирическими данными, полученными в результате применения разработанных программных компонент.

\afsubsection{Внедрение результатов работы.} Результаты, полученные в ходе диссертационной работы, были использованы 

-- при выполнении НИР по программе УМНИК ()
-- в учебном процессе 
-- при реализации рабочего пакета "Встроенные предметно-ориентированные языки" проекта "Продуктивность разработки ПО" в рамках шестилетней программы разработок научно-исследовательского центра STACC (Тарту, Эстония)

\afsubsection{Апробация работы.} Изложенные в диссертации результаты обсуждались на 11 российских и международных научных конференциях и семинарах и школах, включая V, VI и VII всероссийские межвузовские научные конференции молодых ученых (2008, 2009 и 2010 гг., Санкт-Петербург), международную научную конференцию ``Компьютерные науки и информационный технологии'' (2009 г., Саратов), международные научные школы ``Generative and Transformational Techniques in Software Engineering'' (2009 г., Брага, Португалия), ``Aspect-Oriented Software Development'' (2009 г., Нант, Франция) и ``15$^{th}$ Estonian Winter School in Computer Science'' (2010 г., Палмсе, Эстония), а так же международные семинары ``Teooriapäevad'' (2009 и 2010 гг., Эстония), семинар Лаборатории математической логики и семантики языков программирования Научно-исследовательского института кибернетики Эстонской Академии наук (2009 г., Таллинн, Эстония) и научном семинаре ``Computer Science Клуба'' при ПОМИ РАН (2009 г., Санкт-Петербург).

\afsubsection{Публикации.} По теме диссертации опубликовано пять печатных работ (из них две --- в изданиях, соответствующих требованиям ВАК РФ к кандидатским диссертациям).

-- Что считать, годы Вестника

\afsubsection{Структура и объем работы.} Диссертация состоит из введения, четырех глав, списка литературы (??? наименований) и 3 приложений. Содержит ??? с. текста (из них ??? основного текста и ??? --- приложений), включая ??? рис. и табл.

\afsection{Содержание работы}

\afsubsection{Во введении} обосновывается актуальность проблемы, формулируются цель и задачи исследования, отмечаются научная новизна и практическая значимость результатов, перечисляются основные положения, выносимые на защиту.

\afsubsection{Первая глава} посвящена обзору существующих подходов к автоматизации разработки предметно-ориентированных языков. Долгое время в этой области доминировали инструменты, предназначенные для разработки трансляторов текстовых языков, основанные на принципах синтаксически управляемой атрибутной трансляции. Наиболее популярными инструментами этого семейства являются \tool{Yacc}, \tool{Bison} и \tool{ANTLR}. Такие инструменты подразумевают описание синтаксиса языка с помощью контекстно-свободной грамматики, с продукциями которой ассоциированы правила вычисления атрибутов, описывающих семантические свойства предложений языка. С помощью атрибутов могут быть реализованы все стадии семантического анализа от разрешения имен до преобразования в машинный код. 

Основным недостатком традиционных средств разработки трансляторов применительно к созданию предметно-ориентированных языков является трудоемкость разработки. Это вызвано в первую очередь тем, что такие инструменты создавались как универсальные средства разработки языков программирования и не предназначены для быстрого решения типичных задач, возникающих при создании небольших языков.

Распространенным способом решения проблемы быстрой разработки ПОЯ является встраивание таких языков в языки общего назначения. При этом используются встроенные в язык общего назначения средства мета-программирования или гибкие синтаксические конструкции. Чаще всего ПОЯ встраиваются в динамические языки, такие как \tool{Ruby} или \tool{Groovy}, и в языки с гибкой системой типов, такие как \tool{Haskell} или \tool{Scala}. Основным недостатком данного подхода является привязка к тому или иному языку общего назначения: ПОЯ, легко встраиваемый в один язык, может быть практически невозможно встроить в другой. Это затрудняет повторное использование ПОЯ и приводит к смешиванию уровней абстракции: аспекты реализации сильно влияют на высокоуровневое описание предметной области.

Другое направление в развитии средств разработки языков основано на использовании графического синтаксиса вместо текстового. Толчок к развитию этого направление дал UML, унифицированный язык моделирования. Чаще всего нотации таких языков используют диаграммы, представляющие собой графы с различными типами вершин и ребер, уложенные на плоскости. Такие языки показали высокую эффективность при решении определенного круга задач, но они не заменяют текстовых языков, в частности, потому, что требуют серьезной инструментальной поддержки, что создает трудности с совместимостью и переносимостью. Следует отметить также, что в области графического синтаксиса существует подход, реализованный в проекте \tool{MPS}, объединившим сильные стороны текстового и графического синтаксиса. Однако в настоящее время этот подход также требует серьезной инструментальной поддержки, что создает препятствия к его использованию в индустрии.

С развитием идеи предметно-ориентированных языков стали появляться инструменты, ориентированные на быструю разработку автономного транслятора вместе с интегрированной средой разработки. Преимущества этих инструментов состоят в том, что они, во-первых, позволяют создавать простые трансляторы с минимальными затратами времени, а во-вторых, автоматически генерируют расширения для той или иной интегрированной среды, облегчающие разработчику создание и поддержку программ на новом языке. Как правило, такие инструменты ориентированы на решение типичных проблем, и реализация поддержки более сложных механизмов с их помощью затруднительна, однако на практике оказывается, что простота и скорость разработки являются очень весомым фактором, и именно этим инструментам отдают предпочтение разработчики. Возникает необходимость расширять возможности подобных средств, не увеличивая нагрузки на программиста, то есть идет о полной или практически полной автоматизации разработки тех или иных механизмов в языке. Одним из таких механизмов является композиция, обеспечивающая повторное использование спецификаций, основными примерами универсальных механизмов такого рода являются шаблоны (статически проверяемые макроопределения) и аспекты. Существующие подходы к автоматизации разработки таких механизмов не позволяют автоматически получать языки, поддерживающие их в полном объеме.

\afsubsection{Вторая глава} описывает предметно-ориентированный язык \GRM{}, предназначенный для описания текстового синтаксиса, поддерживающий композицию с помощью модулей, шаблонов и аспектов. Этот язык используется как обобщенная нотация, которую можно применять для при разработке различных инструментов, основанных на контекстно-свободных грамматиках. Реализация данного языка представляет собой библиотеку, позволяющую транслировать текстовые описания грамматик во внутреннее объектно-ориентированное представление, которое в дальнейшем используется различными генераторами для построения тех или иных компонент ПО, таких как синтаксические анализаторы и компоненты интегрированных сред разработки.

Основными конструкциями данного языка являются правила контекстно-свободной грамматики. Каждое правило включает одну или несколько продукций, описывающих один нетерминальный символ. При этом используются операции расширенной нотации BNF (см. \tabref{operations}). 
\begin{figure}[htbp]
\center
	\begin{tabular}{|c|l|}
	\hline
	\bf Нотация & \bf Значение \\
	\hline
	\code{\#empty} & Пустое выражение \\
	\code{a} & Ссылка на символ a \\
	\code{a b} & Последовательность \\
	\code{a | b} & Альтернатива \\
	\code{a*} & Итерация от 0 до бесконечности \\
	\code{a+} & Итерация от 1 до бесконечности \\
	\code{a?} & Итерация от 0 до 1 \\
	\code{['a'--'z']} & Множество символов от 'a' до 'z' \\
	\code{'abc'} & Строка символов 'abc' \\
	\code{(a | b) c} & Круглые скобки для группировки выражений \\
	\hline
	\end{tabular}
	\caption{Выражения \GRM{}}\label{operations}
\end{figure}
С помощью этих операций можно эффективно описать не только синтаксическую, но и лексическую структуру языка, поэтому терминальным алфавитом в спецификациях \GRM{} всегда считается Unicode, а лексические правила задаются в виде продукций для соответствующих нетерминальных символов. Пример использования \GRM{} для описания простого языка арифметических выражений приведен в \lstref{ArithSyn}.
\begin{lstlisting}[float=htbp,label=ArithSyn,caption=Синтаксис языка арифметических выражений]
	INT : ['0'--'9']+;
	VAR : ['a'--'z''A'--'Z''_']['a'--'z''A'--'Z''_''0'--'9']*;
	expr
		: expr '+' expr
		: expr '*' expr
		: '(' expr ')'
		: INT
		: VAR
		;
\end{lstlisting}

Большинство инструментов, основанных на контекстно-свободных грамматиках, используют дополнительные средства (\term{метаданные}) для описания семантики или других свойств языков. В языке \GRM{} этот подход обобщается за счет введения произвольных аннотаций, которые могут быть добавлены к любому элементу грамматики: символу, продукции, выражению и т.д. Каждая аннотация состоит из \term{атрибутов}, записываемых в форме ``имя = значение''. Предопределенные типы значений приведены в \tabref{valtypes}; разработчик может определять собственные типы значений.
\begin{figure}[htbp]
\center
	\begin{tabular}{|c|l|}
	\hline
	\bf Нотация & \bf Значение \\
	\hline
	\code{'abc'} & Строка \\
	\code{10} & Целое число \\
	\code{abc} & Идентификатор \\
	\code{\{ a = b; c = 10\}} & Аннотация \\
	\code{ \{\{ a, b, c ; \}\} } & Последовательность \\
	\code{ << s | (a b)* >> } & Грамматическое выражение \\
	\hline
	\end{tabular}
	\caption{Предопределенные типы значений атрибутов}\label{valtypes}
\end{figure}
Семантика аннотаций в \GRM{} не зафиксирована, что позволяет различным генераторам использовать их для различных целей, таких как описание атрибутной трансляции, классификация лексем для подсветки синтаксиса или спецификация правил автоматического форматирования кода.

Для повторного использования грамматик и их фрагментов применяются механизмы модулей, шаблонов и аспектов. Модули обеспечивают разделение спецификации на несколько физических файлов, имеющих собственные пространства имен символов. Включение одного модуля другим происходит с помощью директивы цитирования \code{import}, синтаксис которой иллюстрируется следующим примером:
\begin{lstlisting}
import 'a/b/c/d.grammar' {A, B as C};

B : A C*;
\end{lstlisting}  
Директива \code{import} принимает два аргумента: идентификатор импортируемого файла в одинарных кавычках и список импортируемых символов в фигурных скобках, который может быть заменен символом ``*'', если требуется импортировать все символы из данного модуля. Идентификатором файла является его имя в \term{виртуальной файловой системе}, конфигурация которой подается на вход транслятору \GRM{} вместе с файлом основной грамматики. Ключевое слово \code{as} в списке импортируемых символов для использования импортированного символа под другим именем.

Шаблоны (типизированные макроопределения) позволяют повторно использовать фрагменты грамматики, внося в них некоторые изменения, посредством подстановки на место параметров шаблона реальных значений. Проиллюстрируем описание шаблона следующим примером:
\begin{lstlisting}
template List<element : Expression, sep : Expression> : Expression {
	<?element> (<?sep> <?element>)*
}
\end{lstlisting}
Данный шаблон описывает грамматические выражения, задающие списки элементов, чередующихся с разделителем, например ``\code{INT ('*' INT)*}''. Здесь \code{List} --- имя шаблона, после него в угловых скобках следует список параметров с типами, позволяющими контролировать корректность результата разворачивания шаблона. В теле шаблона параметры можно использовать на вместо тех или иных фрагментов спецификации, указывая имена в угловых скобках со знаком вопроса (например, ``\code{<?sep>}''). Шаблон можно использовать, указав в угловых скобках его имя и аргументы, занимающие места формальных параметров, например, выражение \code{<List INT, '*'>} будет развернуто в \code{INT ('*' INT)*}. Результатом применения шаблона может быть не только грамматическое выражение, но и любая другая конструкция языка \GRM{}, например, одно или несколько правил. Это позволяет реализовать с помощью шаблонов концепцию \term{параметрических модулей}. 

Еще одним механизмом композиции, реализованным в \GRM{} являются аспекты. Этот механизм обеспечивает выполнение двух основополагающих свойств:
\begin{itemize}
\item \term{Незнание} --- отсутствие необходимости специальным образом обозначать или иначе подготавливать участок программы, в который будет внесено изменение с помощью аспектов (``\term{совет}''). Другими словами, наличие аспекта не влияет на структуру программы, в которую он встраивается, то есть программа \term{не знает} о существовании аспекта.
\item \term{Квантификация} --- возможность встроить один и тот же совет в несколько участков программы, описанных некоторым выражением. Это выражение играет роль \term{квантора} (аналогично квантору всеобщности в логике предикатов).
\end{itemize}
Основополагающие понятия аспектно-ориентированного программирования реализуются в \GRM{} следующим образом:
\begin{itemize}
\item \term{Точками встраивания} (join points) являются все элементы языка \GRM{}, такие как символы, различные выражения, продукции и аннотации.
\item \term{Срезы} (point-cuts), обеспечивающие квантификацию, описываются в виде образцов (patterns), использующих как конструкции из \tabref{operations}, так и переменные, с которыми связываются конкретные фрагменты сопоставляемых выражений. Кроме того, используются подстановочные\term{подстановочные знаки}, соответствующие произвольным конструкциям одного определенного типа (например, произвольным выражениям или произвольным символам).
\item \term{Советы} (advice), описывающие изменения, привносимые в точках встраивания, позволяют встраивать результаты разворачивания данных шаблонных выражений до, после или вместо фрагментов точек встраивания.
\end{itemize}
Приведем пример \term{аспектного правила}, использующего данные понятия:
\begin{lstlisting}
example : .. e=example  .. ;
	instead ?e : '(' <?e> ')' ;
\end{lstlisting}
Данный пример заменяет рекурсивное вхождение символа \code{example} в правой части на тот же символ, заключенный в скобки. Другой способ записать то же преобразование использует вставку элементов до и после символа:
\begin{lstlisting}
example : .. e=example  .. ;
	before ?e : '(';
	after  ?e : ')';
\end{lstlisting}

С помощью аспектов достигается повторное использование  и расширение спецификаций, в которых не предусмотрены такие возможности (например, эти спецификации не являются шаблонными). Кроме того, этот механизм позволяет разделять спецификацию на фрагменты с различным назначением, например, отделять метаданные для различных генераторов от грамматических правил.

\afsubsection{Третья глава} посвящена описанию генератора трансляторов \ATF{}, построенного на базе языка \GRM{}. Целью создания этого генератора является не только демонстрация возможностей \GRM{}, но и решение задачи генерации кода на разных языках программирования по одной спецификации транслятора. Эта задача важна для разработки предметно-ориентированных языков, поскольку эти языки должны быть легко совместимыми с различными языками реализации, чтобы не ограничивать разработчиков в выборе платформы.

\ATF{} принимает на вход грамматику, аннотированную семантическими действиями, задающими схему L-атрибутной трансляции, и генерирует транслятор. Семантические действия могут использовать следующие операции: (а) чтение и запись атрибута, (б) вызов внешней функции, написанной на языке реализации, (в) передача параметров функциям, осуществляющим разбор. 
Отличительной особенностью \ATF{} является наличие статической проверки типов внутри семантических действий, гарантирующей отсутствие ошибок типизации в сгенерированном коде при условии корректной конфигурации генератора. Этот механизм обеспечивает раннее обнаружение ошибок, допущенных разработчиком транслятора, ускоряя таким образом процесс разработки.
Для генерации кода, непосредственно осуществляющего синтаксический анализ, могут быть использованы различные существующие генераторы, которые можно подключать к \ATF{}. Как правило бывает целесообразным использование различных существующих генераторов для различных языков реализации.

Механизм работы с типами, используемый в \ATF{}, имеет два уровня: \term{абстрактный уровень} выражает свойства общие для всех языков реализации; с помощью типов этого уровня проверяются семантические действия. \term{Конкретный уровень} описывает процесс генерации из типов и функций абстрактного уровня соответствующих элементов языка реализации. Таким образом, для данной спецификации существует ровно одна система типов абстрактного уровня и, возможно, несколько систем конкретного уровня --- как минимум, по одной на каждый язык реализации.

Системы типов абстрактного уровня поддерживают параметрический полиморфизм типов и функций, аналогично \tool{Java} (generics) или \tool{Haskell} (parametric polymorphism), причем поддерживается локальный вывод типов. Спецификация системы типов конкретного уровня позволяет отображать параметрически полиморфные функции сообразно специфике языка реализации: если параметрический полиморфизм не поддерживается, его можно заменить \term{ad hoc} полиморфизмом в той или иной форме, например, сгенерировать множество мономорфных функций --- по одной для каждого значения типовой переменной. 

\ATF{} предоставляет декларативные предметно-ориентированные языки для описания систем типов обоих уровней и программный интерфейс, позволяющий добавлять другие способы описания систем типов. С помощью последнего интерфейса реализована тесная интеграция с системой типов языка \tool{Java}.

Для демонстрации возможностей \ATF{} приведены примеры спецификаций, для которых определены системы типов конкретного уровня для двух языков реализации: \tool{Java} и \tool{C}. Из таких спецификаций можно генерировать код на соответствующих языках, используя один и тот же файл с описанием транслятора. Транслятор языка \GRM{} был реализован с помощью \ATF{} (основным языком реализации является \tool{Java}, а для генерации синтаксического анализатора используется \tool{ANTLR}).

\renewcommand{\thepart}{4}
\afsubsection{В четвертой главе} описан метод, позволяющий автоматически расширять предметно-ориентированные языки механизмами композиции, основанными на шаблонах и аспектах аналогичных использованным в языке \GRM{}. 

Механизм шаблонов \GRM{} обобщается для произвольного языка следующим образом. Выделяется набор \term{базовых понятий} (синтаксических категорий или классов в целевой мета-модели), характеризующих такой механизм в любом языке: \term{шаблон}, \term{параметр}, \term{шаблонное выражение}, \term{применение шаблона}, \term{использование шаблонного параметра}. Для каждого конкретного языка этот набор дополняется конкретными типами шаблонных выражений, соответствующих конструкциям данного языка. Шаблонные версии конструкций допускают использование шаблонных параметров и применений шаблонов вместо тех или иных своих частей. 

Семантика шаблонов определяется алгоритмом разворачивания, который обозначается $\Inst{\gamma}{\bullet}$, где \term{среда} $\gamma$ сопоставляет шаблонным параметрам фактические значения. Для применений базовых понятий этот алгоритм работает одинаково вне зависимости от конкретного языка, а для специфичных шаблонных выражений создаются экземпляры соответствующих конструкций языка и алгоритм вызывается рекурсивно на подвыражениях. Конечность такой процедуры обеспечивается тем, что шаблонам запрещено вызывать себя рекурсивно, и результирующие объекты, таким образом, всегда конечны. Время работы алгоритма разворачивания линейно от размера входных данных.

Для того, чтобы диагностика ошибок происходила в терминах исходной спецификации, содержащей шаблоны, а не в терминах результата разворачивания, необходимо иметь возможность убедиться в корректности результата, не осуществляя разворачивания. Эта задача решается с помощью системы типов, которая строится следующим образом: правила типизации для базовых понятий фиксированы; наиболее важные правила приведены на \figref{TmpTypes}.
\begin{figure}[htbp]
	\centering
$$
\trule{}{\Gamma \cup \{v : \tau\} \vdash \ang{?v} : \tau}{var}
$$ 
$$
\trule{
	\Gamma \cup \bigcup\limits_{i=1}^{n} \{ p_i : \tau_i \} \vdash b : \sigma
}{
	\Gamma \vdash \mathbf{template}\left(
		T \ang{p_1 : \tau_1, \ldots, p_n : \tau_n} \,: \sigma \, \{ b \}
	\right)
}{abstr}
$$ 
$$
\trule{
	\Gamma \vdash \mathbf{template}\left(
		T \ang{p_1 : \tau_1, \ldots, p_n : \tau_n} \,: \sigma \, \{ b \}
	\right)
	&
	\forall i : [1:n].\; \Gamma \vdash a_i : \tau_i \
}{
	\Gamma \vdash \ang{T \, a_1, \ldots, a_n} : \sigma
}{appl}
$$
	\caption{Основные правила системы типов языка шаблонов}\label{TmpTypes}
\end{figure}
Для специфичных шаблонных выражений генерируются новые правила системы типов, отражающие структурные ограничения, накладываемые целевой мета-моделью исходного языка (включая кратность ссылок).

Для построенных таким образом алгоритма $\Inst{\gamma}{\bullet}$ и системы типов доказаны следующие теоремы, показывающие, что система типов гарантирует корректность результата разворачивания.

\begin{Th}[О сохранении типов]
Если среда $\gamma$ согласована с контекстом $\Gamma$ и $\Gamma \vdash e : \tau$, то $\Gamma \vdash \Inst{\gamma}{e} : \tau$. Другими словами, преобразование $\Inst{}{\bullet}$ сохраняет типы.
\end{Th}

\begin{Th}[О нормализации]
Если среда $\gamma$ согласована с контекстом $\Gamma$ и $\Gamma \vdash e : \tau$, то вычисление $\Inst{\gamma}{e}$ заканчивается за конечное количество шагов, и результат не содержит применений шаблонов и шаблонных параметров.
\end{Th}

Аналогично названному выше строится алгоритм реконструкции типов, позволяющий пользователю не декларировать типы шаблонов и их параметров явно.

Поддержка аспектов строится на тех же принципах, что и поддержка шаблонов, причем многие конструкции, генерируемые для поддержки шаблонов используются также и для аспектов. Основные отличия лежат в области семантики, которая в случае аспектов описывается двумя алгоритмами: сопоставление выражения $e$ исходного языка с образцом (срезом) $p$, обозначаемое $\match{e}{p}$, и применение аспектного правила $\mathcal{R}$ в случае успешного сопоставления, обозначаемое $\rapply{\mathcal{R}}{e}$.

Операция сопоставления является в некотором смысле обратной к разворачиванию шаблона: вместо того, чтобы заменять вхождения переменных их значениями, она должна найти значения переменных, удовлетворяющие данному образцу. Основной интерес представляет алгоритм сопоставления коллекций (списков и множеств) в случае использования подстановочных знаков, допускающих сопоставление с частью коллекции. В случае списков для решения этой задачи применяется перебор с возвратами, а в случае множеств задача сводится к поиску максимальных паросочетаний в друдольных графах. В литературе показано, что задача сопоставления образцов является $NP$-полной при наличии переменных и неупорядоченных коллекций, и используемый алгоритм имеет экспоненциальную оценку времени работы в худшем случае, однако этот алгоритм показывает вполне приемлемые результаты на практике, что было установлено в процессе использования аспектов, реализованных в \GRM{}.

Применение аспектного правила сводится к замене объектов, сопоставленных переменным, другими объектами, полученными при разворачивании соответствующих шаблонов. В общем случае смысл имеют только советы с ключевым словом \code{instead}, то есть заменяющие, а не добавляющие, поскольку понятия вставки до и после могут не иметь смысла в конкретном языке. Тем не менее, если эти понятия имеют смысл, они легко реализуются через замену.

Система типов, используемая для статического контроля корректности результатов применения аспектов базируется на системе типов для шаблонов с той лишь разницей, что в случае аспектов требуется соответствие между типом переменной и шаблонным выражением, которым значения этой переменной будут заменены, что выражается следующим правилом:
$$
	\infer[aspect]{
		(\mathbf{instead} \; v \, : \, t) \in Allowed(\mathcal{R})
	}{
		\mathcal{R} = \langle p, T, V \rangle &
		p \vdash v : \tau &
		\Gamma(p) \vdash t : \sigma &
		\sigma \preceq \tau
	}
$$
Здесь $Allowed(\mathcal{R})$ обозначает множество всех корректных пар ``переменная-шаблонное выражение''.

В качестве примера применения описанного метода разработано расширение языка описания мета-моделей \tool{Emfatic}, добавляющее в данный язык поддержку композиции с помощью шаблонов и аспектов.

\afsubsection{Основные результаты диссертационной работы}
\begin{itemize}
\item Разработан предметно-ориентированный язык описания текстового синтаксиса, реализующий механизмы композиции, основанный на использовании модулей, шаблонов и аспектов.
\item Продемонстрирована эффективность механизмов композиции, использованных в данном языке.
\item Предложен метод автоматизации разработки предметно-ориентированных языков с поддержкой механизмов композиции, основанных на шаблонах и аспектов.
\item С использованием предложенного подхода созданы расширения языков \tool{Emfatic} и \tool{SQL/DDL} для поддержки указанных механизмов композиции.
\end{itemize}

\par
\begin{center}
\afsubsection{Публикации по теме диссертационной работы}
\end{center}


\end{document}