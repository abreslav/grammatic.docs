\documentclass[12pt,a4paper]{article}

\usepackage{afterpage,fullpage,amsfonts,amsthm,amssymb,amsmath,indentfirst}

\usepackage{ucs}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}

\usepackage[english,russian]{babel}


%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[
	colorlinks=true,
	linkcolor=blue,
	citecolor=blue,
	urlcolor=blue
]{hyperref}
\usepackage{listings}

\renewcommand{\lstlistingname}{Листинг}

\lstset{
	inputencoding=utf8x, 
	extendedchars=\true, 
	basicstyle=\ttfamily\footnotesize,
	keywordstyle=\sffamily\bfseries,
	stringstyle=\sffamily,
	tabsize=4,
	captionpos=b,
	showstringspaces=false,
	xleftmargin=1cm,
}

\newcommand{\figref}[1]{Рис.~\ref{#1}}
\newcommand{\lstref}[1]{Лист.~\ref{#1}}
\newcommand{\tabref}[1]{Таб.~\ref{#1}}
\newcommand{\term}[1]{\emph{#1}}
\newcommand{\code}[1]{\mbox{\texttt{#1}}}
\newcommand{\tool}[1]{\textsc{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\voffset=-5mm
\rightmargin=0pt

%\input ../sty/aut14.cli
\input{aut14.cli}
\makeatletter
\def\paragraph{\@startsection{paragraph}{4}{\z@}%
{2ex plus 0.2ex minus.1ex}{-1em}{\reset@font\bf}}
 \makeatother
\date{}
\catcode`@ = 11 \catcode`@ = 12
\def\hiphantom#1{\underline{\phantom{#1}}}

\sloppy

\selectlanguage{russian} \makeatletter
\renewcommand{\@oddhead}{\hfill{\large -\thepage-}\hfill}
\renewcommand{\@oddfoot}{}
\renewcommand{\@evenhead}{\hfill{\large -\thepage-}\hfill}
\renewcommand{\@evenfoot}{}
%\renewcommand{\@makefntext}[1]{\parindent=1em\noindent
% \hbox to 1.8 em {\hss\Large$^{\@thefnmark}$}#1}
\makeatother \large
%title

\newcommand{\afsection}[1]{\par \begin{center}\textbf{\MakeUppercase{#1}}\end{center}}
\newcommand{\afsubsection}[1]{\par \textbf{\underline{#1}}}

\begin{document}

Механизмы композиции в предметно-ориентированных языках

и т.д.

\thispagestyle{empty}
\newpage


\setlength{\topmargin}{-5mm} \makeatletter
\renewcommand{\@oddhead}{\hfill{\large -\thepage-}\hfill}
\renewcommand{\@oddfoot}{}
\renewcommand{\@evenhead}{\hfill{\large -\thepage-}\hfill}
\renewcommand{\@evenfoot}{}
\makeatother

\afsection{Общая характеристика работы}

\afsubsection{Актуальность темы.}
широкая тема, имена
компьютерные языки высокого уровня, разработка языков программирования ...
синтаксис
Хомский, Наур (Бэкус)
семантика Кнут
автоматизация разработки трансляторов
Ахо (Yacc), Турчин, Гуревич, Мартыненко

узкая тема
предметно-ориентированные языки -- еще большее повышение уровня абстракции
непосредственно оперируют понятиями предметной области
примеры: SQL, make, graphviz, \TeX.
порождающее программирование: краткость, исключение многих ошибок
вручную создаются языки в таких областях как описание трансляторов, бизнес-процессов, компонентного и сервис-ориентированного ПО, безопасности, веб-приложений и т.д.

мотивация специфичной задачи
чтобы использовать ПОЯ было выгодно, необходимо, чтобы их разработка требовала малых затрат времени и денег. Это мотивирует автоматизацию разработки. Причем важно, чтобы получающиеся языки были удобны в использовании, иначе выгода от повышения уровня абстракции может быть сведена на нет неудобством языка. Общая цель использования ПОЯ --- повысить качество ПО, поэтому спецификации, написанные с использованием ПОЯ должны сами отвечать таким критериям качества как модульность, повторное использование, которые обеспечиваются механизмами (де-)композиции ПО, такими как модули, полиморфизм и аспекты. Для того, чтобы ПОЯ это могли, нужно, чтобы автоматизированные средства разработки позволяли поддерживать эту функциональность без существенных затрат времени.

\afsubsection{Предметом исследования} являются механизмы композиции, пригодные для использования в предметно-ориентированных языках.

\afsubsection{Целью работы} является решение задачи, имеющей существенное значение в области автоматизации разработки предметно-ориентированных языков, а именно --- исследование и обоснование подходов и методов, позволяющих автоматически расширять предметно-ориентированные языки механизмами композиции, поддерживающими повторное использование.

\afsubsection{Задачи исследования.} Достижение поставленной цели подразумевает решение следующих задач:
\begin{itemize}
\item Сравнительный анализ механизмов композиции, используемых в современных предметно-ориентированных языках, с целью обоснования требований к средствам автоматизации.
\item Проектирование и реализация предметно-ориентированного языка для хорошо изученной области (описание текстового синтаксиса искусственных языков), поддерживающего все основные механизмы композиции в полном объеме, с целью выявления связей между этими механизмами и их характерных особенностей, влияющих на подходы к автоматизации.
\item Демонстрация адекватности разработанного языка нуждам конечных пользователей на примере описания синтаксиса языка структурных запросов к реляционным базам данных SQL и его диалектов.
\item Обобщение рассмотренных механизмов композиции в виде формализованных языковых конструкций. Описание их семантики и соответствующих систем типов.
\item Разработка алгоритмов автоматического расширения языка механизмами композиции, обоснование их корректности.
\item Демонстрация работоспособности предложенного подхода на примере языка описания объектно-ориентированных мета-моделей Emfatic.
\end{itemize}

\afsubsection{Методы исследования} включают методы инженерии программного обеспечения, анализа алгоритмов и программ, аппарат теории типов и методы количественной оценки характеристик программного обеспечения.

\afsubsection{Научная новизна} результатов работы состоит в том, что:
\begin{itemize}
\item Спроектирован и реализован предметно-ориентированный язык для описания текстового синтаксиса, поддерживающий композицию спецификаций с помощью модулей, шаблонов (типизированных макроопредений) и аспектов.
\item Предложена формализация механизмов композиции на основе шаблонов и аспектов, и доказаны свойства данной формализации, гарантирующие раннее обнаружение ошибок программиста при использовании этих механизмов.
\item Разработаны и апробированы алгоритмы, позволяющие автоматизировать расширение предметно-ориентированных языков механизмами композиции, основанными на шаблонах и аспектах.
\end{itemize}

\afsubsection{Практическую ценность} работы составляют:
\begin{itemize}
\item Разработанная библиотека, обеспечивающая трансляцию предложенного языка описания текстового синтаксиса.
\item Программные генераторы, использующие данную библиотеку, позволяющие автоматически получать трансляторы и компоненты интегрированной среды разработки.
\item Методика и алгоритмов расширения предметно-ориентированных языков механизмами композиции.
\end{itemize}

\afsubsection{На защиту выносятся следующие положения:} 
\begin{itemize}
\item Предметно-ориентированный язык для описания текстового синтаксиса, поддерживающий композицию спецификаций с помощью модулей, шаблонов и аспектов.
\item Метод, позволяющий автоматически расширить имеющееся описание синтаксиса и семантики предметно-ориентированного языка таким образом, что результирующий язык поддерживает композицию с помощью шаблонов и аспектов.
\end{itemize}

\afsubsection{Достоверность научных результатов и выводов} обеспечивается формальной строгостью описания процесса композиции языков, обоснованностью применения математического аппарата, результатами тестирования алгоритмов и программного обеспечения, а также эмпирическими данными, полученными в результате применения разработанных программных компонент.

\afsubsection{Внедрение результатов работы.} Результаты, полученные в ходе диссертационной работы, были использованы 

-- при выполнении НИР по программе УМНИК ()
-- в учебном процессе 
-- при реализации рабочего пакета "Встроенные предметно-ориентированные языки" проекта "Продуктивность разработки ПО" в рамках шестилетней программы разработок научно-исследовательского центра STACC (Тарту, Эстония)

\afsubsection{Апробация работы.} Изложенные в диссертации результаты обсуждались на 11 российских и международных научных конференциях и семинарах и школах, включая V, VI и VII всероссийскую межвузовскую научную конференцию молодых ученых (2008, 2009 и 2010 гг., Санкт-Петербург), международную научную конференцию ``Компьютерные науки и информационный технологии'' (2009 г., Саратов), международные научные школы ``Generative and Transformational Techniques in Software Engineering'' (2009 г., Брага, Португалия), ``Aspect-Oriented Software Development'' (2009 г., Нант, Франция) и ``15$^{th}$ Estonian Winter School in Computer Science'' (2010 г., Палмсе, Эстония), а так же международные семинары ``Teooriapäevad'' (2009 и 2010 гг., Эстония), семинар Лаборатории математической логики и семантики языков программирования Научно-исследовательского института кибернетики Эстонской Академии наук (2009 г., Таллинн, Эстония) и научном семинаре ``Computer Science Клуба'' при ПОМИ РАН (2009 г., Санкт-Петербург).

\afsubsection{Публикации.} По теме диссертации опубликовано пять печатных работ (из них две --- в изданиях, соответствующих требованиям ВАК РФ к кандидатским диссертациям).

-- Что считать, годы Вестника

\afsubsection{Личный вклад автора}
???

\afsubsection{Структура и объем работы.} Диссертация состоит из введения, четырех глав, списка литературы (??? наименований) и 3 приложений. Содержит ??? с. текста (из них ??? основного текста и ??? --- приложений), включая ??? рис. и табл.

\afsection{Содержание работы}

\afsubsection{Во введении} обосновывается актуальность проблемы, формулируются цель и задачи исследования, отмечаются научная новизна и практическая значимость результатов, перечисляются основные положения, выносимые на защиту.

\afsubsection{Первая глава} посвящена обзору существующих подходов к автоматизации разработки предметно-ориентированных языков. Долгое время в этой области доминировали инструменты, предназначенные для разработки трансляторов текстовых языков, основанные на принципах синтаксически управляемой атрибутной трансляции. Наиболее популярными инструментами этого семейства являются \tool{Yacc}, \tool{Bison} и \tool{ANTLR}. Такие инструменты подразумевают описание синтаксиса языка с помощью контекстно-свободной грамматики, с продукциями которой ассоциированы правила вычисления атрибутов, описывающих семантические свойства предложений языка. С помощью атрибутов могут быть реализованы все стадии семантического анализа от разрешения имен до преобразования в машинный код. 

Основным недостатком традиционных средств разработки трансляторов применительно к созданию предметно-ориентированных языков является трудоемкость разработки. Это вызвано в первую очередь тем, что такие инструменты создавались как универсальные средства разработки языков программирования и не предназначены для быстрого решения типичных задач, возникающих при создании небольших языков.

Распространенным способом решения проблемы быстрой разработки ПОЯ является встраивание таких языков в языки общего назначения. При этом используются встроенные в язык общего назначения средства мета-программирования или гибкие синтаксические конструкции. Чаще всего ПОЯ встраиваются в динамические языки, такие как \tool{Ruby} или \tool{Groovy}, и в языки с гибкой системой типов, такие как \tool{Haskell} или \tool{Scala}. Основным недостатком данного подхода является привязка к тому или иному языку общего назначения: ПОЯ, легко встраиваемый в один язык, может быть практически невозможно встроить в другой. Это затрудняет повторное использование ПОЯ и приводит к смешиванию уровней абстракции: аспекты реализации сильно влияют на высокоуровневое описание предметной области.

Другое направление в развитии средств разработки языков основано на использовании графического синтаксиса вместо текстового. Толчок к развитию этого направление дал UML, унифицированный язык моделирования. Чаще всего нотации таких языков используют диаграммы, представляющие собой графы с различными типами вершин и ребер, уложенные на плоскости. Такие языки показали высокую эффективность при решении определенного круга задач, но они не заменяют текстовых языков, в частности, потому, что требуют серьезной инструментальной поддержки, что создает трудности с совместимостью и переносимостью. Следует отметить также, что в области графического синтаксиса существует подход, реализованный в проекте \tool{MPS}, объединившим сильные стороны текстового и графического синтаксиса. Однако в настоящее время этот подход также требует серьезной инструментальной поддержки, что создает препятствия к его использованию в индустрии.

С развитием идеи предметно-ориентированных языков стали появляться инструменты, ориентированные на быструю разработку автономного транслятора вместе с интегрированной средой разработки. Преимущества этих инструментов состоят в том, что они, во-первых, позволяют создавать простые трансляторы с минимальными затратами времени, а во-вторых, автоматически генерируют расширения для той или иной интегрированной среды, облегчающие разработчику создание и поддержку программ на новом языке. Как правило, такие инструменты ориентированы на решение типичных проблем, и реализация поддержки более сложных механизмов с их помощью затруднительна, однако на практике оказывается, что простота и скорость разработки являются очень весомым фактором, и именно этим инструментам отдают предпочтение разработчики. Возникает необходимость расширять возможности подобных средств, не увеличивая нагрузки на программиста, то есть идет о полной или практически полной автоматизации разработки тех или иных механизмов в языке. Одним из таких механизмов является композиция, обеспечивающая повторное использование спецификаций, основными примерами универсальных механизмов такого рода являются шаблоны (статически проверяемые макроопределения) и аспекты. Существующие подходы к автоматизации разработки таких механизмов не позволяют автоматически получать языки, поддерживающие их в полном объеме.

\afsubsection{Вторя глава} описывает предметно-ориентированный язык \tool{Grammatic}, предназначенный для описания текстового синтаксиса, поддерживающий композицию с помощью модулей, шаблонов и аспектов. Этот язык используется как обобщенная нотация, которую можно применять для при разработке различных инструментов, основанных на контекстно-свободных грамматиках. Реализация данного языка представляет собой библиотеку, позволяющую транслировать текстовые описания грамматик во внутреннее объектно-ориентированное представление, которое в дальнейшем используется различными генераторами для построения тех или иных компонент ПО, таких как синтаксические анализаторы и компоненты интегрированных сред разработки.

Основными конструкциями данного языка являются правила контекстно-свободной грамматики. Каждое правило включает одну или несколько продукций, описывающих один нетерминальный символ. При этом используются операции расширенной нотации BNF (см. \tabref{operations}). 
\begin{figure}[htbp]
\center
	\begin{tabular}{|c|l|}
	\hline
	\bf Нотация & \bf Значение \\
	\hline
	\code{\#empty} & Пустое выражение \\
	\code{a} & Ссылка на символ a \\
	\code{a b} & Последовательность \\
	\code{a | b} & Альтернатива \\
	\code{a*} & Итерация от 0 до бесконечности \\
	\code{a+} & Итерация от 1 до бесконечности \\
	\code{a?} & Итерация от 0 до 1 \\
	\code{['a'--'z']} & Множество символов от 'a' до 'z' \\
	\code{'abc'} & Строка символов 'abc' \\
	\code{(a | b) c} & Круглые скобки для группировки выражений \\
	\hline
	\end{tabular}
	\caption{Выражения \tool{Grammatic}}\label{operations}
\end{figure}
С помощью этих операций можно эффективно описать не только синтаксическую, но и лексическую структуру языка, поэтому терминальным алфавитом в спецификациях \code{Grammatic} всегда считается Unicode, а лексические правила задаются в виде продукций для соответствующих нетерминальных символов. Пример использования \tool{Grammatic} для описания простого языка арифметических выражений приведен в \lstref{ArithSyn}.
\begin{lstlisting}[float=htbp,label=ArithSyn,caption=Синтаксис языка арифметических выражений]
	INT : ['0'--'9']+;
	VAR : ['a'--'z''A'--'Z''_']['a'--'z''A'--'Z''_''0'--'9']*;
	expr
		: expr '+' expr
		: expr '*' expr
		: '(' expr ')'
		: INT
		: VAR
		;
\end{lstlisting}

Большинство инструментов, основанных на контекстно-свободных грамматиках, используют дополнительные средства (\term{метаданные}) для описания семантики или других свойств языков. В языке \tool{Grammatic} этот подход обобщается за счет введения произвольных аннотаций, которые могут быть добавлены к любому элементу грамматики: символу, продукции, выражению и т.д. Каждая аннотация состоит из \term{атрибутов}, записываемых в форме ``имя = значение''. Предопределенные типы значений приведены в \tabref{valtypes}; разработчик может определять собственные типы значений.
\begin{figure}[htbp]
\center
	\begin{tabular}{|c|l|}
	\hline
	\bf Нотация & \bf Значение \\
	\hline
	\code{'abc'} & Строка \\
	\code{10} & Целое число \\
	\code{abc} & Идентификатор \\
	\code{\{ a = b; c = 10\}} & Аннотация \\
	\code{ \{\{ a, b, c ; \}\} } & Последовательность \\
	\code{ << s | (a b)* >> } & Грамматическое выражение \\
	\hline
	\end{tabular}
	\caption{Предопределенные типы значений атрибутов}\label{valtypes}
\end{figure}
Семантика аннотаций в \tool{Grammatic} не зафиксирована, что позволяет различным генераторам использовать их для различных целей, таких как описание атрибутной трансляции, классификация лексем для подсветки синтаксиса или спецификация правил автоматического форматирования кода.

Для повторного использования грамматик и их фрагментов применяются механизмы модулей, шаблонов и аспектов. Модули обеспечивают разделение спецификации на несколько физических файлов, имеющих собственные пространства имен символов. Включение одного модуля другим происходит с помощью директивы цитирования \code{import}, синтаксис которой иллюстрируется следующим примером:
\begin{lstlisting}
import 'a/b/c/d.grammar' {A, B as C};

B : A C*;
\end{lstlisting}  
Директива \code{import} принимает два аргумента: идентификатор импортируемого файла в одинарных кавычках и список импортируемых символов в фигурных скобках, который может быть заменен символом ``*'', если требуется импортировать все символы из данного модуля. Идентификатором файла является его имя в \term{виртуальной файловой системе}, конфигурация которой подается на вход транслятору \tool{Grammatic} вместе с файлом основной грамматики. Ключевое слово \code{as} в списке импортируемых символов для использования импортированного символа под другим именем.

Шаблоны (типизированные макроопределения) позволяют повторно использовать фрагменты грамматики, внося в них некоторые изменения, посредством подстановки на место параметров шаблона реальных значений. Проиллюстрируем описание шаблона следующим примером:
\begin{lstlisting}
template List<element : Expression, sep : Expression> : Expression {
	<?element> (<?sep> <?element>)*
}
\end{lstlisting}
Данный шаблон описывает грамматические выражения, задающие списки элементов, чередующихся с разделителем, например ``\code{INT ('*' INT)*}''. Здесь \code{List} --- имя шаблона, после него в угловых скобках следует список параметров с типами, позволяющими контролировать корректность результата разворачивания шаблона. В теле шаблона параметры можно использовать на вместо тех или иных фрагментов спецификации, указывая имена в угловых скобках со знаком вопроса (например, ``\code{<?sep>}''). Шаблон можно использовать, указав в угловых скобках его имя и аргументы, занимающие места формальных параметров, например, выражение \code{<List INT, '*'>} будет развернуто в \code{INT ('*' INT)*}. Результатом применения шаблона может быть не только грамматическое выражение, но и любая другая конструкция языка \tool{Grammatic}, например, одно или несколько правил. Это позволяет реализовать с помощью шаблонов концепцию \term{параметрических модулей}. 

// Говорить про формализацию?

Еще одним механизмом композиции, реализованным в \tool{Grammatic} являются аспекты. Этот механизм обеспечивает выполнение двух основополагающих свойств:
\begin{itemize}
\item \term{Незнание} --- отсутствие необходимости специальным образом обозначать или иначе подготавливать участок программы, в который будет внесено изменение с помощью аспектов (``\term{совет}''). Другими словами, наличие аспекта не влияет на структуру программы, в которую он встраивается, то есть программа \term{не знает} о существовании аспекта.
\item \term{Квантификация} --- возможность встроить один и тот же совет в несколько участков программы, описанных некоторым выражением. Это выражение играет роль \term{квантора} (аналогично квантору всеобщности в логике предикатов).
\end{itemize}
Основополагающие понятия аспектно-ориентированного программирования реализуются в \tool{Grammatic} следующим образом:
\begin{itemize}
\item \term{Точками встраивания} (join points) являются все элементы языка \tool{Grammatic}, такие как символы, различные выражения, продукции и аннотации.
\item \term{Срезы} (point-cuts), обеспечивающие квантификацию, описываются в виде образцов (patterns), использующих как конструкции из \tabref{operations}, так и переменные, с которыми связываются конкретные фрагменты сопоставляемых выражений. Кроме того, используются подстановочные\term{подстановочные знаки}, соответствующие произвольным конструкциям одного определенного типа (например, произвольным выражениям или произвольным символам).
\item \term{Советы} (advice), описывающие изменения, привносимые в точках встраивания, позволяют встраивать результаты разворачивания данных шаблонных выражений до, после или вместо фрагментов точек встраивания.
\end{itemize}
Приведем пример \term{аспектного правила}, использующего данные понятия:
\begin{lstlisting}
example : .. e=example  .. ;
	instead ?e : '(' <?e> ')' ;
\end{lstlisting}
Данный пример заменяет рекурсивное вхождение символа \code{example} в правой части на тот же символ, заключенный в скобки. Другой способ записать то же преобразование использует вставку элементов до и после символа:
\begin{lstlisting}
example : .. e=example  .. ;
	before ?e : '(';
	after  ?e : ')';
\end{lstlisting}

С помощью аспектов достигается повторное использование  и расширение спецификаций, в которых не предусмотрены такие возможности (например, эти спецификации не являются шаблонными). Кроме того, этот механизм позволяет разделять спецификацию на фрагменты с различным назначением, например, отделять метаданные для различных генераторов от грамматических правил.

// Формализация

\afsubsection{Третья глава}

\afsubsection{Четвертая глава}

\afsubsection{Основные результаты диссертационной работы}

\par
\begin{center}
\afsubsection{Публикации по теме диссертационной работы}
\end{center}


\end{document}