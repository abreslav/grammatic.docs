\part{Генератор синтаксических анализаторов, построенный на базе \GRM{}}\label{part3}

\GRM{} предоставляет единый формат для записи контекстно-свободных грамматик и спецификаций на их основе. Если спецификация содержит дополнительную информацию, \GRM{} позволяет хранить ее в аннотациях. Как было показано выше, метаданные можно отделять от грамматики с помощью аспектов, получая несколько спецификаций из одной грамматики.

В настоящей главе мы рассмотрим генератор трансляторов \ATF{}, использующий возможности \GRM{} для решения задачи порождения кода транслятора сразу на нескольких языках программирования, причем гарантируется, что сгенерированный код не содержит ошибок типизации.

\chapter{Генераторы трансляторов}

Генератор трансляторов принимает на вход некоторую спецификацию и порождает код на некотором языке программирования, способный выполнять трансляцию текста во внутреннее представление в соответствии с правилами, указанными в спецификации.
Формат входных данных генератора мы будем называть \term{языком спецификации}, а язык программирования, код на котором генерируется --- \term{языком реализации}. Язык, синтаксис (и, возможно, семантику) которого описывает спецификация, мы будем называть \term{анализируемым языком}.

Языки спецификаций обычно основываются на атрибутных грамматиках \cite{???Knuth} в той или иной форме. В случае \ATF{} спецификация описывает схему синтаксически-управляемой трансляции \cite{???Dragon}, соответствующей \term{L-атрибутной грамматике} \cite{???}. Особенность таких грамматик состоит в том, что вне зависимости от направления анализа (нисходящий/восходящий) для вычисления атрибутов не требуется построения полного синтаксического дерева, поскольку атрибуты удается вычислять в процессе разбора. Наиболее популярные генераторы трансляторов используют именно этот подход \cite{???}.

\section{Модули анализа и генерации}

Любой генератор можно логически разделить на два взаимодействующих модуля: \term{модуль анализа}, читающий спецификацию, проверяющий ее корректность, и преобразующий ее во внутреннее представление, и \term{модуль генерации}, непосредственно порождающий код, читая внутреннее представление.
Модулей генерации может быть несколько, поскольку для переносимости реализации анализируемого языка и повторного использования спецификаций важно иметь возможность генерировать код на разных языках реализации.

// Рис?

Для удобства программиста важно выполнение следующего требования: \emph{если модуль анализа не обнаружил в спецификации ошибок и успешно построил внутреннее представление, модуль генерации должен построить код, не содержащий ошибок}.

В современных генераторах трансляторов это требование не соблюдается, что негативно сказывается на производительности разработчика. Проиллюстрируем это на примере разработки простого языка арифметических выражений с помощью одного из наиболее широкого используемых на сегодняшний день генераторов --- \tool{ANTLR}. Грамматика этого языка (без семантических действий) приведена в \lstref{arithexp}.
\begin{lstlisting}[texcl,language=ANTLR,label=arithexp,float=htbp,caption=Спецификация \tool{ANTLR} для языка арифметических выражений]
// Лексические правила
fragment LETTER : 'a'..'z' | 'A'..'Z' | '_' ;
fragment DIGIT  : '0'..'9' ;
VAR    : LETTER (LETTER | DIGIT)* ;
INT    : DIGIT+ ;
// Синтаксические правила
expr   : term (('+' | '-') term)* ;
term   : factor ('*' factor)* ;
factor : VAR | INT | '(' expr ')' ;
\end{lstlisting}
Нотация \tool{ANTLR} очень близка к нотации \GRM{} и в пояснении, по нашему мнению, не нуждается. Пусть необходимо разработать транслятор данного языка, вычисляющий значение выражения в процессе разбора. При этом значения переменных задаются внешней средой в виде объекта класса \code{Environment}, позволяющего получить значение переменной по имени. \tool{ANTLR} генерирует синтаксический анализатор основанный на методе рекурсивного спуска, поэтому каждое синтаксическое правило можно рассматривать как функцию, принимающую параметры (наследуемые атрибуты) и возвращающую значения (синтезируемые атрибуты). Семантические действия для правил \term{expr}, \term{term} и \term{factor} будут принимать объект \code{Environment} в качестве параметра и возвращать целочисленный результат вычисления. Соответствующий код на языке \tool{Java} пишется в фигурных скобках в том месте правила, где он должен быть вызван, аналогично схеме трансляции. 

Рассмотрим следующий вариант реализации семантических действий для правила \code{factor}:
\begin{lstlisting}[language=ANTLR]
factor[Environment env] returns [int result]
	: VAR { result = env.getValue($VAR.getText()); }
	| INT { result = $INT; }
	| '(' e=expr[env] ')' { result = e; } ;
\end{lstlisting}
По этой спецификации \tool{ANTLR} успешно генерирует код, содержащий следующий строки:
\begin{lstlisting}[language=Java,escapechar={!}]
	int result = 0;
	// ...
	Token INT2=null;
	// ...
	result = INT2;
\end{lstlisting}
При попытке скомпилировать этот фрагмент компилятором \tool{Java}, мы получим сообщение об ошибке на последней строке: значение \code{INT2} типа \code{Token} не может быть присвоено переменной \code{result}, имеющей тип \code{int}. Чтобы определить, в чем причина возникновения этой ошибки, нам необходимо вернуться к спецификации и вручную сопоставить сгенерированный код с соответствующим семантическим действием. В результате мы обнаружим, что использовали саму лексему \code{\$INT} вместо соответствующего ей текста, который можно получить, вызвав метод \code{getText()}. Мы вносим исправление в спецификацию:
\begin{lstlisting}[language=ANTLR]
factor //...
	| INT { result = $INT.getText(); }
\end{lstlisting}%$
Теперь нам необходимо снова запустить \tool{ANTLR}, чтобы получить и новую версию кода на \tool{Java}, а затем скомпилировать ее. Компилятор снова выдает сообщение об ошибке: значение \code{INT2.getText()} типа \code{String} не может быть присвоено переменной \code{result}, имеющей тип \code{int}. Мы снова возвращаемся к спецификации и конвертируем строку в число:
\begin{lstlisting}[language=ANTLR]
	| INT { result = Integer.parseInt($INT.getText()); }
\end{lstlisting}%$
После еще одного цикла генерации и компиляции, мы убеждаемся, что ошибка устранена. Всего нам понадобилось трижды запустить генератор и компилятор и дважды проследить, в каком месте в спецификации содержится причина возникновения ошибки в сгенерированном коде.

\section{Подходы, реализованные в современных генераторах}

В общем виде этот процесс, реализующийся при использовании любого генератора, не соответствующего сформулированному выше требованию, можно описать с помощью цикла, показанного на \figref{cycles} (а).
\begin{figure}[htbp]
\centering
\framebox{
\begin{minipage}{.45\textwidth}
\begin{enumerate}
\setlength{\itemsep}{0pt}
		\item Изменить спецификацию.
		\item Сгенерировать код.
		\item Попытаться скомпилировать код.
		\item Получить сообщения об ошибках в терминах языка реализации.
		\item Вручную отследить причины возникновения ошибок, содержащиеся в спецификации.
		\item Перейти к пункту 1.
\end{enumerate}
\centering
(а)
\end{minipage}
}
\framebox{
\begin{minipage}{.45\textwidth}
\begin{enumerate}
\setlength{\itemsep}{0pt}
		\item Изменить спецификацию.
		\item Попытаться сгенерировать код.
		\item Получить сообщения об ошибках в терминах языка спецификации.
		\item Перейти к пункту 1.
\end{enumerate}
\vspace{82pt}
\centering
(б)
\end{minipage}
}
\caption{Процесс устранения ошибки: (а) без статических проверок, (б) с проверками}\label{cycles}
\end{figure}
Основную сложность представляет необходимость вручную определять фрагмент спецификации, вызывающий ошибку. В принципе, модуль анализа мог бы делать это автоматически, но большинство современных инструментов, таких как \tool{ANTLR} или \tool{Bison} этого не делают, ограничиваясь лишь проверкой простейших условий, таких как наличие определений для всех символов, использованных в грамматике, без выполнения которых невозможно построение внутреннего представления. Семантические действия в этих инструментах рассматриваются как текстовые строки, и их содержание не анализируется.

Существуют генераторы, помогающие программисту в решении описанной проблемы. Так система \tool{Eli} \cite{???} анализирует сообщения об ошибках, выдаваемые компилятором, и автоматически находит соответствующие места в спецификации. Этот подход имеет два недостатка: во-первых, он привязан не только к одному языку реализации (используется язык \tool{C}), но и к одной версии компилятора, поскольку формат сообщений об ошибках может меняться. Система \tool{JastAdd} \cite{???} интегрируется с компилятором \tool{Java} и осуществляет точную диагностику ошибок, однако поддержка других языков реализации при таком подходе невозможна. Другой подход реализован в генераторе \tool{SableCC} \cite{???}: язык спецификаций вообще не поддерживает семантических действий, вместо этого разработчик должен вручную написать код на языке реализации, осуществляющий обход абстрактного синтаксического дерева и вычисляющий атрибуты. Такой подход в большей степени подвержен ошибкам и требует создания большего количества однотипного неинформативного кода.

\section{Задача \ATF{}}

Задачей \ATF{} является сокращение цикла работы со спецификацией до состояния, представленного на \figref{cycles} (б), при этом поддерживается возможность генерации кода на нескольких языках реализации по одной и той же спецификации.
Такая функциональность достигается за счет того, что семантические действия пишутся на абстрактном языке, в котором модуль анализа проверяет соблюдение правил типизации, а различные модули генерации строят код на соответствующих языках реализации.

В следующих разделах мы опишем язык спецификации, соответствующую систему типов и способы конфигурации модулей генерации и интеграции с различными языками реализации.

\chapter{Язык спецификаций \ATF{}}

\ATF{} использует нотацию \GRM{} для описания лексики и грамматики языков, при этом лексические правила явным образом помечаются атрибутом \code{lexical}, а игнорируемые терминалы, например, комментарии и пробельные символы --- еще и атрибутом \code{ignore}.

Спецификация описывает L-атрибутную трансляцию, при этом, аналогично \tool{ANTLR}, каждому правилу ставится в соответствие \term{функция трансляции}, принимающая наследуемые атрибуты в качестве параметров и возвращающая синтезируемые атрибуты. Это не означает, что \ATF{} способен генерировать только нисходящие анализаторы, использующие метод рекурсивного спуска, поскольку в случае восходящего анализа L-атрибутные определения тоже можно вычислить, вводя дополнительные продукции\footnote{Это делается автоматически в соответствующем модуле генерации.} \cite{???}. Тем не менее, о конструкциях, используемых в \ATF{}, удобнее всего думать в терминах рекурсивного спуска.

Телом функции трансляции, соответствующей правилу, является спецификация семантических действий, относящихся к различным позициям внутри правила, а также значения аргументов, передаваемых функциям трансляции, соответствующим символам, входящим в правые части продукций данного правила. В следующих подразделах мы опишем основные конструкции языка спецификации \ATF{} и проиллюстрируем их на примере интерпретатора арифметических выражений, который мы использовали в предыдущем разделе.

\section{Атрибуты и функции}

\term{Атрибут} в \ATF{} имеет имя и тип, в декларации разделяемые двоеточием, например
\begin{lstlisting}
result : Int
\end{lstlisting}
Атрибуты аналогичны переменным в императивных языках.

\term{Сигнатура} функции описывает ее имя, входные (наследуемые) и выходные (синтезируемые) атрибуты. Пример:
\begin{lstlisting}
factor (env : Environment) -> (result : Int)
\end{lstlisting}
Входные атрибуты описываются до стрелки, а выходные --- после. Отметим, что функция может возвращать кортеж из нескольких атрибутов.

В \ATF{} используются два вида функций:
\begin{itemize}
\item \term{функции трансляции} осуществляют разбор, обрабатывая входной поток, и вычисляют значения атрибутов;
\item \term{внешние функции} в \ATF{} описываются только сигнатурой, тела таких функций пишутся на языке реализации вне спецификации.
\end{itemize}
Встроенных операций, как и типов, в \ATF{} нет: арифметические и другие базовые операции реализуются в виде внешних функций.

Функции трансляции сопоставляются правилам грамматики следующим образом:
\begin{lstlisting}[language=Grammatic]
	N : ... ; // Синтаксическое правило
		translateN (in : Int) --> (out : Int) { // Сигнатура
			// Тело
		}
\end{lstlisting}
Полное описание функции, сигнатура и тело, записывается сразу после правила. Тело указывается в фигурных скобках. Одному правилу может соответствовать несколько функций трансляции, определяющих разные наборы семантических действий. 

В отличие от традиционной записи схемы трансляции, в \ATF{} семантические действия не встраиваются внутрь правил, а составляют тела функций трансляции. Для описания позиций, которым соответствуют действия, используются ключевые слова \code{after}, \code{before} и \code{at}. За счет этого удается достичь разделения семантических действий и правил грамматики.

Позиции семантических действий специфицируются следующим образом:
\begin{lstlisting}[escapeinside={!}{!},language=Grammatic]
	A : B C;
		translateA (...) --> (...) {
			...
			after B : !\textit{действие}! ;
			...
		}
\end{lstlisting}
После ключевого слова \code{after} указывается образец, \term{после} вхождения которого должно быть вычислено действие, отделенное двоеточием. В данном примере это просто вхождение символа \code{B}, но могут использоваться образцы произвольной сложности, описанные в предыдущей главе. Ключевое слово \code{before} имеет аналогичную семантику, но действие выполняется \term{до} вхождения, соответствующего образцу. 

Действия, указываемые справа от двоеточия, могут содержать декларации атрибутов, операции присваивания атрибутам и вызовы внешних функций. Если действие состоит из нескольких операций, они заключаются в фигурные скобки.

Ключевое слово \code{at} имеет иное значение: с его помощью описываются значения аргументов, передаваемых функциям трансляции и указывается, в какие атрибуты должны быть записаны результаты таких вызовов. После данного ключевого слова может быть указан только образец, имеющий тип \code{SymbolRefrence}. Пример:
\begin{lstlisting}[language=Grammatic]
	tmp : Int;
	at C : tmp = translateC(a, b) ;
\end{lstlisting}
В данном случае для обработки всех вхождений символа \code{C} будет вызвана функция трансляции \code{translateC} с аргументами \code{a} и \code{b}, а ее результат будет записан в \term{локальный} атрибут \code{tmp}. Локальный атрибут объявляется внутри тела функции трансляции и аналогичен локальной переменной.

\section{Пример спецификации}

Для того, чтобы проиллюстрировать использование основных конструкций, мы разберем спецификацию интерпретатора арифметических выражений, использующую эти конструкции. Для реализации интерпретатора нам понадобятся следующие внешние функции:
\begin{lstlisting}
	strToInt(s : String) --> (value : Int );
	value(env : Environment, variable : String) --> (value : Int);
	zero() --> (zero : Int);
	one() --> (one : Int);
	neg(x : Int) --> (negx : Int);
	add(x : Int, y : Int) --> (sum : Int);
	mul(x : Int, y : Int) --> (prod : Int);
\end{lstlisting}
Мы не имеем в виду никакого конкретного языка реализации. Все изложенное ниже имеет смысл для любого языка, поддерживающего числа и строки, в котором можно реализовать структуру данных, сопоставляющую строкам числа (для реализации среды).

Нам необходимо описать три функции трансляции --- по одной для каждого из нижеследующих правил:
\begin{lstlisting}
expr   : term (('+' | '-') term)* ;
term   : factor ('*' factor)* ;
factor : VAR | INT | '(' expr ')' ;
\end{lstlisting}
Каждая из этих функций будет принимать среду в качестве параметра и возвращать целочисленный результат. Для символа \code{factor} такая функция будет выглядеть так:
\begin{lstlisting}[
	label=factorTF,
%	caption=Функция трансляции для символа \code{factor},
	language=Grammatic]
factor : VAR | INT | '(' expr ')' ;           
  factor(Environment env) --> (Int result) { 
    after VAR : result = value(env, VAR#); // Внешняя функция
    after INT : result = strToInt(INT#);   // Внешняя функция
    at expr   : result = expr(env);        // Функция трансляции
  }
\end{lstlisting}
Использование ``\code{\#}'' после терминального символа (определение которого помечено атрибутом \code{lexical}) обозначает текстовое значение, сопоставленное данному соответствующее данному символу. Порядок следования элементов внутри функции не важен, поскольку каждое семантическое действие сопровождается информацией о позиции в правиле.

Приведенная в примере функция описывает следующие действия: 
\begin{itemize}
\item После обнаружения терминального символа \code{VAR} присвоить атрибуту \code{result} результат вызова внешней функции \code{value} от среды \code{env} и текста, соответствующего терминальному символу. Данная функция должна возвращать значение переменной с данным именем.
\item Аналогично для символа \code{INT}.
\item Для распознавания символа \code{expr} вызвать функцию разбора \code{expr} и параметром \code{env} и присвоить результат атрибуту \code{result}.
\end{itemize}
В некоторых случаях вызовы функций разбора могут быть опущены, но в данном примере это невозможно, поскольку необходимо указать значение аргумента.

Правило для символа \code{term} отличается тем, что имеет два вхождения одного и того же символа \code{factor}, семантические действия для которых различны (действия по ключевому слову \code{at} совпадают):
\begin{lstlisting}[
	language=Grammatic,	
	label=termTF,
%	caption=Translation function for \texttt{term},float=htbp
]
term : $f1=factor ('*' $f2=factor)* ;         
	term(Environment env) --> (Int result) {  
		Int f; // Объявление локального атрибута
		at factor : f = factor(env);      // Для обоих вхождений
		after $f1 : result = f;              // Только для \$f1
		after $f2 : result = mul(result, f); // Только для \$f2
	}
\end{lstlisting}
Для того, чтобы различать вхождения, в данном примере используются переменные \footnote{Синтаксис аналогичен использованному в \GRM{}, поскольку для реализации \ATF{} используется механизм аспектов, реализованный в \GRM{}}. Это позволяет сопоставить первому вхождению (переменная \code{\$f1}) присваивание, а второму (переменная \code{\$f2}) --- умножение и присваивание. Отметим, что вызов функции \code{factor} общий для обоих вхождений.


\begin{lstlisting}[
	language=Grammatic,	
	label=exprTF,
%	caption=Translation function for \texttt{expr},float=htbp
	]
expr : $t1=term ( $sgn=('+' | '-') term)* ;         
	expr(Environment env) --> (Int result) {  
  		at     term : t = term(env);
		before $t1  : {
			result = zero();
			sign = one();
		}
		after  term : result = add(result, mul(sign, t));
		before $sgn : sign = one();
		after  '-'  : sign = neg(sign);
  }
\end{lstlisting}

\chapter{Контроль типов в семантических действиях}

Общие правила системы типов

декларативное описание абстрактной системы типов

описание генератора

\chapter{Реализация на основе \GRM{}}

\chapter{Применение предложенного подхода}

Grammatic на Java

\chapter{Выводы}