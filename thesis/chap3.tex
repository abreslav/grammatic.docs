\part{Генератор синтаксических анализаторов, построенный на базе \GRM{}}\label{part3}

\GRM{} предоставляет единый формат для записи контекстно-свободных грамматик и спецификаций на их основе. Если спецификация содержит дополнительную информацию, \GRM{} позволяет хранить ее в аннотациях. Как было показано выше, метаданные можно отделять от грамматики с помощью аспектов, получая несколько спецификаций из одной грамматики.

В настоящей главе мы рассмотрим генератор трансляторов \ATF{}, использующий возможности \GRM{} для решения задачи порождения кода транслятора сразу на нескольких языках программирования, при чем гарантируется, что сгенерированный код не содержит ошибок типизации.

\chapter{Генераторы трансляторов}

Генератор трансляторов принимает на вход некоторую спецификацию и порождает код на некотором языке программирования, способный выполнять трансляцию текста во внутреннее представление в соответствии с правилами, указанными в спецификации.
Формат входных данных генератора мы будем называть \term{языком спецификации}, а язык программирования, код на котором генерируется --- \term{языком реализации}. Язык, синтаксис (и, возможно, семантику) которого описывает спецификация, мы будем называть \term{анализируемым языком}.

Языки спецификаций обычно основываются на атрибутных грамматиках \cite{???Knuth} в той или иной форме. В случае \ATF{} спецификация описывает схему синтаксически-управляемой трансляции \cite{???Dragon}, соответствующей \term{L-атрибутной грамматике} \cite{???}. Особенность таких грамматик состоит в том, что вне зависимости от направления анализа (нисходящий/восходящий) для вычисления атрибутов не требуется построения полного синтаксического дерева, поскольку атрибуты удается вычислять в процессе разбора. Наиболее популярные генераторы трансляторов используют именно этот подход \cite{???}.

Любой генератор можно логически разделить на два взаимодействующих модуля: \term{модуль анализа}, читающий спецификацию, проверяющий ее корректность, и преобразующий ее во внутреннее представление, и \term{модуль генерации}, непосредственно порождающий код, читая внутреннее представление.\\
// Рис?\\
Для удобства программиста важно выполнение следующего требования: \emph{если модуль анализа не обнаружил в спецификации ошибок и успешно построил внутреннее представление, модуль генерации должен построить код, не содержащий ошибок}.

В современных генераторах трансляторов это требование не соблюдается, что негативно сказывается на производительности разработчика. Проиллюстрируем это на примере разработки простого языка арифметических выражений с помощью одного из наиболее широкого используемых на сегодняшний день генераторов --- \tool{ANTLR}. Грамматика этого языка (без семантических действий) приведена в \lstref{arithexp}.
\begin{lstlisting}[texcl,language=ANTLR,label=arithexp,float=htbp,caption=Спецификация \tool{ANTLR} для языка арифметических выражений]
// Лексические правила
fragment LETTER : 'a'..'z' | 'A'..'Z' | '_' ;
fragment DIGIT  : '0'..'9' ;
VAR    : LETTER (LETTER | DIGIT)* ;
INT    : DIGIT+ ;
// Синтаксические правила
expr   : term (('+' | '-') term)* ;
term   : factor ('*' factor)* ;
factor : VAR | INT | '(' expr ')' ;
\end{lstlisting}
Нотация \tool{ANTLR} очень близка к нотации \GRM{} и в пояснении, по нашему мнению, не нуждается. Пусть необходимо разработать транслятор данного языка, вычисляющий значение выражения в процессе разбора. При этом значения переменных задаются внешней средой в виде объекта класса \code{Environment}, позволяющего получить значение переменной по имени. \tool{ANTLR} генерирует синтаксический анализатор основанный на методе рекурсивного спуска, поэтому каждое синтаксическое правило можно рассматривать как функцию, принимающую параметры (наследуемые атрибуты) и возвращающую значения (синтезируемые атрибуты). Семантические действия для правил \term{expr}, \term{term} и \term{factor} будут принимать объект \code{Environment} в качестве параметра и возвращать целочисленный результат вычисления. Соответствующий код на языке \tool{Java} пишется в фигурных скобках в том месте правила, где он должен быть вызван, аналогично схеме трансляции. 

Рассмотрим следующий вариант реализации семантических действий для правила \code{factor}:
\begin{lstlisting}[language=ANTLR]
factor[Environment env] returns [int result]
	: VAR { result = env.getValue($VAR.getText()); }
	| INT { result = $INT; }
	| '(' e=expr[env] ')' { result = e; } ;
\end{lstlisting}
По этой спецификации \tool{ANTLR} успешно генерирует код, содержащий следующий строки:
\begin{lstlisting}[language=Java,escapechar={!}]
	int result = 0;
	// ...
	Token INT2=null;
	// ...
	result = INT2;
\end{lstlisting}
При попытке скомпилировать этот фрагмент компилятором \tool{Java}, мы получим сообщение об ошибке на последней строке: значение \code{INT2} типа \code{Token} не может быть присвоено переменной \code{result}, имеющей тип \code{int}. Чтобы определить, в чем причина возникновения этой ошибки, нам необходимо вернуться к спецификации и вручную сопоставить сгенерированный код с соответствующим семантическим действием. В результате мы обнаружим, что использовали саму лексему \code{\$INT} вместо соответствующего ей текста, который можно получить, вызвав метод \code{getText()}. Мы вносим исправление в спецификацию:
\begin{lstlisting}[language=ANTLR]
factor //...
	| INT { result = $INT.getText(); }
\end{lstlisting}%$
Теперь нам необходимо снова запустить \tool{ANTLR}, чтобы получить и новую версию кода на \tool{Java}, а затем скомпилировать ее. Компилятор снова выдает сообщение об ошибке: значение \code{INT2.getText()} типа \code{String} не может быть присвоено переменной \code{result}, имеющей тип \code{int}. Мы снова возвращаемся к спецификации и конвертируем строку в число:
\begin{lstlisting}[language=ANTLR]
	| INT { result = Integer.parseInt($INT.getText()); }
\end{lstlisting}%$
После еще одного цикла генерации и компиляции, мы убеждаемся, что ошибка устранена. Всего нам понадобилось трижды запустить генератор и компилятор и дважды найти проследить, в каком месте в спецификации содержится причина возникновения ошибки в сгенерированном коде.

В общем виде этот процесс, реализующийся при использовании любого генератора, не соответствующего сформулированному выше требованию, можно описать с помощью цикла, показанного на \figref{cycles} (слева).
\begin{figure}[htbp]
\centering
\framebox{
\begin{minipage}{.45\textwidth}
\begin{enumerate}
\setlength{\itemsep}{0pt}
		\item Изменить спецификацию.
		\item Сгенерировать код.
		\item Попытаться скомпилировать код.
		\item Получить сообщения об ошибках в терминах языка реализации.
		\item Вручную отследить причины возникновения ошибок, содержащиеся в спецификации.
		\item Перейти к пункту 1.
\end{enumerate}
\end{minipage}
}
\framebox{
\begin{minipage}{.45\textwidth}
\begin{enumerate}
\setlength{\itemsep}{0pt}
		\item Изменить спецификацию.
		\item Попытаться сгенерировать код.
		\item Получить сообщения об ошибках в терминах языка спецификации.
		\item Перейти к пункту 1.
\end{enumerate}
\vspace{52pt}
\end{minipage}
}
\caption{Development cycles: conventional and with static checking}\label{cycles}
\end{figure}
\chapter{Спецификация синтаксического анализатора}

Схема трансляции

Атрибуты

Функции разбора

Внешние функции

\chapter{Контроль типов в семантических действиях}

Общие правила системы типов

декларативное описание абстрактной системы типов

описание генератора

\chapter{Применение предложенного подхода}

Grammatic на Java

\chapter{Выводы}