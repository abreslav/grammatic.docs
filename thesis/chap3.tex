\part{Генератор синтаксических анализаторов, построенный на базе \GRM{}}\label{part3}

\GRM{} предоставляет единый формат для записи контекстно-свободных грамматик и спецификаций на их основе. Если спецификация содержит дополнительную информацию, \GRM{} позволяет хранить ее в аннотациях. Как было показано выше, метаданные можно отделять от грамматики с помощью аспектов, получая несколько спецификаций из одной грамматики.

В настоящей главе мы рассмотрим генератор трансляторов \ATF{}, использующий возможности \GRM{} для решения задачи порождения кода транслятора сразу на нескольких языках программирования, причем гарантируется, что сгенерированный код не содержит ошибок типизации.

\chapter{Генераторы трансляторов}

Генератор трансляторов принимает на вход некоторую спецификацию и порождает код на некотором языке программирования, способный выполнять трансляцию текста во внутреннее представление в соответствии с правилами, указанными в спецификации.
Формат входных данных генератора мы будем называть \term{языком спецификации}, а язык программирования, код на котором генерируется --- \term{языком реализации}. Язык, синтаксис (и, возможно, семантику) которого описывает спецификация, мы будем называть \term{анализируемым языком}.

Языки спецификаций обычно основываются на атрибутных грамматиках \cite{???Knuth} в той или иной форме. В случае \ATF{} спецификация описывает схему синтаксически-управляемой трансляции \cite{???Dragon}, соответствующей \term{L-атрибутной грамматике} \cite{???}. Особенность таких грамматик состоит в том, что вне зависимости от направления анализа (нисходящий/восходящий) для вычисления атрибутов не требуется построения полного синтаксического дерева, поскольку атрибуты удается вычислять в процессе разбора. Наиболее популярные генераторы трансляторов используют именно этот подход \cite{???}.

\section{Модули анализа и генерации}

Любой генератор можно логически разделить на два взаимодействующих модуля: \term{модуль анализа}, читающий спецификацию, проверяющий ее корректность, и преобразующий ее во внутреннее представление, и \term{модуль генерации}, непосредственно порождающий код, читая внутреннее представление.
Модулей генерации может быть несколько, поскольку для переносимости реализации анализируемого языка и повторного использования спецификаций важно иметь возможность генерировать код на разных языках реализации.

// Рис?

Для удобства программиста важно выполнение следующего требования: \emph{если модуль анализа не обнаружил в спецификации ошибок и успешно построил внутреннее представление, модуль генерации должен построить код, не содержащий ошибок}.

В современных генераторах трансляторов это требование не соблюдается, что негативно сказывается на производительности разработчика. Проиллюстрируем это на примере разработки простого языка арифметических выражений с помощью одного из наиболее широкого используемых на сегодняшний день генераторов --- \tool{ANTLR}. Грамматика этого языка (без семантических действий) приведена в \lstref{arithexp}.
\begin{lstlisting}[texcl,language=ANTLR,label=arithexp,float=htbp,caption=Спецификация \tool{ANTLR} для языка арифметических выражений]
// Лексические правила
fragment LETTER : 'a'..'z' | 'A'..'Z' | '_' ;
fragment DIGIT  : '0'..'9' ;
VAR    : LETTER (LETTER | DIGIT)* ;
INT    : DIGIT+ ;
// Синтаксические правила
expr   : term (('+' | '-') term)* ;
term   : factor ('*' factor)* ;
factor : VAR | INT | '(' expr ')' ;
\end{lstlisting}
Нотация \tool{ANTLR} очень близка к нотации \GRM{} и в пояснении, по нашему мнению, не нуждается. Пусть необходимо разработать транслятор данного языка, вычисляющий значение выражения в процессе разбора. При этом значения переменных задаются внешней средой в виде объекта класса \code{Environment}, позволяющего получить значение переменной по имени. \tool{ANTLR} генерирует синтаксический анализатор основанный на методе рекурсивного спуска, поэтому каждое синтаксическое правило можно рассматривать как функцию, принимающую параметры (наследуемые атрибуты) и возвращающую значения (синтезируемые атрибуты). Семантические действия для правил \term{expr}, \term{term} и \term{factor} будут принимать объект \code{Environment} в качестве параметра и возвращать целочисленный результат вычисления. Соответствующий код на языке \tool{Java} пишется в фигурных скобках в том месте правила, где он должен быть вызван, аналогично схеме трансляции. 

Рассмотрим следующий вариант реализации семантических действий для правила \code{factor}:
\begin{lstlisting}[language=ANTLR]
factor[Environment env] returns [int result]
	: VAR { result = env.getValue($VAR.getText()); }
	| INT { result = $INT; }
	| '(' e=expr[env] ')' { result = e; } ;
\end{lstlisting}
По этой спецификации \tool{ANTLR} успешно генерирует код, содержащий следующий строки:
\begin{lstlisting}[language=Java,escapechar={!}]
	int result = 0;
	// ...
	Token INT2=null;
	// ...
	result = INT2;
\end{lstlisting}
При попытке скомпилировать этот фрагмент компилятором \tool{Java}, мы получим сообщение об ошибке на последней строке: значение \code{INT2} типа \code{Token} не может быть присвоено переменной \code{result}, имеющей тип \code{int}. Чтобы определить, в чем причина возникновения этой ошибки, нам необходимо вернуться к спецификации и вручную сопоставить сгенерированный код с соответствующим семантическим действием. В результате мы обнаружим, что использовали саму лексему \code{\$INT} вместо соответствующего ей текста, который можно получить, вызвав метод \code{getText()}. Мы вносим исправление в спецификацию:
\begin{lstlisting}[language=ANTLR]
factor //...
	| INT { result = $INT.getText(); }
\end{lstlisting}%$
Теперь нам необходимо снова запустить \tool{ANTLR}, чтобы получить и новую версию кода на \tool{Java}, а затем скомпилировать ее. Компилятор снова выдает сообщение об ошибке: значение \code{INT2.getText()} типа \code{String} не может быть присвоено переменной \code{result}, имеющей тип \code{int}. Мы снова возвращаемся к спецификации и конвертируем строку в число:
\begin{lstlisting}[language=ANTLR]
	| INT { result = Integer.parseInt($INT.getText()); }
\end{lstlisting}%$
После еще одного цикла генерации и компиляции, мы убеждаемся, что ошибка устранена. Всего нам понадобилось трижды запустить генератор и компилятор и дважды проследить, в каком месте в спецификации содержится причина возникновения ошибки в сгенерированном коде.

\section{Подходы, реализованные в современных генераторах}

В общем виде этот процесс, реализующийся при использовании любого генератора, не соответствующего сформулированному выше требованию, можно описать с помощью цикла, показанного на \figref{cycles} (а).
\begin{figure}[htbp]
\centering
\framebox{
\begin{minipage}{.45\textwidth}
\begin{enumerate}
\setlength{\itemsep}{0pt}
		\item Изменить спецификацию.
		\item Сгенерировать код.
		\item Попытаться скомпилировать код.
		\item Получить сообщения об ошибках в терминах языка реализации.
		\item Вручную отследить причины возникновения ошибок, содержащиеся в спецификации.
		\item Перейти к пункту 1.
\end{enumerate}
\centering
(а)
\end{minipage}
}
\framebox{
\begin{minipage}{.45\textwidth}
\begin{enumerate}
\setlength{\itemsep}{0pt}
		\item Изменить спецификацию.
		\item Попытаться сгенерировать код.
		\item Получить сообщения об ошибках в терминах языка спецификации.
		\item Перейти к пункту 1.
\end{enumerate}
\vspace{82pt}
\centering
(б)
\end{minipage}
}
\caption{Процесс устранения ошибки: (а) без статических проверок, (б) с проверками}\label{cycles}
\end{figure}
Основную сложность представляет необходимость вручную определять фрагмент спецификации, вызывающий ошибку. В принципе, модуль анализа мог бы делать это автоматически, но большинство современных инструментов, таких как \tool{ANTLR} или \tool{Bison} этого не делают, ограничиваясь лишь проверкой простейших условий, таких как наличие определений для всех символов, использованных в грамматике, без выполнения которых невозможно построение внутреннего представления. Семантические действия в этих инструментах рассматриваются как текстовые строки, и их содержание не анализируется.

Существуют генераторы, помогающие программисту в решении описанной проблемы. Так система \tool{Eli} \cite{???} анализирует сообщения об ошибках, выдаваемые компилятором, и автоматически находит соответствующие места в спецификации. Этот подход имеет два недостатка: во-первых, он привязан не только к одному языку реализации (используется язык \tool{C}), но и к одной версии компилятора, поскольку формат сообщений об ошибках может меняться. Система \tool{JastAdd} \cite{???} интегрируется с компилятором \tool{Java} и осуществляет точную диагностику ошибок, однако поддержка других языков реализации при таком подходе невозможна. Другой подход реализован в генераторе \tool{SableCC} \cite{???}: язык спецификаций вообще не поддерживает семантических действий, вместо этого разработчик должен вручную написать код на языке реализации, осуществляющий обход абстрактного синтаксического дерева и вычисляющий атрибуты. Такой подход в большей степени подвержен ошибкам и требует создания большего количества однотипного неинформативного кода.

\section{Задача \ATF{}}

Задачей \ATF{} является сокращение цикла работы со спецификацией до состояния, представленного на \figref{cycles} (б), при этом поддерживается возможность генерации кода на нескольких языках реализации по одной и той же спецификации.
Такая функциональность достигается за счет того, что семантические действия пишутся на абстрактном языке, в котором модуль анализа проверяет соблюдение правил типизации, а различные модули генерации строят код на соответствующих языках реализации.

В следующих разделах мы опишем язык спецификации, соответствующую систему типов и способы конфигурации модулей генерации и интеграции с различными языками реализации.

\chapter{Язык спецификаций \ATF{}}

\ATF{} использует нотацию \GRM{} для описания лексики и грамматики языков, при этом лексические правила явным образом помечаются атрибутом \code{lexical}, а игнорируемые терминалы, например, комментарии и пробельные символы --- еще и атрибутом \code{ignore}.

Синтаксические правила описывают L-атрибутную трансляцию, при этом, аналогично \tool{ANTLR}, каждому правилу ставится в соответствие \term{функция трансляции}, принимающая наследуемые атрибуты в качестве параметров и возвращающая синтезируемые атрибуты. Это не означает, что \ATF{} способен генерировать только нисходящие анализаторы, использующие метод рекурсивного спуска, поскольку в случае восходящего анализа L-атрибутные определения тоже можно вычислить, вводя дополнительные продукции\footnote{Это делается автоматически в соответствующем модуле генерации.} \cite{???}.

Телом функции трансляции, соответствующей правилу, является спецификация семантических действий, относящихся к различным позициям внутри правила, а также значения аргументов, передаваемых функциям трансляции, соответствующим символам, входящим в правые части продукций данного правила. В следующих подразделах мы опишем основные конструкции языка спецификации \ATF{} и проиллюстрируем их на примере интерпретатора арифметических выражений, который мы использовали в предыдущем разделе.

\section{Атрибуты и функции}

\term{Атрибут} в \ATF{} имеет имя и тип, в декларации разделяемые двоеточием, например
\begin{lstlisting}
result : Int
\end{lstlisting}
Атрибуты аналогичны переменным в императивных языках.

\term{Сигнатура} функции описывает ее имя, входные (наследуемые) и выходные (синтезируемые) атрибуты. Пример:
\begin{lstlisting}
factor (env : Environment) -> (result : Int)
\end{lstlisting}
Входные атрибуты описываются до стрелки, а выходные --- после. Отметим, что функция может возвращать кортеж из нескольких атрибутов.

В \ATF{} используются два вида функций:
\begin{itemize}
\item \term{функции трансляции} осуществляют разбор, обрабатывая входной поток, и вычисляют значения атрибутов;
\item \term{внешние функции} в \ATF{} описываются только сигнатурой, тела таких функций пишутся на языке реализации вне спецификации.
\end{itemize}
Встроенных операций, как и типов, в \ATF{} нет: арифметические и другие базовые операции реализуются в виде внешних функций.

Функции трансляции сопоставляются правилам грамматики следующим образом:
\begin{lstlisting}[language=Grammatic]
	N : ... ; // Синтаксическое правило
		translateN (in : Int) --> (out : Int) { // Сигнатура
			// Тело
		}
\end{lstlisting}
Полное описание функции, сигнатура и тело, записывается сразу после правила.
Тело указывается в фигурных скобках.
В отличие от традиционной записи схемы трансляции, в \ATF{} семантические действия не встраиваются внутрь правил, а составляют тела функций трансляции. Для описания позиций, которым соответствуют действия, используются ключевые слова \code{after}, \code{before} и \code{at}. За счет этого удается достичь разделения семантических действий и правил грамматики.

Позиции семантических действий специфицируются следующим образом:
\begin{lstlisting}[escapeinside={!}{!},language=Grammatic]
	A : B C;
		translateA (...) --> (...) {
			...
			after B : !\textit{действие}! ;
			...
		}
\end{lstlisting}
После ключевого слова \code{after} указывается образец, \term{после} вхождения которого должно быть вычислено действие, отделенное двоеточием. В данном примере это просто вхождение символа \code{B}, но могут использоваться образцы произвольной сложности, описанные в предыдущей главе. Ключевое слово \code{before} имеет аналогичную семантику, но действие выполняется \term{до} вхождения, соответствующего образцу. 

Действия, указываемые справа от двоеточия, могут содержать декларации атрибутов, операции присваивания атрибутам и вызовы внешних функций. Если действие состоит из нескольких операций, они заключаются в фигурные скобки.

Ключевое слово \code{at} имеет иное значение: с его помощью описываются значения аргументов, передаваемых функциям трансляции и указывается, в какие атрибуты должны быть записаны результаты таких вызовов. После данного ключевого слова может быть указан только образец, имеющий тип \code{SymbolRefrence}. Пример:
\begin{lstlisting}[language=Grammatic]
	tmp : Int;
	at C : tmp = translateC(a, b) ;
\end{lstlisting}
В данном случае для обработки всех вхождений символа \code{C} будет вызвана функция трансляции \code{translateC} с аргументами \code{a} и \code{b}, а ее результат будет записан в атрибут \code{tmp}.


\begin{itemize}
\item 
\end{itemize}

\section{Пример спецификации}

Для того, чтобы проиллюстрировать использование основных конструкций, мы разберем спецификацию интерпретатора арифметических выражений, использующую эти конструкции.



Функции разбора

Внешние функции

\chapter{Контроль типов в семантических действиях}

Общие правила системы типов

декларативное описание абстрактной системы типов

описание генератора

\chapter{Применение предложенного подхода}

Grammatic на Java

\chapter{Выводы}