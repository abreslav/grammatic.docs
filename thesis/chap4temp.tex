\chapter{Автоматическое построение языков, поддерживающих типизированные макроопределения}

В настоящем разделе описан метод, позволяющий по описанию языка построить описание более богатого языка, поддерживающего композицию с помощью типизированных макроопределений. Мы будем называть такой пополненный язык \term{макро-языком}, построенным на базе исходного языка.

\begin{Note}[О терминологии]
В англоязычной литературе используется термин \term{macro} \cite{MacroML,Cpp,Nemerle}. 
В качестве русского перевода этого термина употребляется либо слово ``макрос'', являющееся в сущности сленговым и полученное транслитерацией множественного числа ``macros'', либо слово ``макроопределение'', соответствующее более узкому по смыслу термину ``macro definition''. 
Близкой по смыслу альтернативой является термин ``шаблон'' (англ. ``template''), используемый в языке 
\tool{C++} 
\cite{C++} 
и ряде других~\cite{HTMP,Velocity,UML}. 

Мы считаем термин ``macro'' более подходящим для наших целей, и будем, следуя традиции, использовать более формальный вариант его перевода --- \term{макроопределение}.
\end{Note}

\section{Неформальное описание механизма композиции, основанного на макроопределениях}

Наиболее известными системами, использующими макроопределения, являются язык программирования \tool{LISP}~\cite{Lisp} и препроцессор языка \tool{C}~\cite{C, Cpp}. В обоих случаях макроопределения служат для обогащения языка новыми конструкциями, которые преобразуются в базовые конструкции языка во время компиляции\footnote{Понятие ``время компиляции'' в данном контексте является собирательным и противопоставляется понятию ``время выполнения программы''.}, этот процесс называется \term{разворачиванием} макроопределений.

Приведем пример использования макроопределений в языке \tool{C}: пусть нам требуется реализовать односвязные списки. Для этого в первую очередь необходимо описать \emph{структуру} элемента списка, например, для списка целых чисел эта структура будет выглядеть следующим образом:
\begin{lstlisting}[language=C]
struct IntList {
	struct IntList* next;
	int data;
};
\end{lstlisting}
Для списка элементов другого типа, например, строк, структура будет очень похожей, но тип поля \code{data} будет отличаться:
\begin{lstlisting}[language=C]
struct StrList {
	struct StrList* next;
	char* data;
};
\end{lstlisting}
Дублировать описания для каждого нового типа элементов не очень удобно, поэтому мы напишем макроопределение, которое по данному типу элемента генерирует описание соответствующей структуры\footnote{Задача, которую мы решаем в этом примере с помощью макроопределений языка \tool{C}, более эффективно решается в языке \tool{C++} с помощью \emph{шаблонных структур}, которые можно рассматривать как узкоспециализированную разновидность макроопределений.}:
\begin{lstlisting}[language=C]
#define DEFLIST(name, type) struct name { \
	struct name *next; \
	type data; \
};
\end{lstlisting}
После директивы \code{\#define} следует \emph{имя} макроопределения, а за ним в скобках --- \emph{параметры}. Весь остальной текст --- это \emph{тело} макроопределения (знак ``$\backslash$'' используется для подавления перевода строки). Для того, чтобы использовать данное макроопределение, достаточно написать его имя и передать в скобках значения параметров (то есть \emph{аргументы}), например:

\begin{lstlisting}[language=C]
DEFLIST(StrList, char*)
\end{lstlisting}
В результате \emph{разворачивания} данного определения аргументы будут подставлены в тело вместо соответствующих параметров и мы получим определение структуры \code{StrList}, приводившееся выше. Аналогично можно получить определения структуры \code{IntList}, а также структуры элемента списка для любого типа. Заметим, что разворачивание происходит во время компиляции и результатом является исходный текст на языке \tool{C}, который, в свою очередь, транслируется в машинный код, причем транслятор ничего не знает о том, были использованы макроопределения или нет. 

Обобщая сведения, приведенные в данном примере, можно выделить следующие свойства, присущие механизму макроопределений\footnote{Такое обобщение имеет смысл, поскольку в различных языках и системах макроопределения функционируют схожим образом.}:
\begin{itemize}
\item Макроопределение состоит из \emph{списка параметров} и \emph{тела} и имеет уникальное \emph{имя}.
\item Тело макроопределения содержит конструкции на целевом языке (в нашем примере --- на языке \tool{C}) и ссылки на параметры. Также тело может содержать обращения к другим макроопределениям.
\item При разворачивании ссылки на параметры в теле макроопределения заменяются значениями соответствующих аргументов.
\item Разворачивание происходит во время компиляции программы.
\end{itemize}

Макроопределения представляют собой достаточно гибкий механизм повторного использования. В принципе, этот механизм не зависит от целевого языка, в который разворачиваются макроопределения. В частности, в языке \tool{C} поддержка макроопределений обеспечивается препроцессором \tool{Cpp} --- независимым программным средством, обрабатывающим исходный код \term{до} начала работы собственно компилятора языка \tool{C}. Препроцессор \tool{Cpp} может работать с любым текстом, не только с исходным кодом на языке \tool{C}, следовательно он (или аналогичный механизм) может применяться для повторного использования и в других языках, в частности в предметно-ориентированных, делая их более пригодными для использования в промышленных проектах.

Однако чисто текстовый препроцессор обладает одним важным недостатком: корректность результата разворачивания макроопределений никак не гарантируется, поскольку препроцессор манипулирует простым текстом и ``не знает'' о синтаксисе целевого языка.

Вернемся к примеру макроопределения, приведенному выше. Если программист допустит ошибку при использовании макроопределения \code{DEFLIST}, а именно перепутает порядок аргументов, что случается не так уж редко, препроцессор послушно выполнит свою работу:
\begin{lstlisting}[language=C]
DEFLIST(char*, StrList)
\end{lstlisting}
превратится в
\begin{lstlisting}[language=C]
struct char* {  // error: expected '\{' before 'char'
    struct char* *next; 
    StrList data; 
};
\end{lstlisting}
Получившийся код синтаксически некорректен, и компилятор, получив этот текст на вход, выдаст сообщение об ошибке:
\begin{lstlisting}[language=C]
DEFLIST(char*, StrList) // error: expected '\{' before 'char'
\end{lstlisting}
В итоге ошибка программиста обнаружена, но сообщение, выданное компилятором, записано в терминах программы, полученной после разворачивания макроопределений, и совсем не помогает программисту исправить ситуацию. Чтобы разобраться, в чем проблема, придется вручную рассмотреть код, полученный на выходе препроцессора, что является существенным затруднением при разработке больших проектов.
Описанная здесь проблема является основной причиной, по которой профессиональные программисты зачастую избегают широкого использования возможностей макроопределений в программах на \tool{C} \cite{CodeComplete}. 

Итак, чисто текстовый препроцессор позволяет легко обеспечить поддержку макроопределений в любом языке, но не обеспечивает своевременного обнаружения ошибок, что затрудняет разработку. В данной главе мы рассмотрим метод реализации макроопределений, который также пригоден для любого языка, но обеспечивает контроль корректности аргументов макроопределений с помощью специальной системы типов, что позволяет избежать проблем, присущих чисто текстовым препроцессорам. Такие макроопределения мы будем называть \emph{шаблонами} (templates).

\section{Шаблоны в языках, порожденных метамоделями}

Вернемся к примеру описания структуры элементов списка в языке \tool{C}. Для начала рассмотрим абстрактный синтаксис такого описания; соответствующая метамодель приведена на \figref{c-struct-mm}. 
%
\figdef{c-struct-mm}{Метамодель абстрактного синтаксиса описаний структур в языке \tool{C}}
%
Мы не ставим целью рассмотрение возможностей языка \tool{C} во всем их многообразии, поэтому наша метамодель позволяет оперировать лишь весьма ограниченным набором типов: структурами (\code{Struct} и \code{StructType}), указателями (\code{PointerType}) и примитивными типами \code{int} (\code{IntType}) и \code{char} (\code{CharType)}.

На \figref{int-list-struct} приведена диаграмма, соответствующая описанию структуры \code{IntList}, уже приводившемуся выше:
\begin{lstlisting}[language=C]
struct IntList {
	struct IntList* next;
	int data;
};
\end{lstlisting}
%
\figdef{int-list-struct}{Модель, описывающая структуру \code{IntList}}
%
Объект класса \code{Struct} хранит список, состоящий из объектов класса 	\code{Field}, каждый из которых имеет тип и имя.

Теперь преобразуем модель на \figref{int-list-struct} в шаблон, аналогичный макроопределению \code{DEFLIST} из предыдущего раздела:
\begin{lstlisting}[language=C]
#define DEFLIST(name, type) struct name { \
	struct name *next; \
	type data; \
};
\end{lstlisting}
Что для этого нужно сделать? Нужно добавить специальные объекты, представляющие структуру шаблона. На \figref{deflist-template} эти объекты выделены зеленым цветом фона.
%
\figdef{deflist-template}{Шаблон описания структуры элемента списка}
%
Рассмотрим новую диаграмму подробнее. Корневым элементом дерева встраивания является объект \code{DEFLIST} класса \code{Abstraction} --- это и есть шаблон, он содержит список \emph{параметров}, состоящий из двух объектов класса \code{Variable}, и \emph{тело} --- объект \code{struct}. Значение свойства \code{@name} объекта \code{struct} изменилось по сравнению с \figref{int-list-struct}: если раньше это была строка $\String{IntList}$, то теперь это объект класса \code{VariableUsage}, который ссылается на объект \code{name} класса \code{Variable}. Это соответствует использованию параметра теле шаблона. Аналогично изменилось из значение свойства \code{@type} объекта \code{data}: теперь это тоже объект класса \code{VariableUsage}, ссылающийся на параметр \code{type}.

Процедура разворачивания просто заменяет объекты \code{VariableUsage} в теле шаблона значениями соответствующих аргументов и получается модель, не содержащая ``шаблонных''объектов (зеленого цвета). Чтобы придать параметрам значения, требуется \code{применить} шаблон к соответствующим аргументам. 
%
\figdef{deflist-application-intlinst}{Применение шаблона}
%
На \figref{deflist-application-intlinst} приведена диаграмма, соответствующая применению шаблона \code{DEFLIST}, определенного выше, к аргументам $\String{IntList}$ и $\Object{}{\Ref{\String{IntType}}}{}$. Объект класса \code{Application} (\emph{применение}) содержит ссылку на применяемый шаблон и список аргументов. Соответствие между параметрами шаблона и аргументами устанавливается с помощью индексов в списках: нулевой аргумент соответствует нулевому параметру, первый --- первому и т.д. На рисунке параметры шаблона соединены с соответствующими аргументами пунктирными линиями. 

Заметим, что результатом разворачивания применения шаблона на \figref{deflist-application-intlinst} будет в точности модель на \figref{int-list-struct}, аналогично тому как разворачивание применения макроопределения
\begin{lstlisting}[language=C]
DEFLIST(IntList, int)
\end{lstlisting}
дает описание структуры \code{IntList}.

Заметим также, что аргументами шаблона в принципе могут быть и ``шаблонные'' объекты. 
%
\figdef{deflist-application-list-of-lists}{Использование применения шаблона в аргументах}
%
Так на \figref{deflist-application-list-of-lists} показано применения шаблона \code{DEFLIST} к списку аргументов, один из которых, в свою очередь, тоже является применением шаблона \code{DEFLIST}. В результате разворачивания шаблонов в этом примере получится описание структуры $\String{ListList}$ элементов списка, состоящего из списков целых чисел.

Чтобы облегчить понимание, мы позволили себе некоторую вольность, приводя модельные термы с шаблонами на диаграммах данном разделе. Рассмотрим, например, \figref{deflist-template}: объекты \code{struct} и \code{data}, изображенные на этом рисунке, не удовлетворяют требованиям метамодели, приведенной на \figref{c-struct-mm}, поскольку эта метамодель определяет свойство \code{name} класса \code{Struct} как строковое, а на нашей диаграмме оно хранит объект класса \code{VariableUsage}; аналогично для свойства \code{type} объекта \code{data}. 

Такое положение вещей неудивительно: язык, порожденный метамоделью на \figref{c-struct-mm}, не поддерживает шаблоны, а для того, чтобы добавить в язык поддержку нового механизма, нужно как минимум пополнить его новыми конструкциями. В последующих разделах мы опишем метод, позволяющую пополнять языки автоматически. Процесс разработки языка с поддержкой шаблонов на основе уже существующего языка схематически представлен на \figref{macro-workflows}.
%
\figdef{macro-workflows}{Разработка и использование языков с поддержкой шаблонов}
%
Метамодель и интерпретирующая семантика языка \emph{Language} разрабатывается архитектором, после чего к метамодели применяется автоматизированная процедура трансформации, которую мы опишем ниже, в результате чего получается новая метамодель, поддерживающая шаблоны. Пользователь создает программу, удовлетворяющую требованиям пополненной метамодели, в своей программе он может использовать шаблоны. К этой программе применяется процедура разворачивания шаблонов, включающая в себя проверку типов аргументов (эту процедуру мы также опишем ниже). В результате получается программа, удовлетворяющая исходной метамодели языка \emph{Language}, к которой применима интерпретирующая семантика, разработанная архитектором. Таким образом, интерпретирующая семантика пополненного языка \emph{T-Language} получается автоматически как композиция процедуры разворачивания и интерпретирующей семантики исходного языка.

\section{Базовый язык шаблонов}

Примеры, приведенные в предыдущем разделе, дают общее представление о том, как можно пополнить существующий язык (в данном случае --- подмножество языка \tool{C}, позволяющее описывать структуры) механизмом шаблонов. В данном разделе мы приступаем к формальному описанию этого метода.

Структура ``шаблонных'' объектов в примерах из предыдущего раздела соответствует упрощенной метамодели, приведенной на \figref{template-metamodel}.
%
\figdef{template-metamodel}{Упрощенная метамодель базового языка шаблонов}
%
Определению шаблона соответствует класс \code{Abstraction}, объекты которого содержат \emph{тело} (\code{body}) и список \emph{параметров} (\code{parameters}). Телом шаблона может являться объект класса \code{Term}, мы будем называть такие объекты \emph{шаблонными термами}. На \figref{template-metamodel} изображено два конкретных подкласса абстрактного класса \code{Term}: \code{Application} (применение шаблона) и \code{VariableUsage} (использование переменной), структуру которых мы обсуждали в предыдущем разделе. 

Заметим, что \figref{deflist-template} не удовлетворяет требованиям данной метамодели: в качестве тела шаблона указан объект класса \code{Struct}, не являющегося подклассом класса \code{Term}. Эта проблема сродни той, которую мы обсуждали в конце предыдущего раздела: базовый язык шаблонов, порождаемый метамоделью, изображенной на \figref{template-metamodel}, не поддерживает конструкций, специфичных для описания структур. Поэтому при построении шаблонного языка необходимо не просто добавить классы для шаблонов в исходную метамодель, но и изменить структуру метамодели так, чтобы конструкции исходного языка стали шаблонными термами. 

На \figref{template-metamodel} изображен подкласс класса \code{Term}, вместо идентификатора имеющий многоточие. Он символизирует шаблонные конструкции, полученные из структур исходного языка. На \figref{c-struct-template-mm} изображены классы метамодели, полученной в результате пополнения языка описания структур шаблонными конструкциями.
%
\figdef{c-struct-template-mm}{Метамодель пополненного языка описания структур}
%
Из рисунка видно, что каждый класс исходной метамодели (\figref{c-struct-mm}) теперь является подклассом класса \code{Term}, и все свойства в также имеют значения типа $\RefT{\String{Term}}$ или $\ClassT{\String{Term}}$. Это позволяет в качестве значения любого свойства, включая свойства классов на \figref{template-metamodel}, использовать как конструкции исходного языка (теперь являющиеся шаблонными термами), так и ``чисто-шаблонные'' термы, то есть применения шаблонов и ссылки на параметры.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ignore{
\section{Базовый язык макроопределений}
Все языки шаблонов имеют довольно большую общую часть, называемую \term{базовым языком шаблонов}. Мы детально опишем эту часть в данном разделе. Детали, специфичные для конкретных языков шаблонов, будут описаны в следующих разделах.

\figdef{macro-workflows}{Создание и использование языка с поддержкой макроопределений}

Целевая мета-модель базового языка шаблонов (\figref{TempMM}) описывает основные понятия, на которых этот язык строится. Поскольку эта же мета-модель будет использована для описания аспектов, мы не используем в ней слова ``шаблон'' (template), ``параметр'' (parameter) и т.д., но приводим следующее ``отображение'' терминологии мета-модели на терминологию языка шаблонов:
\begin{itemize}
\item Шаблон представляется классом \code{Abstraction} и характеризуется именем, параметрами и телом.
\item Параметру соответствует класс \code{Variable}.
\item Шаблонные выражения представляются абстрактным классом \code{Term}, имеющим в базовом языке только два конкретных подкласса:
	\begin{itemize}
	\item использование шаблонного параметра (\code{VariableRef});
	\item применение шаблона (\code{Application}), описываемое ссылкой на шаблон и аргументами, подставляемыми вместо формальных параметров.
	\end{itemize}
\end{itemize}
Данная мета-модель также использует типы, указывать которые не обязательно. Тип характеризуется уникальным именем и кратностью, соответствующей одиночному вхождению или одной из операций ``\code{?}'', ``\code{*}'' или ``\code{+}''.

\begin{figure}[htbp]
	\centering
\begin{tabular}{p{.45\textwidth}p{.45\textwidth}}
\begin{lstlisting}[xleftmargin=0cm]
class Type {
  attr typeName : String;
  attr multiplicity 
  			: Multiplicity;
}

enum Multiplicity {
  VAL, MANY_VAL, REF
}

class Abstraction {
  attr name : String;
  val parameters : Variable*;
  val body : Term;
  val type : Type?;
}

\end{lstlisting}
&
\begin{lstlisting}[xleftmargin=0cm]
abstract class Term {}

class VariableRef extends Term {
  ref variable : Variable;
}

class Application extends Term {
  ref abstraction : Abstraction;
  val arguments : Term*;
}

class Variable {
  attr name : String;
  val type : Type?;
}
\end{lstlisting}
\end{tabular}
	\caption{Базовая мета-модель языка шаблонов}\label{TempMM}
\end{figure}

Контекстно-свободная грамматика базового языка шаблонов приведена в \lstref{TempG} (в нотации \GRM{}). Эта грамматика сама является шаблоном, поскольку базовый язык необходимо расширять для того, чтобы построить язык шаблонов на основе некоторого конкретного языка. В данном описании имеется два параметра, позволяющих добавлять новые виды выражений (\code{domainSpecificTerms}) и новые типы (\code{domainSpecificTypes}). Поскольку \GRM{} использует данный базовый язык шаблонов, мы не приводим здесь примеры использования его синтаксиса.

\begin{lstlisting}[label=TempG,float=htbp,caption=Базовый синтаксис языка шаблонов]
template Templates<domainSpecificTypes : Expression*, 
		domainSpecificTerms : Expression*> : Grammar {
	abstraction 
		: 'template' NAME <List variable, ','> type? 
			'{' term '}';
	variable : NAME type?;
	type : ':' typeName ('?' | '*' | '+')?;
	typeName
		: basicType
		: <?domainSpecificTypes> ;
	basicType : 'Integer' | 'String' | 'Boolean' | 'Character' ;
	term
		: genericTerm
		: <?domainSpecificTerms> ;
	genericTerm
		: templateVariableRef
		: '<' NAME term* '>' ;
}
\end{lstlisting}

Семантика языка шаблонов задается операцией \term{разворачивания}, описанной в композиционном стиле правилами на \figref{TempSem}. Мы обозначаем результат разворачивания шаблонов в выражении $e$ как $\Inst{\gamma}{e}$, где $\gamma$ (``\term{среда}'') является множеством значений параметров шаблонов вида $p = e$, где $p$ --- параметр, а $e$ --- шаблонное выражение. Как видно из правила \rref{app-inst}, когда разворачивается применение шаблона, среда пополняется информацией о текущих значениях параметров, при этом вызов происходит по значению, то есть аргументы разворачиваются до обработки тела вызываемого шаблона. 

\begin{figure}[htbp]
	\centering
$$
\trule{
	\{p = e\} \subseteq \gamma
}{
	\Inst{\gamma}{\ang{?p}} = e
}{var-inst}
$$ 
$$
\trule{
	\mathbf{template}\left(
		T \, \ang{p_1, \ldots, p_n} \, \{ b \}
	\right)
}{
	\gamma' = \bigcup\limits_{i=1}^{n} \{ p_i = \Inst{\gamma}{a_i} \}
	\qquad
	\Inst{\gamma}{\ang{T \, a_1, \ldots, a_n}} = \Inst{\gamma \cup \gamma'}{b}
}{app-inst}
$$
	\caption{Базовая семантика языка шаблонов}\label{TempSem}
\end{figure}


% встраивание/ссылки???, от этого зависит наличие val/ref в типах ниже

Для того, чтобы гарантировать, что результат применения шаблона будет корректным с точки зрения целевой мета-модели, мы определяем систему типов для языка шаблонов. Базовые правила этой системы типов приведены на \figref{TempTypes}, они должны быть дополнены специфичными правилами для поддержки конкретного языка. Отношение $\subtype$ является специфичным для расширяемого языка и не определяется в базовой системе типов, а лишь используется.

\begin{figure}[htbp]
	\centering
$$
\trule{}{\Gamma \cup \{v : \tau\} \vdash \ang{?v} : \tau}{var}
$$ 
$$
\trule{
	\Gamma \cup \bigcup\limits_{i=1}^{n} \{ p_i : \tau_i \} \vdash b : \sigma
}{
	\Gamma \vdash \mathbf{template}\left(
		T \ang{p_1 : \tau_1, \ldots, p_n : \tau_n} \,: \sigma \, \{ b \}
	\right)
}{abstr}
$$
$$
\trule{
	\Gamma \vdash \mathbf{template}\left(
		T \ang{p_1 : \tau_1, \ldots, p_n : \tau_n} \,: \sigma \, \{ b \}
	\right)
	&
	\forall i : [1:n].\; \Gamma \vdash a_i : \tau_i \
}{
	\Gamma \vdash \ang{T \, a_1, \ldots, a_n} : \sigma
}{appl}
$$
$$
\myinfer[null]{
	\Gamma \vdash NULL : \tau^?
}{}
\quad
\myinfer[relax]{
	\Gamma \vdash x : \tau^?
}{
	\Gamma \vdash x : \tau
}
\quad
\myinfer[relax$^+$]{
	\Gamma \vdash x : \tau^*
}{
	\Gamma \vdash x : \tau^+
}
$$
$$
\myinfer[subtype]{
	\Gamma \vdash x : \sigma
}{
	\Gamma \vdash x : \tau &
	\tau \subtype \sigma
}
$$
$$
\myinfer[elist]{\Gamma \vdash [] : \tau*}{}
\quad
\myinfer[list]{
	\Gamma \vdash [t_1,\ldots,t_n] : \tau^+
}{
	\forall i \in [1:n].\; \Gamma \vdash Item(t_i, \tau)
}
$$
$$
\myinfer[eset]{\Gamma \vdash \{\} : \tau*}{}
\quad
\myinfer[set]{
	\Gamma \vdash \{t_1,\ldots,t_n\} : \tau^+
}{
	\forall i \in [1:n].\; \Gamma \vdash Item(t_i, \tau)
}
$$
$$
\myinfer[item]{
	\Gamma \vdash Item(t, \tau)
}{
	\Gamma \vdash t : \tau
}
\quad
\myinfer[item*]{
	\Gamma \vdash Item(\ang{?v}, \tau)
}{
	\Gamma \vdash v : \tau^*
}
\quad
\myinfer[item$^+$]{
	\Gamma \vdash Item(\ang{?v}, \tau)
}{
	\Gamma \vdash v : \tau^+
}
$$
	\caption{Базовая система типов языка шаблонов}\label{TempTypes}
\end{figure}

В правилах \rref{list} и \rref{set} использовано отношение $Item(x,\tau)$, означающее, что $x$ может быть элементом коллекции $\tau$. Определение этого отношения дано на том же рисунке и сводится к тому, что внутри коллекции типа $\tau$ можно использовать не только одиночные значения этого типа, но и переменные, сами являющиеся коллекциями, что соответствует возможности вставки сразу нескольких элементов.

% mistake: we can add all <?v:\tau*> and get a collection of type \tau+

Дополнительно к правилам типизации, на язык шаблонов накладывается следующее требование: 
%\begin{enumerate}[(a)]
%\item 
\emph{Никакой шаблон не должен быть достижим из своего тела по ссылкам}. Это требование гарантирует отсутствие рекурсии в определениях шаблонов.
%\item \emph{Если множество использований некоторого параметра непусто, в нем должно содержаться хотя бы одно использование, на которое указывает агрегирующая ссылка.} Это требование гарантирует, что в результате разворачивания не возникнет объектов, не агрегируемых результирующей моделью.
%\end{enumerate}

\section{Генерация языка шаблонов}

\newcommand{\TM}{\mathcal{TM}}
\newcommand{\TC}[1]{\mathcal{TC}\left(#1\right)}
\newcommand{\TR}[1]{\mathcal{TR}\left(#1\right)}
\newcommand{\TA}[1]{\mathcal{TA}\left(#1\right)}
%\renewcommand{\vec}[1]{\overrightarrow{\mbox{#1}}}

Для того, чтобы построить язык шаблонов на основе заданного языка $L$, необходимо расширить базовую мета-модель, алгоритм разворачивания и систему типов конструкциями и правилами, специфичными для этого языка. 

Пусть целевая мета-модель языка $L$ обозначается $\MM{M}$, тогда мета-модель соответствующего языка шаблонов, $\TM$, состоит из классов, полученных применением преобразования $\TC{\bullet}$, описанного на \figref{TC}, к каждому классу мета-модели $\MM{M}$. Эта мета-модель использует как классы базовой мета-модели шаблонов (\code{Term}), так и примитивные типы и перечисления мета-модели $\MM{M}$.

\begin{figure}[htbp]
	\centering
$\TC{\class{}{S}{R}{A}} = \class{}
			{\mathtt{Term}}{\TR{R}}{\TA{A}}$
			
$\TC{C^*} = \TC{C}^*$

$\TC{C^+} = \TC{C}^+$

$\TC{C^?} = \TC{C}^?$

$\TR{\reference{ref}{r}{T}} = \reference{ref}{r}{\mathtt{Term}}$

$\TR{\reference{var}{r}{T}} = \reference{val}{r}{\mathtt{Term}}$

$\TA{\attribute{a}{T}} = \attribute{a}{T}$
	\caption{Преобразование конструкций языка в шаблонные выражения}\label{TC}
\end{figure}

Преобразование $\TC{\bullet}$ сопоставляет каждому классу соответствующий тип шаблонного выражения. При этом ссылки перенаправляются на класс \code{Term}, поскольку вместо конкретного объекта может выступать шаблонное выражение.

Аналогичное преобразование конкретного синтаксиса требует пополнения грамматики из \lstref{TempG} конструкциями языка $L$. Кроме того, сами эти конструкции должны допускать использование шаблонных выражений. Таким образом сначала грамматика языка $L$ преобразуется следующим образом: к каждому нетерминалу $N$, соответствующему классу в целевой мета-модели, добавляется продукция $N \rightarrow \mathtt{term}$, где \code{term} --- это нетермниал для шаблонных выражений из грамматики, приведенной в \lstref{TempG}. Это преобразование можно выразить следующим аспектным правилом в языке \GRM{}:
\begin{lstlisting}
#{class} : <p : Production+>;
	instead p : (p (: term));
\end{lstlisting}
Теперь необходимо придать значения параметрам грамматики базового языка шаблонов. Параметр \code{domainSpecificTypes} замещается множеством литералов, содержащих имена классов и примитивных типов из целевой мета-модели $L$, объединенных с помощью операции альтернативы, например
\begin{lstlisting}[language=Grammatic]
	'Sequence' | 'Alternative' | 'Literal'
\end{lstlisting}
Параметр \code{domainSpecificTerms} замещается множеством всех нетерминалов преобразованной грамматики языка $L$.

Построенная таким образом грамматика может оказаться неоднозначной. К сожалению, задача обнаружения неоднозначности является алгоритмически неразрешимой \cite{???}, и автоматизированные средства могут применять лишь эвристические методы для ее решения. В настоящий момент обнаружение и устранение неоднозначностей возлагается на разработчика.

Для обеспечения функционирования специфичных конструкций процедура разворачивания шаблонов пополняется правилами следующего вида:
$$
\trule{
%	C = \class{}{\_}{R=\{r_i\}}{A=\{a_i\}} &
	t = \obj{\TC{C}}{id}{r_i = rv_i,\, a_j = av_j}
}{
	\Inst{\gamma}{t} = \obj{\TC{C}}{id'}{r_i = \Inst{\gamma}{rv_i}, \,a_j = av_j }
}{ds-inst(С)}
$$ 
Задача таких правил --- развернуть шаблонные выражения, находящиеся внутри специфичных конструкций, поэтому все эти правила однотипны и просто осуществляют рекурсивные вызовы на значениях всех ссылок, выходящих из данного объекта. Поскольку в графе объектов могут быть циклы, в процессе разворачивания поддерживается служебное множество уже обработанных объектов, что соответствует стандартному алгоритму обхода графа в глубину \cite{Cormen}. %Заметим, что данное правило подразумевает, что $\Inst{\gamma}{e}$ всегда возвращает один и тот же объект на идентичных входных данных, что при реализации достигается за счет \term{мемоизации} (memoization, \cite{Memoize}).

\newcommand{\ct}[1]{\MM{M}\left(#1\right)}
Согласно приведенному выше правилу, результатом разворачивания шаблонного выражения является другое шаблонное выражение, полученное разворачиванием всех ссылок на параметры и применений шаблонов. Будем называть такие выражения имеющими \term{нормальную форму}. Для того, чтобы получить из выражения $e$ в нормальной форме экземпляр мета-модели $\MM{M}$, необходимо его преобразовать. Такое преобразование (обозначаемое $\ct{e}$) весьма просто: для каждого объекта класса $\TC{C}$ создается объект класса $C$ с той же структурой, то есть ссылки трансформируются рекурсивно, а атрибуты копируются. Ниже мы будем подразумевать выполнение данного преобразования после разворачивания шаблонов.

Система типов также пополняется правилами для специфичных конструкций. Эти правила имеют следующий вид:
$$
\myinfer[\mbox{ds-type(C)}]{
	\Gamma \vdash x : C
}{
	\begin{array}{l}
	x = \obj{\TC{C}}{id}{r_i = v_i; a_j = {v'}_j}\\
	\TM \Vdash x : \TC{C} 
	\end{array}	
	&
	\begin{array}{l}
	r_i = \TR{\rho_i : \tau_i}\\
	\Gamma \vdash v_i : \tau_i\\
	\end{array}	
}
$$ 
Однотипность этих правил также объясняется их рекурсивной природой: они нужны только для того, чтобы проверить типы в шаблонных выражениях внутри данного объекта, если он сам удовлетворяет требованиям мета-модели $\TM$.

Заметим, что шаблонное выражение, являющееся объектом класса $\TC{C}$ типизируется самим классом $C$. Это необходимо для соблюдения требований к наследованию. Поскольку в мета-модели $\TM$ все классы наследуются от класса \code{Term}, отношения наследования в ней не соответствуют таким же отношениям в $\MM{M}$. Поэтому в правиле \rref{subtype} на \figref{TempTypes} отношение $\subtype$ задается мета-моделью $\MM{M}$, а не $\TM$, и типы тоже берутся из $\MM{M}$. 

Чтобы показать, что ограничения, накладываемые системой типов адекватны требованиям мета-модели, докажем следующую лемму.
\begin{Lemm}[О нормальных формах]\label{LemmNF}
Если шаблонное выражение $e$ имеет нормальную форму и $\vdash e : \tau$, то $\fromMM \ct{e} : \tau$.
\end{Lemm}
\begin{proof}
Достаточно заметить, что в дереве вывода для $\vdash e : \tau$ правила \rref{var}, \rref{abstr}, \rref{appl}, \rref{item*} и \rref{item$^+$} не встречаются, а остальные правила в системе типов для шаблонов имеют прямые аналоги в системе требований мета-модели на \figref{TypesMM}.
\end{proof}

\section{Структурная корректность}

Система типов накладывает ограничения на шаблоны. Шаблоны и шаблонные выражения, удовлетворяющие правилам типизации, при разворачивании порождают конечные объекты, удовлетворяющие требованиям целевой мета-модели.
Для того, чтобы убедиться в этом, покажем, что для системы типов и семанитки языка шаблонов выполняются свойства \term{сохранения типов} и \term{нормализации}~\cite{Pierce}. 

Как отмечалось выше, необходимым условием корректного поведения является тот факт, что функция разворачивания получает на вход выражение, в котором соблюдаются правила системы типов. Это условие формализовано в следующем определении.

\begin{Def}\label{agree}
Среда $\gamma$ называется \term{согласованной с контекстом} $\Gamma$, если все ее элементы имеют допустимые типы:
$$
	\forall p \, : \, 
		\{p = e\} \subseteq \gamma 
			\Rightarrow 
		\left\{\begin{array}{l}		
		\{p : \tau\} \subseteq \Gamma \\
		\Gamma \vdash e : \tau
		\end{array}\right.
$$
\end{Def}

Теперь докажем первое из упомянутых выше свойств.

\begin{Th}[О сохранении типов]\label{ThTP}
Если среда $\gamma$ согласована с контекстом $\Gamma$ и \mbox{$\Gamma \vdash e : \tau$}, то \mbox{$\Gamma \vdash \Inst{\gamma}{e} : \tau$}. Другими словами, преобразование $\Inst{}{\bullet}$ сохраняет типы.
\end{Th}
\begin{proof}
Будем вести индукцию по определению $\Inst{\gamma}{e}$.

\noindent\textbf{База.} Правило \rref{ds-inst(C)} сохраняет типы, поскольку из объекта класса $\TC{C}$ получается объект того же класса, а правило \rref{ds-type(C)} выводит тип из класса объекта.

\noindent\textbf{Переход.} 
В правиле \rref{app-inst} среда расширяется, и нам необходимо показать, что результат согласован с контекстом. Это обеспечивается требованиями к типам параметров, накладываемыми правилом \rref{appl} и способом формирования контекста в правиле \rref{abstr}. Из этого по предположению индукции следует, что правило \rref{app-inst} сохраняет типы.

Так же по предположению правило \rref{var-inst} сохраняет типы.
\end{proof}

\newcommand{\h}[1]{h\left(#1\right)}
Свойство нормализации формулируется следующим образом:

\begin{Th}[О нормализации]\label{ThNorm}
Если среда $\gamma = \cup \{p_i = e_i\}$ согласована с контекстом $\Gamma$, все $e_i$ имеют нормальную форму и $\Gamma \vdash e : \tau$, то результат вычисления $\Inst{\gamma}{e}$ имеет нормальную форму.
\end{Th}
\begin{proof} 
Будем вести индукцию по определению $\Inst{\gamma}[\bullet]$.\\
\textbf{База.} Результат применения правила \rref{var-inst} имеет нормальную форму, поскольку все элементы среды имеют нормальную форму.
\textbf{Переход.} В правиле \rref{app-inst} среда пополняется значениями, имеющими нормальную форму, поэтому по предположению индукции вызовы $\Inst{\gamma}{a_i}$ и $\Inst{\gamma \cup \gamma'}{b}$ заканчиваются за конечное число шагов и результат имеет нормальную форму.

Правило \rref{ds-inst(C)} заменяет значения ссылок результатами разворачивания, имеющими нормальную форму, следовательно и результат применения правила имеет нормальную форму.
\end{proof}

Требование о том, чтобы все элементы среды имели нормальную форму выполняется для пустой среды, следовательно теорема применима для разворачивания шаблонных выражений, применяемых на практике.

Мы показали, что функция $\Inst{}{\bullet}$ корректно разворачивает все шаблонные параметры и применения шаблонов, а также что она не нарушает структурной корректности с точки зрения мета-модели. Результатом применения этой функции всегда является константное шаблонное выражение, которое, как отмечалось выше, тривиальным образом преобразуется в экземпляр мета-модели $\MM{M}$. Таким образом, описанный здесь механизм шаблонов работает корректно.

\section{Вывод типов}

Как отмечалось выше, в большинстве случаев типы в объявлениях шаблонов можно опускать, поскольку они могут быть реконструированы автоматически. Для этого применяется алгоритм, аналогичный использованному в \ATF{} (см. Главу \ref{part3} и \cite{Pierce}). Тип переменной выводится исходя из двух соображений: (а) какие аргументы ей присваиваются в применениях шаблона и (б) в каком контексте она используется в теле шаблона, то есть, если на использование переменной указывает ссылка $\TR{R}$, то учитывается тип ссылки $R$. Если система ограничений, построенная таким образом, не имеет решения, генерируется сообщение об ошибке типизации. Такой подход позволяет для переменной найти наиболее широкий тип объектов, которые могут быть подставлены на ее место.

Возникающие в процессе реконструкции неоднозначности разрешаются следующим образом: если параметр используется непосредственно внутри коллекции типа $T$, он получает тип $T^*$ и позволяет добавить в эту коллекцию ноль или более элементов. Исключение составляет случай, когда параметр является единственным элементом коллекции, в которой мета-модель требует наличия хотя бы одного элемента: в этом случае параметр получает тип $T^+$. 

}
