\chapter{Автоматическое построение языков, поддерживающих шаблоны}

В настоящем разделе описан метод, позволяющий по структурному описанию языка построить описание более богатого языка, поддерживающего композицию с помощью шаблонов. Мы будем называть такой пополненный язык \term{языком шаблонов}, построенным на базе исходного языка.

\section{Базовый язык шаблонов}
Все языки шаблонов имеют довольно большую общую часть, называемую \term{базовым языком шаблонов}. Мы детально опишем эту часть в данном разделе. Детали, специфичные для конкретных языков шаблонов, будут описаны в следующих разделах.

Целевая мета-модель базового языка шаблонов (\figref{TempMM}) описывает основные понятия, на которых этот язык строится. Поскольку эта же мета-модель будет использована для описания аспектов, мы не используем в ней слова ``шаблон'' (template), ``параметр'' (parameter) и т.д., но приводим следующее ``отображение'' терминологии мета-модели на терминологию языка шаблонов:
\begin{itemize}
\item Шаблон представляется классом \code{Abstraction} и характеризуется именем, параметрами и телом.
\item Параметру соответствует класс \code{Variable}.
\item Шаблонные выражения представляются абстрактным классом \code{Term}, имеющим в базовом языке только два конкретных подкласса:
	\begin{itemize}
	\item использование шаблонного параметра (\code{VariableRef});
	\item применение шаблона (\code{Application}), описываемое ссылкой на шаблон и аргументами, подставляемыми вместо формальных параметров.
	\end{itemize}
\end{itemize}
Данная мета-модель также использует типы, указывать которые не обязательно. Тип характеризуется уникальным именем и кратностью, соответствующей одиночному вхождению или одной из операций ``\code{?}'', ``\code{*}'' или ``\code{+}''.

\begin{lstlisting}[label=TempMM,float=htbp,caption=Базовая мета-модель языка шаблонов]
class Type {
	attr typeName : String;
	attr multiplicity : Multiplicity;
}

enum Multiplicity {
	VAL, MANY_VAL, REF
}

class Abstraction {
	attr name : String;
	val parameters : Variable*;
	val body : Term;
	val type : Type?;
}

class Variable {
	attr name : String;
	val type : Type?;
}

abstract class Term {}

class VariableRef extends Term {
	ref variable : Variable;
}

class Application extends Term {
	ref abstraction : Abstraction;
	val arguments : Term*;
}
\end{lstlisting}

Контекстно-свободная грамматика базового языка шаблонов приведена в \lstref{TempG} (в нотации \GRM{}). Эта грамматика сама является шаблоном, поскольку базовый язык необходимо расширять для того, чтобы построить язык шаблонов на основе некоторого конкретного языка. В данном описании имеется два параметра, позволяющих добавлять новые виды выражений (\code{domainSpecificTerms}) и новые типы (\code{domainSpecificTypes}). Поскольку \GRM{} использует данный базовый язык шаблонов, мы не приводим здесь примеры использования его синтаксиса.

\begin{lstlisting}[label=TempG,float=htbp,caption=Базовый синтаксис языка шаблонов]
template Temapltes<domainSpecificTypes : Expression*, 
		domainSpecificTerms : Expression*> : Grammar {
	abstraction 
		: 'template' NAME 
			'<' variable (',' variable)*'>' 
			type? 
			'{' term '}';
	variable : NAME type?;
	type : ':' typeName ('?' | '*' | '+')?;
	typeName
		: basicType
		: <?domainSpecificTypes>
		;
	basicType
		: 'Integer'
		: 'String'
		: 'Boolean'
		: 'Character'
		;
	term
		: genericTerm
		: <?domainSpecificTerms>
		;
	genericTerm
		: '<' '?' NAME type? '>'
		: '<' NAME term* '>'
		;
}
\end{lstlisting}

\newcommand{\rref}[1]{\mbox{\textit{#1}}}

Семантика языка шаблонов задается операцией \term{разворачивания}, описанной в композиционном стиле правилами на \figref{TempSem}. Мы обозначаем результат разворачивания шаблонов в выражении $e$ как $\Inst{\gamma}{e}$, где $\gamma$ (``\term{среда}'') является множеством значений параметров шаблонов вида $p = e$, где $p$ --- параметр, а $e$ --- шаблонное выражение. Как видно из правила \rref{app-inst}, когда разворачивается применение шаблона, среда пополняется информацией о текущих значениях параметров, при этом вызов происходит по значению, то есть аргументы разворачиваются до обработки тела вызываемого шаблона. 

\begin{figure}[htbp]
	\centering
$$
\trule{
	\{p = e\} \subseteq \gamma
}{
	\Inst{\gamma}{\ang{?p}} = e
}{var-inst}
$$ 
$$
\trule{
	\mathbf{template}\left(
		T \, \ang{p_1, \ldots, p_n} \, \{ b \}
	\right)
}{
	\gamma' = \bigcup\limits_{i=1}^{n} \{ p_i = \Inst{\gamma}{a_i} \}
	\qquad
	\Inst{\gamma}{\ang{T \, a_1, \ldots, a_n}} = \Inst{\gamma \cup \gamma'}{b}
}{app-inst}
$$
	\caption{Базовая семантика языка шаблонов}\label{TempSem}
\end{figure}


% встраивание/ссылки???, от этого зависит наличие val/ref в типах ниже

Для того, чтобы гарантировать, что результат применения шаблона будет корректным с точки зрения целевой мета-модели, мы определяем систему типов для языка шаблонов. Базовые правила этой системы типов приведены на \figref{TempTypes}, они должны быть дополнены специфичными правилами для поддержки конкретного языка. Отношение $\subtype$ является специфичным для расширяемого языка и не определяется в базовой системе типов, а лишь используется.

\begin{figure}[htbp]
	\centering
$$
\trule{}{\Gamma \cup \{v : \tau\} \vdash \ang{?v} : \tau}{var}
$$ 
$$
\trule{
	\Gamma \cup \bigcup\limits_{i=1}^{n} \{ p_i : \tau_i \} \vdash b : \sigma
}{
	\Gamma \vdash \mathbf{template}\left(
		T \ang{p_1 : \tau_1, \ldots, p_n : \tau_n} \,: \sigma \, \{ b \}
	\right)
}{abstr}
$$ 
$$
\trule{
	\Gamma \vdash \mathbf{template}\left(
		T \ang{p_1 : \tau_1, \ldots, p_n : \tau_n} \,: \sigma \, \{ b \}
	\right)
	&
	\forall i : [1:n].\; \Gamma \vdash a_i : \tau_i \
}{
	\Gamma \vdash \ang{T \, a_1, \ldots, a_n} : \sigma
}{appl}
$$
$$
\infer[elist]{\Gamma \vdash [] : \tau*}{}
\quad
\infer[list]{
	\Gamma \vdash [t_1,\ldots,t_n] : \tau^+
}{
	\forall i \in [1:n].\; \Gamma \vdash Item(t_i, \tau)
}
$$
$$
\infer[eset]{\Gamma \vdash \{\} : \tau*}{}
\quad
\infer[set]{
	\Gamma \vdash \{t_1,\ldots,t_n\} : \tau^+
}{
	\forall i \in [1:n].\; \Gamma \vdash Item(t_i, \tau)
}
$$
$$
\infer[item]{
	\Gamma \vdash Item(t, \tau)
}{
	\Gamma \vdash t : \tau
}
\quad
\infer[item^*]{
	\Gamma \vdash Item(\ang{?v}, \tau)
}{
	\Gamma \vdash v : \tau^*
}
\quad
\infer[item^+]{
	\Gamma \vdash Item(\ang{?v}, \tau)
}{
	\Gamma \vdash v : \tau^+
}
$$
$$
\infer[null]{
	\Gamma \vdash NULL : \tau^?
}{}
\quad
\infer[relax]{
	\Gamma \vdash x : \tau^?
}{
	\Gamma \vdash x : \tau
}
\quad
\infer[relax^+]{
	\Gamma \vdash x : \tau^*
}{
	\Gamma \vdash x : \tau^+
}
$$
$$
\infer[subtype]{
	\Gamma \vdash x : \sigma
}{
	\Gamma \vdash x : \tau &
	\tau \subtype \sigma
}
$$
	\caption{Базовая система типов языка шаблонов}\label{TempTypes}
\end{figure}
Дополнительно к правилам типизации, на язык шаблонов накладывается следующее требование: 
%\begin{enumerate}[(a)]
%\item 
\emph{Никакой шаблон не должен быть достижим из своего тела по ссылкам}. Это требование гарантирует отсутствие рекурсии в определениях шаблонов.
%\item \emph{Если множество использований некоторого параметра непусто, в нем должно содержаться хотя бы одно использование, на которое указывает агрегирующая ссылка.} Это требование гарантирует, что в результате разворачивания не возникнет объектов, не агрегируемых результирующей моделью.
%\end{enumerate}

// Пояснения про систему типов

\section{Генерация языка шаблонов}

\newcommand{\TM}{\mathcal{TM}}
\newcommand{\TC}[1]{\mathcal{TC}\left(#1\right)}
\newcommand{\TR}[1]{\mathcal{TR}\left(#1\right)}
\newcommand{\TA}[1]{\mathcal{TA}\left(#1\right)}
%\renewcommand{\vec}[1]{\overrightarrow{\mbox{#1}}}

Для того, чтобы построить язык шаблонов на основе заданного языка $L$, необходимо расширить базовую мета-модель, алгоритм разворачивания и систему типов конструкциями и правилами, специфичными для этого языка. 

Пусть целевая мета-модель языка $L$ обозначается $\MM{M}$, тогда мета-модель соответствующего языка шаблонов, $\TM$, состоит из классов, полученных применением преобразования $\TC{\bullet}$, описанного на \figref{TC}, к каждому классу мета-модели $\MM{M}$. Эта мета-модель использует как классы базовой мета-модели шаблонов (\code{Term}), так и примитивные типы и перечисления мета-модели $\MM{M}$.

\begin{figure}[htbp]
	\centering
$\TC{\class{}{S}{R}{A}} = \class{}
			{\mathtt{Term}}{\TR{R}}{\TA{A}}$
			
$\TC{C^*} = \TC{C}^*$

$\TC{C^+} = \TC{C}^+$

$\TC{C^?} = \TC{C}^?$

$\TR{\reference{ref}{r}{T}} = \reference{ref}{r}{\mathtt{Term}}$

$\TR{\reference{var}{r}{T}} = \reference{val}{r}{\mathtt{Term}}$

$\TA{\attribute{a}{T}} = \attribute{a}{T}$
	\caption{Преобразование конструкций языка в шаблонные выражения}\label{TC}
\end{figure}

Преобразование $\TC{\bullet}$ сопоставляет каждому классу соответствующий тип шаблонного выражения. При этом ссылки перенаправляются на класс \code{Term}, поскольку вместо конкретного объекта может выступать шаблонное выражение.

Аналогичное преобразование конкретного синтаксиса требует пополнения грамматики из \lstref{TempG} конструкциями языка $L$. Кроме того, сами эти конструкции должны допускать использование шаблонных выражений. Таким образом сначала грамматика языка $L$ преобразуется следующим образом: к каждому нетерминалу $N$, соответствующему классу в целевой мета-модели, добавляется продукция $N \rightarrow \mathtt{term}$, где \code{term} --- это нетермниал для шаблонных выражений из грамматики, приведенной в \lstref{TempG}. Это преобразование можно выразить следующим аспектным правилом в языке \GRM{}:
\begin{lstlisting}
# : <p : Production+>;
	instead p : (p (: term));
\end{lstlisting}
Теперь необходимо придать значения параметрам грамматики базового языка шаблонов. Параметр \code{domainSpecificTypes} замещается множеством литералов, содержащих имена классов и примитивных типов из целевой мета-модели $L$, объединенных с помощью операции альтернативы, например
\begin{lstlisting}[language=Grammatic]
	'Sequence' | 'Alternative' | 'Literal'
\end{lstlisting}
Параметр \code{domainSpecificTerms} замещается множеством всех нетерминалов преобразованной грамматики языка $L$.

Построенная таким образом грамматика может оказаться неоднозначной. К сожалению, задача обнаружения неоднозначности является алгоритмически неразрешимой \cite{???}, и автоматизированные средства могут применять лишь эвристические методы для ее решения. В настоящий момент обнаружение и устранение неоднозначностей возлагается на разработчика.

Для обеспечения функционирования специфичных конструкций процедура разворачивания шаблонов пополняется правилами следующего вида:
$$
\trule{
%	C = \class{}{\_}{R=\{r_i\}}{A=\{a_i\}} &
	t = \obj{\TC{C}}{id}{r_i = rv_i,\, a_j = av_j}
}{
	\Inst{\gamma}{t} = \obj{\TC{C}}{id'}{r_i = \Inst{\gamma}{rv_i}, \,a_j = av_j }
}{ds-inst(С)}
$$ 
Задача таких правил --- развернуть шаблонные выражения, находящиеся внутри специфичных конструкций, поэтому все эти правила однотипны и просто осуществляют рекурсивные вызовы на значениях всех ссылок, выходящих из данного объекта. Поскольку в графе объектов могут быть циклы, в процессе разворачивания поддерживается служебное множество уже обработанных объектов, что соответствует стандартному алгоритму обхода графа в глубину \cite{Cormen}. %Заметим, что данное правило подразумевает, что $\Inst{\gamma}{e}$ всегда возвращает один и тот же объект на идентичных входных данных, что при реализации достигается за счет \term{мемоизации} (memoization, \cite{Memoize}).

Согласно приведенному выше правилу, результатом разворачивания шаблонного выражения является другое шаблонное выражение, полученное разворачиванием всех ссылок на параметры и применений шаблонов. Будем называть такие выражения имеющими \term{нормальную форму}. Для того, чтобы получить экземпляр мета-модели $\MM{M}$ необходимо преобразовать выражение в нормальной форме. Такое преобразование весьма просто: для каждого объекта класса $\TC{C}$ создается объект класса $C$ с той же структурой, то есть ссылки трансформируются рекурсивно, а атрибуты копируются. Ниже мы будем подразумевать выполнение данного преобразования после разворачивания шаблонов.

Система типов также пополняется правилами для специфичных конструкций. Эти правила имеют следующий вид:
$$
\infer[\mbox{ds-type(C)}]{
	\Gamma \vdash x : C
}{
	\begin{array}{l}
	x = \obj{\TC{C}}{id}{r_i = v_i; a_j = {v'}_j}\\
	\TM \Vdash x : \TC{C} 
	\end{array}	
	&
	\begin{array}{l}
	r_i = \TR{\rho_i : \tau_i}\\
	\Gamma \vdash v_i : \tau_i\\
	\end{array}	
}
$$ 
Однотипность этих правил также объясняется их рекурсивной природой: они нужны только для того, чтобы проверить типы в шаблонных выражениях внутри данного объекта, если он сам удовлетворяет требованиям мета-модели $\TM$.

Заметим, что шаблонное выражение, являющееся объектом класса $\TC{C}$ типизируется самим классом $C$. Это необходимо для соблюдения требований к наследованию. Поскольку в мета-модели $\TM$ все классы наследуются от класса \code{Term}, отношения наследования в ней не соответствуют таким же отношениям в $\MM{M}$. Поэтому в правиле \rref{subtype} на \figref{TempTypes} отношение $\subtype$ задается мета-моделью $\MM{M}$, а не $\TM$, и типы тоже берутся из $\MM{M}$. 

\section{Структурная корректность}

Система типов накладывает ограничения на шаблоны. Шаблоны и шаблонные выражения, удовлетворяющие правилам типизации, при разворачивании порождают конечные объекты, удовлетворяющие требованиям целевой мета-модели.
Для того, чтобы убедиться в этом, покажем, что для системы типов и семанитки языка шаблонов выполняются свойства \term{сохранения типов} и \term{нормализации} \cite{Pierce}. 

Как отмечалось выше, необходимым условием корректного поведения является тот факт, что функция разворачивания получает на вход выражение, в котором соблюдаются правила системы типов. Это условие формализовано в следующем определении.

\begin{Def}\label{agree}
Среда $\gamma$ называется \term{согласованной с контекстом} $\Gamma$, если все ее элементы имеют допустимые типы:
$$
	\forall p \, : \, 
		\{p = e\} \subseteq \gamma 
			\Rightarrow 
		\left\{\begin{array}{l}		
		\{p : \tau\} \subseteq \Gamma \\
		\Gamma \vdash e : \tau
		\end{array}\right.
$$
\end{Def}

Теперь докажем первое из упомянутых выше свойств.

\begin{Th}[О сохранении типов]
Если среда $\gamma$ согласована с контекстом $\Gamma$ и \mbox{$\Gamma \vdash e : \tau$}, то \mbox{$\Gamma \vdash \Inst{\gamma}{e} : \tau$}. Другими словами, преобразование $\Inst{}{\bullet}$ сохраняет типы.
\end{Th}
\begin{proof}
Будем вести индукцию по определению $\Inst{\gamma}{e}$.

\noindent\textbf{База.} Правило \rref{ds-inst(C)} сохраняет типы, поскольку из объекта класса $\TC{C}$ получается объект того же класса, а правило \rref{ds-type(C)} выводит тип из класса объекта.

\noindent\textbf{Переход.} 
В правиле \rref{app-inst} среда расширяется, и нам необходимо показать, что результат согласован с контекстом. Это обеспечивается требованиями к типам параметров, накладываемыми правилом \rref{appl} и способом формирования контекста в правиле \rref{abstr}. Из этого по предположению индукции следует, что правило \rref{app-inst} сохраняет типы.

Так же по предположению правило \rref{var-inst} сохраняет типы.
\end{proof}

\newcommand{\h}[1]{h\left(#1\right)}
Свойство нормализации формулируется следующим образом:

\begin{Th}[О нормализации]
Если среда $\gamma = \cup {p_i = e_i}$ согласована с контекстом $\Gamma$, все $e_i$ имеют нормальную форму и $\Gamma \vdash e : \tau$, то результат вычисления $\Inst{\gamma}{e}$ имеет нормальную форму.
\end{Th}
\begin{proof} 
Будем вести индукцию по определению $\Inst{\gamma}[\bullet]$.\\
\textbf{База.} Результат применения правила \rref{var-inst} имеет нормальную форму, поскольку все элементы среды имеют нормальную форму.
\textbf{Переход.} В правиле \rref{app-inst} среда пополняется значениями, имеющими нормальную форму, поэтому по предположению индукции вызовы $\Inst{\gamma}{a_i}$ и $\Inst{\gamma \cup \gamma'}{b}$ заканчиваются за конечное число шагов и результат имеет нормальную форму.

Правило \rref{ds-inst(C)} заменяет значения ссылок результатами разворачивания, имеющими нормальную форму, следовательно и результат применения правила имеет нормальную форму.
\end{proof}

Требование о том, чтобы все элементы среды имели нормальную форму выполняется для пустой среды, следовательно теорема применима для разворачивания шаблонных выражений, применяемых на практике.

Мы показали, что функция $\Inst{}{\bullet}$ корректно разворачивает все шаблонные параметры и применения шаблонов, а также что она не нарушает структурной корректности с точки зрения мета-модели. Результатом применения этой функции всегда является константное шаблонное выражение, которое, как отмечалось выше, тривиальным образом преобразуется в экземпляр мета-модели $\MM{M}$. Таким образом, описанный здесь механизм шаблонов работает корректно.

\section{Вывод типов}

Как отмечалось выше, типы в объявлениях шаблонов можно опускать, поскольку они могут быть реконструированы автоматически. Для этого применяется тот же стандартный алгоритм, что и в \ATF{} (см. Главу \ref{part3}). Отличия имеются только в обработке неоднозначностей.

В случае шаблонов неоднозначности разрешаются следующим образом: если параметр используется непосредственно внутри коллекции типа $T$, он получает тип $T^*$ и позволяет добавить в эту коллекцию ноль или более элементов. Исключение составляет случай, когда параметр является единственным элементом коллекции, в которой мета-модель требует наличия хотя бы одного элемента: в этом случае параметр получает тип $T^+$. Если один и тот же параметр, использованный в разных местах может иметь различные типы, ему присваивается общий подтип этих типов. Если такого типа не существует, генерируется сообщение об ошибке.