\chapter{Автоматическое построение языков, поддерживающих шаблоны}

В настоящем разделе описан метод, позволяющий по структурному описанию языка построить описание более богатого языка, поддерживающего композицию с помощью шаблонов. Мы будем называть такой пополненный язык \term{языком шаблонов}, построенным на базе исходного языка.

\section{Базовый язык шаблонов}
Все языки шаблонов имеют довольно большую общую часть, называемую \term{базовым языком шаблонов}. Мы детально опишем эту часть в данном разделе. Детали, специфичные для конкретных языков шаблонов, будут описаны в следующих разделах.

Целевая мета-модель базового языка шаблонов (\figref{TempMM}) описывает основные понятия, на которых этот язык строится. Поскольку эта же мета-модель будет использована для описания аспектов, мы не используем в ней слова ``шаблон'' (template), ``параметр'' (parameter) и т.д., но приводим следующее ``отображение'' терминологии мета-модели на терминологию языка шаблонов:
\begin{itemize}
\item Шаблон представляется классом \code{Abstraction} и характеризуется именем, параметрами и телом.
\item Параметру соответствует класс \code{Variable}.
\item Шаблонные выражения представляются абстрактным классом \code{Term}, имеющим в базовом языке только два конкретных подкласса:
	\begin{itemize}
	\item использование шаблонного параметра (\code{VariableRef});
	\item применение шаблона (\code{Application}), описываемое ссылкой на шаблон и аргументами, подставляемыми вместо формальных параметров.
	\end{itemize}
\end{itemize}
Данная мета-модель также использует типы, указывать которые не обязательно. Тип характеризуется уникальным именем и кратностью, соответствующей одиночному вхождению или одной из операций ``\code{?}'', ``\code{*}'' или ``\code{+}''.

\begin{lstlisting}[label=TempMM,float=htbp,caption=Базовая мета-модель языка шаблонов]
class Type {
	attr typeName : String;
	attr multiplicity : Multiplicity;
}

enum Multiplicity {
	VAL, MANY_VAL, REF
}

class Abstraction {
	attr name : String;
	val parameters : Variable*;
	val body : Term;
	val type : Type?;
}

class Variable {
	attr name : String;
	val type : Type?;
}

abstract class Term {}

class VariableRef extends Term {
	ref variable : Variable;
}

class Application extends Term {
	ref abstraction : Abstraction;
	val arguments : Term*;
}
\end{lstlisting}

Контекстно-свободная грамматика базового языка шаблонов приведена в \lstref{TempG} (в нотации \GRM{}). Эта грамматика сама является шаблоном, поскольку базовый язык необходимо расширять для того, чтобы построить язык шаблонов на основе некоторого конкретного языка. В данном описании имеется два параметра, позволяющих добавлять новые виды выражений (\code{domainSpecificTerms}) и новые типы (\code{domainSpecificTypes}). Поскольку \GRM{} использует данный базовый язык шаблонов, мы не приводим здесь примеры использования его синтаксиса.

\begin{lstlisting}[label=TempG,float=htbp,caption=Базовый синтаксис языка шаблонов]
template Temapltes<domainSpecificTypes : Expression*, 
		domainSpecificTerms : Expression*> : Grammar {
abstraction 
	: 'template' NAME 
		'<' variable (',' variable)*'>' 
		type? 
		'{' term '}';
variable : NAME type?;
type : ':' typeName ('?' | '*' | '+')?;
typeName
	: basicType
	: <?domainSpecificTypes>
	;
basicType
	: 'Integer'
	: 'String'
	: 'Boolean'
	: 'Character'
	;
term
	: genericTerm
	: <?domainSpecificTerms>
	;
genericTerm
	: '<' '?' NAME type? '>'
	: '<' NAME term* '>'
	;
}
\end{lstlisting}

\newcommand{\rref}[1]{\textit{#1}}

Семантика языка шаблонов задается операцией \term{разворачивания}, описанной в композиционном стиле правилами на \figref{TempSem}. Мы обозначаем результат разворачивания шаблонов в выражении $e$ как $\Inst{\gamma}{e}$, где $\gamma$ (``\term{среда}'') является множеством значений параметров шаблонов вида $p = e$, где $p$ --- параметр, а $e$ --- шаблонное выражение. Как видно из правила \rref{app-inst}, когда разворачивается применение шаблона, среда пополняется информацией о текущих значениях параметров, при этом сами значения не разворачиваются до тех пор, пока не будут использованы. Разворачивание значений использованных параметров выполняется в правиле \rref{var-inst}.

\begin{figure}[htbp]
	\centering
$$
\trule{
	\{p = e\} \subseteq \gamma
}{
	\Inst{\gamma}{\ang{?p}} = \Inst{\gamma}{e}
}{var-inst}
$$ 
$$
\trule{
	\mathbf{template}\left(
		T \, \ang{p_1, \ldots, p_n} \, \{ b \}
	\right)
}{
	\gamma' = \bigcup\limits_{i=1}^{n} \{ p_i = a_i \}
	\qquad
	\Inst{\gamma}{\ang{T \, a_1, \ldots, a_n}} = \Inst{\gamma \cup \gamma'}{b}
}{app-inst}
$$
	\caption{Базовая семантика языка шаблонов}\label{TempSem}
\end{figure}


% встраивание/ссылки???, от этого зависит наличие val/ref в типах ниже

Для того, чтобы гарантировать, что результат применения шаблона будет корректным с точки зрения целевой мета-модели, мы определяем систему типов для языка шаблонов. Базовые правила этой системы типов приведены на \figref{TempTypes}, они должны быть дополнены специфичными правилами для поддержки конкретного языка. Отношение $\subtype$ является специфичным для расширяемого языка и не определяется в базовой системе типов, а лишь используется.

\begin{figure}[htbp]
	\centering
$$
\trule{}{\Gamma \cup \{v : \tau\} \vdash \ang{?v} : \tau}{var}
$$ 
$$
\trule{
	\Gamma \cup \bigcup\limits_{i=1}^{n} \{ p_i : \tau_i \} \vdash b : \sigma
}{
	\Gamma \vdash \mathbf{template}\left(
		T \ang{p_1 : \tau_1, \ldots, p_n : \tau_n} \,: \sigma \, \{ b \}
	\right)
}{abstr}
$$ 
$$
\trule{
	\Gamma \vdash \mathbf{template}\left(
		T \ang{p_1 : \tau_1, \ldots, p_n : \tau_n} \,: \sigma \, \{ b \}
	\right)
	&
	\forall i : [1:n].\; \Gamma \vdash a_i : \tau_i \
}{
	\Gamma \vdash \ang{T \, a_1, \ldots, a_n} : \sigma
}{appl}
$$
$$
\infer[elist]{\Gamma \vdash [] : \tau*}{}
\quad
\infer[list]{
	\Gamma \vdash [t_1,\ldots,t_n] : \tau^+
}{
	\forall i \in [1:n].\; \Gamma \vdash Item(t_i, \tau)
}
$$
$$
\infer[eset]{\Gamma \vdash \{\} : \tau*}{}
\quad
\infer[set]{
	\Gamma \vdash \{t_1,\ldots,t_n\} : \tau^+
}{
	\forall i \in [1:n].\; \Gamma \vdash Item(t_i, \tau)
}
$$
$$
\infer[item]{
	\Gamma \vdash Item(t, \tau)
}{
	\Gamma \vdash t : \tau
}
\quad
\infer[itemv]{
	\Gamma \vdash Item(\ang{?v}, \tau)
}{
	\Gamma \vdash v : \tau^*
}
\quad
$$
$$
\infer[null]{
	\Gamma \vdash NULL : \tau^?
}{}
\quad
\infer[relax]{
	\Gamma \vdash x : \tau^?
}{
	\Gamma \vdash x : \tau
}
\quad
\infer[relax+]{
	\Gamma \vdash x : \tau^*
}{
	\Gamma \vdash x : \tau^+
}
$$
$$
\infer[subtype]{
	\Gamma \vdash x : \sigma
}{
	\Gamma \vdash x : \tau &
	\tau \subtype \sigma
}
$$
	\caption{Базовая система типов языка шаблонов}\label{TempTypes}
\end{figure}
Дополнительно к правилам типизации, на язык шаблонов накладывается следующее требование: \emph{никакой шаблон не должен быть достижим из своего тела по ссылкам}. Это требование гарантирует отсутствие рекурсии в определениях шаблонов.

// Пояснения про систему типов

\section{Генерация языка шаблонов}

\newcommand{\TM}{\mathcal{TM}}
\newcommand{\TC}[1]{\mathcal{TC}\left(#1\right)}
\newcommand{\TR}[1]{\mathcal{TR}\left(#1\right)}
\newcommand{\TA}[1]{\mathcal{TA}\left(#1\right)}
%\renewcommand{\vec}[1]{\overrightarrow{\mbox{#1}}}

Для того, чтобы построить язык шаблонов на основе заданного языка $L$, необходимо расширить базовую мета-модель, алгоритм разворачивания и систему типов конструкциями и правилами, специфичными для этого языка. 

Пусть целевая мета-модель языка $L$ обозначается $\MM{M}$, тогда мета-модель соответствующего языка шаблонов, $\TM$, состоит из классов, полученных применением преобразования $\TC{\bullet}$, описанного на \figref{TC}, к каждому классу мета-модели $\MM{M}$. Эта мета-модель использует как классы базовой мета-модели шаблонов (\code{Term}), так и примитивные типы и перечисления мета-модели $\MM{M}$.

\begin{figure}[htbp]
	\centering
$\TC{\class{}{S}{R}{A}} = \class{}
			{\mathtt{Term}}{\TR{R}}{\TA{A}}$
			
$\TC{C^*} = \TC{C}^*$

$\TC{C^+} = \TC{C}^+$

$\TC{C^?} = \TC{C}^?$

$\TR{\reference{ref}{r}{T}} = \reference{ref}{r}{\mathtt{Term}}$

$\TR{\reference{var}{r}{T}} = \reference{val}{r}{\mathtt{Term}}$

$\TA{\attribute{a}{T}} = \attribute{a}{T}$
	\caption{Преобразование конструкций языка в шаблонные выражения}\label{TC}
\end{figure}

Преобразование $\TC{\bullet}$ сопоставляет каждому классу соответствующий тип шаблонного выражения. При этом ссылки перенаправляются на класс \code{Term}, поскольку вместо конкретного объекта может выступать шаблонное выражение.

Аналогичное преобразование конкретного синтаксиса требует пополнения грамматики из \lstref{TempG} конструкциями языка $L$. Кроме того, сами эти конструкции должны допускать использование шаблонных выражений. Таким образом сначала грамматика языка $L$ преобразуется следующим образом: к каждому нетерминалу $N$, соответствующему классу в целевой мета-модели, добавляется продукция $N \rightarrow \mathtt{term}$, где \code{term} --- это нетермниал для шаблонных выражений из грамматики, приведенной в \lstref{TempG}. Это преобразование можно выразить следующим аспектным правилом в языке \GRM{}:
\begin{lstlisting}
# : <p : Production+>;
	instead p : (p (: term));
\end{lstlisting}
Теперь необходимо придать значения параметрам грамматики базового языка шаблонов. Параметр \code{domainSpecificTypes} замещается множеством литералов, содержащих имена классов и примитивных типов из целевой мета-модели $L$, объединенных с помощью операции альтернативы, например
\begin{lstlisting}[language=Grammatic]
	'Sequence' | 'Alternative' | 'Literal'
\end{lstlisting}
Параметр \code{domainSpecificTerms} замещается множеством всех нетерминалов преобразованной грамматики языка $L$.

Построенная таким образом грамматика может оказаться неоднозначной. К сожалению, задача обнаружения неоднозначности является алгоритмически неразрешимой \cite{???}, и автоматизированные средства могут применять лишь эвристические методы для ее решения. В настоящий момент обнаружение и устранение неоднозначностей возлагается на разработчика.

Для обеспечения функционирования специфичных конструкций процедура разворачивания шаблонов пополняется правилами следующего вида:
$$
\trule{
%	C = \class{}{\_}{R=\{r_i\}}{A=\{a_i\}} &
	t = \obj{\TC{C}}{id}{r_i = rv_i,\, a_j = av_j}
}{
	\Inst{\gamma}{t} = \obj{\TC{C}}{id^{new}}{r_i = \Inst{\gamma}{rv_i}, \,a_j = av_j }
}{ds-inst(С)}
$$ 
Задача таких правил --- развернуть шаблонные выражения, находящиеся внутри специфичных конструкций, поэтому все эти правила однотипны и просто осуществляют рекурсивные вызовы на значениях всех ссылок, выходящих из данного объекта.

Система типов также пополняется правилами для специфичных конструкций. Эти правила имеют следующий вид:
$$
\infer[dstype(C)]{
	\Gamma \vdash x : C
}{
	\begin{array}{l}
	x = \obj{\TC{C}}{id}{r_i = v_i; a_j = {v'}_j}\\
	\TM \Vdash x : \TC{C} 
	\end{array}	
	&
	\begin{array}{l}
	r_i = \TR{\rho_i : \tau_i}\\
	\Gamma \vdash v_i : \tau_i\\
	\end{array}	
}
$$ 
Однотипность этих правил также объясняется их рекурсивной природой: они нужны только для того, чтобы проверить типы в шаблонных выражениях внутри данного объекта, если он сам удовлетворяет требованиям мета-модели $\TM$.

Заметим, что шаблонное выражение, являющееся объектом класса $\TC{C}$ типизируется самим классом $C$. Это необходимо для соблюдения требований к наследованию. Поскольку в мета-модели $\TM$ все классы наследуются от класса \code{Term}, отношения наследования в ней не соответствуют таким же отношениям в $\MM{M}$. Поэтому в правиле \rref{subtype} на \figref{TempTypes} отношение $\subtype$ задается мета-моделью $\MM{M}$, а не $\TM$, и типы тоже берутся из $\MM{M}$. 

\section{Структурная корректность}

Система типов накладывает ограничения на шаблоны. Шаблоны и шаблонные выражения, удовлетворяющие правилам типизации, при разворачивании порождают конечные объекты, удовлетворяющие требованиям целевой мета-модели.
Для того, чтобы убедиться в этом, покажем, что для системы типов и семанитки языка шаблонов выполняются свойства \term{сохранения типов} и \term{нормализации} \cite{???}. 

Как отмечалось выше, необходимым условием корректного поведения является тот факт, что функция разворачивания получает на вход выражение, в котором соблюдаются правила системы типов. Это условие формализовано в следующем определении.

\begin{Def}\label{agree}
Среда $\gamma$ называется \term{согласованной с контекстом} $\Gamma$, если все ее элементы имеют допустимые типы:
$$
	\forall p \, : \, 
		\{p = e\} \subseteq \gamma 
			\Rightarrow 
		\left\{\begin{array}{l}		
		\{p : \tau\} \subseteq \Gamma \\
		\Gamma \vdash e : \tau
		\end{array}\right.
$$
\end{Def}

Теперь докажем первое из упомянутых выше свойств.

\begin{Th}[О сохранении типов]
Если среда $\gamma$ согласована с контекстом $\Gamma$ и $\Gamma \vdash e : \tau$, то $\Gamma \vdash \Inst{\gamma}{e} : \tau$. Другими словами, преобразование $\Inst{}{\bullet}$ сохраняет типы.
\end{Th}
\begin{proof}
Будем вести индукцию по структуре выражения $e$, пользуясь правилами на \figref{TempSem}.\\
\textbf{База}. Правила \textsc{STR} и \textsc{SEQ} сохраняют типы.\\
\textbf{Предположение}. Пусть для выражений $e, b, a_1, \ldots, a_n$ данная лемма выполняется.\\
\textbf{Переход}. Рассмотрим правило \textsc{PAR}. Поскольку $\{p = e\} \subseteq \gamma$, по условию леммы выполняется
$$
\left\{\begin{array}{l}		
		\{p : \tau\} \subseteq \Gamma \\
		\Gamma \vdash e : \tau
		\end{array}\right.
$$
(см. Определение \ref{agree}). Следовательно $\Gamma \vdash (\Inst{\gamma}{<p>} = \Inst{\gamma}{e}) : \tau$.\\
Теперь рассмотрим правило \textsc{APP}. Пусть $$\Gamma \vdash <T a_1, \ldots, a_n> : \sigma,$$ тогда по условию леммы $\Gamma \vdash b : \sigma$, то есть $$\Gamma \vdash (\Inst{\gamma}{<T a_1, \ldots, a_n>} = \Inst{\gamma}{b}) : \sigma.$$
\end{proof}

Второе свойство --- нормализация --- формулируется следующим образом.

\begin{Th}[О нормализации]
Если среда $\gamma$ согласована с контекстом $\Gamma$ и $\Gamma \vdash e : \tau$, то вычисление $\Inst{\gamma}{e}$ заканчивается за конечное количество шагов, и результат не содержит применений шаблонов и шаблонных параметров.
\end{Th}
\begin{proof}
Снова будем вести индукцию по структуре выражения, пользуясь правилами на \figref{TempSem}.\\
\textbf{База}. Вычисление по правилу \textsc{STR} заканчивается за один шаг и результат не содержит применений шаблонов и шаблонных параметров.\\
\textbf{Предположение}. Пусть данная лемма выполняется для выражений $e, b, e_1, e_2, a_1, \ldots, a_n$.\\
\textbf{Переход}. Рассмотрим правило \textsc{PAR}. По предположению вычисление заканчивается за конечное количество шагов (время для $e$ плюс один шаг). Поскольку результат рекурсивного вызова не содержит применений шаблонов и шаблонных параметров, а правило их не добавляет (наоборот, удаляет параметр), то и результат их не содержит.\\
Для правил \textsc{SEQ} и \textsc{APP} рассуждения аналогичны с той лишь разницей, что в случае \textsc{APP} нужно учитывать, что рекурсия в шаблонах не допускается.
\end{proof}

Мы показали, что функция $\Inst{}{\bullet}$ корректно разворачивает все шаблонные параметры и применения шаблонов, а также что она не нарушает структурной корректности с точки зрения мета-модели. Результатом применения этой функции (в пустой среде) всегда является константное шаблонное выражение, которое, фактически, является предложением в нотации, не имеющей шаблонов. Таким образом, описанный здесь язык шаблонов работает корректно.

\section{Вывод типов}

???

