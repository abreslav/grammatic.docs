\chapter{Понятие языка}

Несмотря на то, что концепции мета-моделирования и ПОЯ развивались независимо, они тесно связаны между собой, поскольку мета-модели логично рассматривать как языки описания моделей (а мета-мета-модель, соответственно, как язык описания мета-моделей). Таким образом, \tool{Ecore} (MOF, KM3 и т. д.) можно рассматривать как ПОЯ для описания ПОЯ. Эта точка зрения приобретает все большую популярность \cite{}.

Для более глубокого понимания взаимосвязей мета-моделирования и ПОЯ требуется определить само понятие ``язык''. В разных областях математики, логики и компьютерных наук это делается по-разному \cite{???}, например в математической логике термин ``язык'' часто используется как синоним термина ``множество''; нередко имеется в виду множество, описанное определенным образом \cite{}. Здесь и далее мы не будем говорить о языках ``вообще'', а ограничим наше рассмотрение \term{языками моделей}:

\newcommand{\Lang}[1]{\mathcal{L}\left(#1\right)}%
\newcommand{\LMM}[1]{\Lang{\MM{#1}}}%

\begin{Def}
Пусть задана мета-модель $\MM{M}$. Будем называть множество всех моделей, являющихся экземплярами $\MM{M}$, \term{языком, порожденным этой мета-моделью}, и обозначать $\Lang{\MM{M}}$.
\end{Def}

Это определение позволяет описывать как языка моделирования, такие как UML \cite{???}, которые изначально задаются с помощью мета-моделей, так и языки в более традиционном понимании. Например, в теории формальных языков \cite{???} принято определять язык как множество строк над конечным алфавитом; под наше определение подпадают те из языков, определенных таким образом, для которых есть конечное описание в виде (не обязательно контекстно-свободной) грамматики \cite{???}. Мета-модель, соответствующая грамматике состоит из классов, описывающих структуры термов соответствующей индуцированной алгебры \cite{???}.

\ignore{

Для того, чтобы рассуждать о большинстве языков, используемых на практике (например, о языках программирования), ниже мы определяем понятия, связанные с ``синтаксисом'' языков.

\section{Синтаксис}

Понятие ``синтаксис'', чаще всего ассоциируемое с правилами записи предложений языка, является сильно перегруженным и требует внимательного рассмотрения во избежание путаницы в терминах. В данном разделе мы постараемся разделить различные категории понятий, подразумеваемые в разных контекстах под словом ``синтаксис'', и ввести соответствующие определения.

\paragraph*{Конкретный синтаксис. } Способ визуального отображения языка мы будем называть \term{нотацией} (или \term{конкретным синтаксисом}) этого языка.

Для одного и того же множества языка $\LMM{M}$ можно задать несколько (бесконечно много) разных способов отображения. Среди всевозможных нотаций выделяют следующие практически важные классы:
\begin{enumerate}
\item текстовые нотации: предложения языка отображаются в виде строк символов некоторого конечного алфавита;
\item графические нотации: предложения языка отображаются в виде графических изображений, при этом роль играет цвет, форма и толщина линий, взаимное расположение объектов.
\end{enumerate}

Важной разновидностью текстового конкретного синтаксиса является ``расширяемый язык разметки'' (eXtensible Markup Language, XML \cite{XML}), являющийся на сегодняшний день промышленным стандартом для структурирования информации, хранимой в виде текста. Идейным предшественником XML можно считать нотацию S-выражений языка \tool{Lisp} \cite{LISP}.

Формально говоря, текстовый конкретный синтаксис можно считать разновидностью графического, но обычно такая классификация не представляет интереса, хотя в последние годы с появлением псевдо-текстового синтаксиса (системы MPS \cite{MPS}, Amadeus \cite{Amadeus}, SymADE \cite{SymADE}) граница между этими двумя понятиями постепенно стирается.

// Почему мы выбираем текстовый синтаксис? (Надо ли оно?)

Мы будем использовать следующее определение нотации:

\newcommand{\NNot}[3]{#1^{{#2} \rightarrow{} {#3}}}
\newcommand{\Not}[3]{\NNot{#1}{\MM{#2}}{\MM{#3}}}
\newcommand{\N}[2]{\Not{#1}{#1}{#2}}

\begin{Def}
\term{Нотацией} $\N{N}{M}$ для языка $\LMM{M}$ будем называть кортеж, состоящий из следующих объектов:
\begin{enumerate}
\item мета-модель $\MM{N}$;
\item однозначная вычислимая функция $$Meaning_N : \LMM{N} \rightarrow (\{\bot\} \cup \LMM{M}),$$ определенная везде на области задания.
\end{enumerate}

Там, где из контекста ясно, о каких мета-моделях идет речь, мы будем обозначать нотацию как $\Not{N}{}{}$.
\end{Def}

Согласно этому определению, нотация $\N{N}{M}$ задается некоторым множеством $\LMM{N}$ (в случае текстовых нотаций мета-модель $\MM{N}$ просто описывает произвольную последовательность символов, см. \figref{TextMM}), элементы которого преобразуются в элементы языка функцией $Meaning_N$ (в некотором смысле, эта функция выполняет роль, аналогичную роли компилятора языка программирования). Если функция $Meaning_N$ возвращает элемент $\bot$, это означает, что соответствующий элемент нотации некорректен (например, текст программы содержит синтаксическую ошибку).

\begin{figure}[htbp]
\caption{Мета-модель текста}\label{TextMM}
\end{figure}

Для одного и того же языка можно определить несколько нотаций, причем различные нотации не обязаны иметь различные мета-модели. Так, например, текстовых нотаций (заданных одной и той же мета-моделью \figref{TextMM}) для одного языка можно определить бесконечно много (например, добавляя обязательное ключевое слово в начало текста программы).

В широком смысле можно говорить о том, что нотация $\N{N}{M}$, точнее функция $Meaning_N$, определяет \term{денотационную семантику} \cite{???} языка $\LMM{N}$ в терминах языка $\LMM{M}$.

Всякий компилятор можно рассматривать как реализацию функции $Meaning_N$, где нотация $N$ является текстовой. Однако, как правило, компиляторы не работают ``в один шаг'', а выполняют серию преобразований из одной нотации в другую. Так, стандартной последовательностью является (1) преобразование текста в последовательность лексем, далее (2) построение абстрактного синтаксического дерева, которое (3) преобразуется во внутреннее представление, которое, после (4) оптимизации, (5) транслируется в машинный код \cite{Dragon}. Этот процесс можно рассматривать как одну трансформацию из текста в машинный код, а можно выделить в нем не менее пяти указанных этапов, имеющих, каждый, свои входной и выходной языки. Ниже мы часто будем прибегать к такому детализированному рассмотрению.
\newcommand{\Comp}[2]{#1 \circ #2}
\begin{Def}
Нотация $\N{N}{M}$ является \term{композицией} нотаций $\Not{A}{N}{B}$ и $\N{B}{M}$ и обозначается $\Comp{A}{B}$, если 
	$$Meaning_N(n) := \left\{\begin{array}{ll}
		Meaning_{A}(Meaning_{B}(n)), & \mbox{при } Meaning_{B}(n) \neq \bot\\
		\bot, & \mbox{в противном случае}
	\end{array}\right.$$
\end{Def}

Смысл условия в данном определении состоит в том, что если на некотором этапе была обнаружена ошибка ($\bot$), она не теряется, а распространяется на остальные этапы. Поскольку компиляторы следуют этой стратегии (не замалчивают ошибки), описанный выше процесс компиляции можно рассматривать как композицию пяти нотаций.

%На первый взгляд, согласно нашему определению, каждый новый способ отображения дает новый язык, однако такая интерпретация не неудобна с практической точки зрения: многие системы (Intentional \cite{Intentional}, MPS \cite{MPS}, GMF \cite{GMF} и др.) позволяют отображать одни и те же данные разными способами (этот подход называется \term{проективное редактирование}, Projection Editing \cite{Projection}), поэтому целесообразно говорить о том, что те или иные способы отображения относятся к одному и тому же языку (можно считать, что объединение нескольких видов конкретного синтаксиса само по себе является единым способом визуального отображения). 

\paragraph*{Абстрактный синтаксис. } Понятие ``абстрактного синтаксиса'' в литературе трактуется по-разному \cite{Dragon ...}, поскольку существует много различных ``уровней абстракции'' (по сути, различных нотаций, объединенных последовательной композицией).

Так, рассматривая языки с текстовым конкретным синтаксисом, под абстрактным синтаксисом чаще всего понимают алгебру термов, индуцированную грамматикой, описывающей конкретный синтаксис. В этом случае говорят об абстрактных синтаксических деревьях (Abstract Syntax Tree, AST), рассматривая их как деревья разбора, из которых удалены элементы, не представляющие интереса. Текст можно рассматривать как нотацию для языка таких термов, а соответствующую функцию $Meaning$ реализует синтаксический анализатор (обычно, в композиции с лексическим, но не всегда \cite{SGLR}).

Однако при рассмотрении языков с графическим или псевдо-текстовым конкретным синтаксисом  \cite{MPS, ...} под абстрактным синтаксисом понимают множество всех предложений языка, которое как правило явно задается некоторой мета-моделью (сами предложения являются моделями, то есть типизированными атрибутированными графами).

Следует отметить, что трансляторы текстовых языков обычно выполняют (явное или неявное) преобразование AST в граф, когда разрешают имена в программах (так имя переменной преобразуется в ссылку на объявление этой переменной). Таким образом, возникают понятия \term{первичного} абстрактного синтаксиса (First-Order Abstract Syntax, FOAS) и абстрактного синтаксиса \term{высшего порядка} (Higher-Order Abstract Syntax, HOAS). 

Чтобы избежать путаницы, мы будем придерживаться следующих обозначений:

\begin{Def}
Множество $\LMM{M}$ мы будем называть \term{содержанием} нотации $\N{N}{M}$. Мета-модель $\MM{M}$ будем называть \term{целевой мета-моделью} данной нотации.
\end{Def}

\begin{Def}
Понятие \term{абстрактного синтаксического дерева} (AST) имеет смысл только в связи с некоторой контекстно-свободной грамматикой. AST является термом соответствующей индуцированной алгебры, представленным в форме дерева объектов.
\end{Def}

\section{Графические и текстовые нотации}

Для ПОЯ чаще всего применяются...

\paragraph*{Использование графических нотаций при мета-моделировании}

Модели естественно отображать графически: деревья EMF, диаграммы UML

Очень наглядно, но большие диаграммы трудно читать и укладывать.
Для отображения нужны специальные довольно сложные инструменты.

\paragraph*{Преимущества текстового синтаксиса}

Работает даже в консоли. Независимость от инструментов, поддержка обобщенными инструментами (отображение, редактирование, сравнение, контроль версий). Это не работает для XMI из-за ссылок. появилась HUTN, но ей трудно пользоваться.

недостатки текста: надо парсить сложным алгоритмом, поддерживать параллельно структурное представление со ссылками и т.д.

\paragraph*{Псевдо-текстовый синтаксис}

MPS обладает всеми недостатками графического синтаксиса (редактировать и читать чуть проще, да)

\chapter{Ядро нотации и инфраструктурная функциональность}

Интуитивно понятно, что некоторая часть нотации может быть ``избыточной'' в том смысле, ее можно не использовать, сохраняя при этом возможность выразить все предложения языка, выразимые в исходной нотации. Примером таких избыточных элементов могут служить сокращенные формы записи для часто используемых конструкций языка\footnote{часто их называют ``синтаксическим сахаром'' (syntactic sugar \cite{???})}, такие как оператор \texttt{for} в языке \tool{C} \cite{???}, который легко можно выразить через другие операторы. В данном разделе мы вводим для описания таких элементов понятие \term{инфраструктуры} в рамках нотации, и показываем, что многие возможности в языках программирования, ориентированные на повторное использование, могут быть описаны как инфраструктурные.

\newcommand{\Infra}[1]{Infra\left(#1\right)}
\newcommand{\Core}[1]{Core\left(#1\right)}

\begin{Def}
\term{Множеством инфраструктурных элементов} нотации $\N{N}{M}$ называется максимальное по включению множество $\Infra{N}$ элементов мета-модели $\MM{N}$, исключение которого из рассмотрения не сужает образа функции $Meaning_N$:
	$$
		Meaning_N\left[
			\Lang{\MM{N} \setminus \Infra{N}}\right] = Meaning_N[\LMM{N}]
	$$
	
Множество элементов, не являющихся инфраструктурными, будем называть \term{ядром нотации} $N$ и обозначать $\Core{N}$.
\end{Def}

\begin{Def}
	Нотацию, для которой множество $\Infra{N}$ пусто, будем называть \term{минимальной}.
\end{Def}

\begin{Prop}
	Любую нотацию можно представить как композицию $\Comp{A}{B}$, где $B$ является минимальной нотацией.
\end{Prop}
\begin{proof}
Рассмотрим произвольную нотацию $\N{N}{M}$. Если она является минимальной, то она представима в виде
	$$\N{N}{M} = \Comp{\Not{1}{N}{N}}{\N{N}{M}},$$
где $\Not{1}{N}{N}$ --- \term{тождественная} нотация (имеет в качестве содержания самое себя).

Если $N$ не является минимальной, существует нотация $\NNot{\underline{N}}{\Core{N}}{\MM{M}}$, являющаяся минимальной частью $N$: ее можно получить, сузив функцию $Meaning_N$ на ядро нотации $N$. Для каждого предложения $m$ языка $\LMM{M}$ можно выбрать ``каноническое представление'' в нотации $\underline{N}$, то есть элемент $Norm(m) \in \Core{N}$, такой что $Meaning_{\underline{N}}(Norm(m)) = m$.

Теперь рассмотрим нотацию $\NNot{\overline{N}}{\MM{N}}{\Core{N}}$ с функцией
	$$Meaning_{\overline{N}}(n) := Norm(Meaning_N(n)),$$
легко видеть, что $N = \Comp{\overline{N}}{\underline{N}}$.
\end{proof}

Мы показали, что инфраструктурная функциональность может быть выражена статически как трансляция расширенной нотации в минимальную.  Ниже мы покажем, что многие возможности языков программирования, связанные с повторным использованием, могут быть выражены с использованием только инфраструктурных элементов. Это позволяет реализовывать такие возможности отдельно от основных возможностей языка, а также автоматизировать их создание.

Повторное использование всегда базируется на тех или иных механизмах композиции: средствах, позволяющих комбинировать одни и те же объекты многими способами.

// Пояснить

??? В принципе, композиция может поддерживаться не только на уровне инфраструктуры, но и на уровне содержания языка. Например, как мы покажем ниже, модули часто являются элементами инфраструктуры, а функции и классы, также обеспечивающие композицию, имеют динамическую семантику и, следовательно, являются неотъемлемыми элементами содержания языка.

??? Рассмотрим наиболее широко используемые средства композиции, которые как правило обеспечиваются инфраструктурой.

\section{Механизмы идентификации}

Для реализации механизмов повторного использования (композиции) необходимо, чтобы в языке была возможность \term{идентификации} внутри программы, то есть, чтобы из одной части программы можно было сослаться на элемент, определенный в другой ее части. Чаще всего для этой цели используются имена --- уникальные строковые идентификаторы присваиваемые переменным, функциям и т. д., однако нередко используются и более сложные механизмы, например квалифицированные имена (пакет + подпакеты + класс) в \tool{Java} \cite{JLS} или сигнатуры функций при перегрузке в \tool{C++} \cite{???}. Так или иначе, элементам программы сопоставляются \term{идентификаторы} --- объекты, уникальные в определенной области видимости. Важно отметить, что идентификатор не обязан быть уникальным глобально: во-первых, если он уникален в рамках поименованной области видимости, которая, в свою очередь, имеет глобальный идентификатор, этой информации достаточно, чтобы глобально идентифицировать объект; в этом случае мы будем говорить о составном идентификаторе, включающем идентификатор области видимости. Во-вторых, идентифицируемый объект может быть принципиально не доступен из некоторых областей видимости, как, например, локальная переменная, которая ``не существует'' за пределами функции, в которой она объявлена. К таким объектам не должно быть доступа извне, а следовательно и глобальных идентификаторов.

%Наша задача --- показать, что идентификаторы как таковые в большинстве языков являются инфраструктурными элементами нотации. Интуитивно, аргументом в пользу этого является тот факт, что при согласованном переименовании всех упоминаний некоторого элемента в программе, смысл программы (то есть значение функции $Meaning_N$) остается прежним\footnote{Исключением из этого правила являются языки с динамическими возможностями, в частности, поддерживающие \term{рефлексию} \cite{???}.}. В теории функционального программирования такое преобразование называется $\alpha$-редукцией \cite{???}; в силу значительных неудобств, связанных с формализацией $\alpha$-редукции при описании семантики различных $\lambda$-исчислений, были разработаны методы, позволяющие полностью избавиться от имен при описании семантики \cite{HOAS, NomL}.

Пусть $\MM{C}$ --- мета-модель, описывающая машинный код (или язык ассемблера) некоторого процессора или виртуальной машины. Язык $L$, компилируемый для этого процессора или виртуальной машины, можно рассматривать как нотацию $\N{L}{C}$. Эту нотацию можно представить как композицию двух других нотаций: 
$$N{L}{C} := \Comp{\Not{P}{L}{G}}{\Not{Q}{G}{C}},$$
причем в мета-модели 
Ссылки на переменные (вложенные области видимости)
Ссылки на функции и перегрузка
Пространства имен (могут быть и вложенными)
Атрибуты доступа?

\section{Модули}

В большинстве языков программирования \term{модулями} называются фрагменты программ, пригодные для повторного использования путем цитирования: при необходимости обратиться к коду, находящемуся внутри модуля, достаточно ``подключить'' этот модуль в текущей области видимости, после чего можно пользоваться именованными элементами программы, определенными в этом модуле. \cite{???}

Цитирование является, очевидно, простейшим из возможных способов композиции --- одна часть программы просто ссылается на другую. Рассмотрим механизмы работы модулей в различных языках программирования и возможности реализации этих механизмов как инфраструктурных элементов нотации. Нотацию каждого языка мы попытаемся разделить на ядро и инфраструктуру, таким образом, чтобы все, что касается модулей, оказалось в инфраструктурной части.

\paragraph*{Язык \tool{C}. } Вероятно, самая простая реализация модулей принята в языке программирования \tool{C} \cite{???}. Строго говоря, в языке \tool{C} модули вообще не поддерживаются, поскольку обработкой подключаемых заголовков занимается отдельная программа --- \term{препроцессор} \cite{???}, которая способна обрабатывать произвольный текст, размеченный специальными \term{директивами}, а не только код, написанный на языке \tool{C}. 
Однако, поскольку спецификация препроцессора включена в стандарт, и практически никакая программа на \tool{C} не мыслима без его использования, мы будем рассматривать директивы препроцессора как часть нотации языка \tool{C}.

Объявления библиотечных функций и структур данных делаются в отдельных файлах, называемых \term{заголовочными} (header files). Эти файлы, как правило, не содержат реализаций функций, которые помещаются в \term{исходных файлах} (source files). Исходные и заголовочные файлы могут использовать директивы включения \code{\#include}. Препроцессор, обрабатывает исходные файлы по отдельности, вставляя текст включаемых файлов вместо директив включения, пока в тексте есть такие директивы. Таким образом, в результате получается один файл, содержащий все прямо или косвенно включенные объявления, который, в свою очередь, обрабатывается компилятором.

Из сказанного выше видно, что процесс обработки исходного текста включает фазу, которая переводит программу в более богатой нотации (с директивами включения) в программу в менее богатой нотации. Поэтому мы можем рассматривать директивы препроцессора как инфраструктурную часть нотации языка \tool{C}, а отделение препроцессора от компилятора --- как декомпозицию нотаций. 

Вывод: в языке \tool{C} механизм композиции обеспечивается с помощью инфраструктурных элементов нотации. 

\paragraph*{Язык \tool{Pascal}. } В языке \tool{Pascal} \cite{???} модули (units) являются частью основной нотации: каждый модуль имеет имя, которое используется для ссылок на него (в отличие от имени файла в случае \tool{C}), объявления, сделанные в модуле получают идентификаторы в соответствующем пространстве имен, то есть если имена функций, объявленных в разных модулях, совпадают, у программиста есть возможность явно указать, об объявлении из какого модуля идет речь в программе. Сходство с \tool{C} заключается в том, что каждый модуль определяется в отдельном файле, имеется способ подключения модулей, в модуле выделяется интерфейсная часть, в которой, как и в заголовочном файле в \tool{C}, могут содержаться только объявления. Можно сказать, что система модулей \tool{Pascal} гораздо больше контролируется статически, в отличие от \tool{C} (это утверждение верно и при сравнении другой функциональности этих языков). 

Несмотря на то, что в случае языка \tool{Pascal} механизм, обрабатывающий модули, интегрирован в компилятор и не является отдельной программой как препроцессор \tool{C}, мы можем представить нотацию этого языка как композицию двух нотаций, вторая из которых не содержит модулей (то есть реализовать модули как инфраструктурную часть нотации). Функцию $Meaning$ для первой нотации достаточно реализовать аналогично принципу работы препроцессора в \tool{C}: вставить текст модулей в использующие из программы (переименовывая элементы в случае повторений \cite{capture-avoiding-substitution})\footnote{В некоторых случаях будет необходимо добавить предварительные декларации для типов и функций, но это всегда возможно сделать, поскольку \tool{Pascal} запрещает циклические зависимости между интерфейсами модулей}. Программа, полученная в результате не будет содержать следующих элементов: предложений \code{uses} (включений модулей), объявлений модулей (\code{unit interface ... implementation ... end}), имен переменных, функций и типов, квалифицированных именами модулей для разрешения конфликтов (эти элементы будут переименованы).

Вывод: механизм модулей языка \tool{Pascal} можно представить в виде инфраструктурной части нотации.

\paragraph*{Язык \tool{Java}.} Модули, аналогичные тем, что есть в \tool{Pascal} и \tool{C}, в языке \tool{Java} в чистом виде не представлены: функции пространств имен для объявлений выполняют классы, которые также являются объявлениями типов \cite{JLS}. Наиболее близким к традиционным модулям понятием в \tool{Java} является \term{пакет} (package) --- пространство имен, в котором объявляются только типы (классы, интерфейсы, перечисления). Пакеты с модулями роднит в первую очередь механизм \term{импортирования}: чтобы воспользоваться типом, объявленным в другом пакете, программисту необходимо написать предложение \code{import} или квалифицировать имя класса именем пакета.

Если не принимать во внимание динамических возможностей языка \tool{Java} (в первую очередь, библиотеки \code{reflection}, позволяющей обращаться к классам и методам по идентификаторам, записанным в виде строк \cite{JLS}), пакеты можно выразить как инфраструктурную функциональность (аналогично модулям в \tool{Pascal}). Но этот подход воспрепятствует правильной работе механизмов, основанных на динамической загрузке классов, таких, например, как использование одного экземпляра библиотеки несколькими приложениями.

Вывод: механизм пакетов языка \tool{Java} можно выразить с помощью инфраструктуры нотации лишь частично.

\section{Шаблоны}

В предыдущем разделе мы видели, в какой мере модули могут быть выражены как инфраструктура нотации. Общий вывод таков: статическая композиция выражается легко, а динамическая --- не выражается. Это вполне естественно, поскольку само понятие инфраструктуры нотации основывается на \emph{статической} композиции, а не на динамической. Грубо говоря, инфраструктура описывает часть программы, которая может быть полностью вычислена во время компиляции.

Модули представляют собой самый простой механизм композиции. В данном разделе мы рассмотрим механизм \term{макроопределений} (или ``шаблонов''), который, не котором смысле обобщает механизм модулей и предоставляет возможности для более гибкого повторного использования.

\paragraph*{Происхождение термина ``шаблон''.} Термин ``шаблон'' (template) позаимствован из языка программирования \tool{C++} \cite{???}. Этот язык позволяет программисту определять не только классы и функции, но и шаблоны классов и функций --- параметризованные определения, которые можно \term{инстанцировать}, указав значения параметров. Как правило, параметрами являются типы, но можно использовать и константы. Изначально шаблоны были введены в язык для того, чтобы поддержать параметрический полиморфизм \cite{???}, который необходим для реализации удобной библиотеки контейнеров \cite{???}, однако оказалось, что шаблоны позволяют сделать гораздо больше \cite{???}, например, и их помощью можно вычислить во время компиляции любую рекурсивную функцию \cite{???}, то есть компилятор \tool{C++} представляет собой интерпретатор вычислительно универсального языка, основными элементами которого являются шаблоны.

Так или иначе, шаблоны являются частью инфраструктуры нотации языка, поскольку на этапе компиляции каждое упоминание шаблона разворачивается в результате подстановки аргументов на место параметров, и становится обыкновенной функцией или классом. Здесь необходимо заметить, что вследствие вычислительной универсальности шаблонов, процесс их разворачивания может никогда не закончиться (можно написать ``программу'' на шаблонах, порождающую бесконечную цепь рекурсивных обращений шаблонов к самим себе), этот сценарий мы будем считать ошибкой компиляции, то есть функция $Meaning$ для такого входа возвращает $\bot$.

// Haskell \textbf{Template} Meta-programming

\paragraph*{Происхождение термина ``макроопределение''.} Термин ``макроопределение'' (macro-definition или macro\footnote{В некоторых русскоязычных источниках можно встретить слово ``макрос'' (как единственное число существительного мужского рода в именительном падеже), которое образовано транслитерацией слова ``macros'', являющегося формой множественного числа. В силу его грамматической несогласованности, мы избегаем использования этого термина.}) восходит к языкам семейства \tool{Lisp} \cite{???}. Так называется определение в программе, часто --- параметризованное, на которое можно сослаться по имени как на функцию, но оно будет заменено в тексте программы до его выполнения. Например, в языке, где параметры функциям передаются по значению, повторно используемую подпрограмму для обмена переменных местами можно реализовать в виде макроопределения \cite{???}.

\begin{lstlisting}[language=Lisp,label=scheme_swap]
 (define-syntax-rule (swap x y)
    (let ([tmp x])
      (set! x y)
      (set! y tmp)))
\end{lstlisting}

Обращение к этому определению будет заменено на фрагмент программы, меняющий местами значения двух переменных, тогда как вызов функции менял бы местами значения их локальных копий в стеке.

Макроопределения (как и шаблоны) часто используются для создания встроенных предметно-ориентированных языков \cite{???}, поскольку они позволяют в некотором смысле расширить язык программирования новыми конструкциями (то есть, в каком-то смысле, добавить в нотацию новые инфраструктурные элементы).

Очевидны сходства макроопределений \tool{Lisp} с шаблонами \tool{C++}: и те, и другие являются параметризованными фрагментами программ, которые разворачиваются во время компиляции. 

\paragraph*{Обработка идентификаторов при разворачивании макроопределений и шаблонов.}
Разворачивание макроопределений (и шаблонов) связано с проблемой повторения идентификаторов. Если обратиться к макроопределению, меняющему местами значение двух переменных через переменную \code{tmp}, дважды, имя \code{tmp} будет объявлено дважды, что во многих языках вызовет ошибку. В других языках это может привести к изменению значения другой переменной, имя которой случайно совпало с \code{tmp}.

В некоторых системах (как, например, в упоминавшемся выше препроцессоре языка \tool{C}, поддерживающем также и макроопределения) решение этих проблем полностью возлагается на программиста: его внимательность и осторожность. Более совершенные системы гарантируют обнаружение подобных ошибок во время компиляции.

В случае шаблонов \tool{C++} задача относительно проста, поскольку тело шаблона (функция или класс) является пространством имен, поэтому необходимо лишь отслеживать отсутствие повторений в именах шаблонов, а также обеспечить различение результатов развертывания с различными параметрами. Так, компилятор считает использования одного и того же шаблона класса \code{std::vector<int>} и \code{std::vector<string>} разными типами, несмотря на то, что имя шаблона повторяется. Таким образом, идентификатором результата развертывания является имя шаблона и его аргументы. При многократном упоминании одного и того же идентификатора (например, \code{std::vector<string>}) шаблон разворачивается только один раз. Можно говорить о том, что в \tool{C++} проблема именования при развертывании шаблона решена \emph{ad hoc}, за счет ограничения набора элементов, которые могут быть результатом развертывания.

В \tool{Lisp}\footnote{Речь идет о семействе \tool{Lisp} 2 \cite{???}} эта проблема решается в более общем виде: с помощью \term{генерирования свежих имен} и \term{гигиены}. Генерирование свежих имен реализовано специальной операцией \code{gensym}, которая порождает имя, не занятое в текущей области видимости. ``Гигиеной'' (hygiene) называется система средств, позволяющих во время развертывания макроопределения проверять, определено ли уже то или иное имя, и переименовывать элементы в случае необходимости.

// Подробнее



Те же модули, но с параметрами (полиморфные или обобщенные)
	то есть включение, но с внедрением пользовательской информации. Контроль на стороне клиента
	LISP
	макросы в C
	С++
	m4/ST/Vel
	Haskell Template Meta-programming
	Nemerle
	Macros as MultiStage Computations: TypeSafe,Generative, Binding Macros in MacroML
}	
\section{Аспекты}

Если смотреть на модули и шаблоны (макроопределения) как на механизмы композиции, они являются последовательными этапами на пути придания гибкости процессу комбинации фрагментов программы. Пусть есть два фрагмента: M (от Main, основная программа) и L (jn Library, библиотека), и M должен использовать часть функциональности L. В этом случае, при использовании простых модулей, M должен выбрать фрагменты L, которые ему нужны, и использовать их. В случае шаблонов, M не только выбирает нужные ему фрагменты, но и может модифицировать их, подставляя собственные значения шаблонным параметрам. Сказанное иллюстрируется \figref{Composition}.

\begin{figure}[htbp]
// Картинка: кружочек, кружочек с дырками, подписано, что L, а что M
\caption{Виды композиции}\label{Composition}
\end{figure}

Развитие этой линии приводит нас к следующему механизму композиции: M вообще не обязан выбирать сам, L может самостоятельно определить, каким частям программы понадобятся те или иные элементы. Такой механизм является дополнительным к описанным выше; он лежит в основе \term{аспектно-ориентированного программирования} (АОП, \cite{???}).

\paragraph*{Язык \tool{AspectJ}.} АОП получило распространение благодаря языку \tool{AspectJ} \cite{???}, созданному на основе \tool{Java}, добавляя конструкции для нового способа композиции (сразу видно, что речь во многом идет об инфраструктурной функциональности). Основными концепциями в новом языке стали \term{точки присоединения} (join points), \term{срезы} (point-cuts) и \term{советы} (advice). Все эти элементы определяются внутри структурных элементов, называемых \term{аспектами}. Аспекты определяют в себе черты классов, объединяющих взаимосвязанные функции и данные, и модулей, хранящих независимые элементы, одновременно.

Аспектно-ориентированная композиция заключается в том, что код \term{совета} встраивается в основную программу. Например, для записи информации о ходе выполнения в журнал, требуется вписать однотипный код во множество мест в программе. Аспекты позволяют решить эту задачу, написав необходимый фрагмент кода только один раз.

Позиции, в которые код может встраиваться, называются \term{точками присоединения}. В \tool{AspectJ} это позиции перед и после вызовов функций, присваиваний, создания объектов и т. д. Для того, чтобы присоединить \term{совет} сразу ко множеству точек, это множество задается с помощью выражений, называемых \term{срезами}. Срезы описывают статическое или динамическое положение точки в программе, например ``вызов метода a()'' или ``создание объекта класса, имя которого начинается на A, которое происходит в потоке управления метода x()''. При присоединении \term{совета} к срезу указывается относительное положение: \term{совет} может присоединяться \term{до} (before), \term{после} (after) или \term{вместо} (around) каждой точки присоединения, соответствующей срезу.

Частным случаем такого подхода является добавление аспектом полей и методов в существующие классы, причем исходный код самих этих классов не изменяется. Этот механизм носит название ITD (Inter-Type Declarations). Например, специальный аспект может реализовывать методы \code{toString} для нескольких классов в одном файле, объединяя таким образом эту функциональность в одном модуле:

\begin{lstlisting}[language={[AspectJ]Java}]
aspect ToString {
	public String A.toString() {
		return "A: " + data;
	}

	public String B.toString() {
		return "B: " + data;
	}

	public String C.toString() {
		return "B: " + data + " " + moreData;
	}
}
\end{lstlisting}

\paragraph*{Характеристические свойства АОП.} С момента появления языка \tool{AspectJ} разработано множество концепций, так или иначе ``напоминающих'' идеи, заложенные в этом языке. В 2000 году в работе \cite{Obliviousness} была предпринята попытка выработать определение АОП, чтобы иметь эффективный критерий, позволяющий сказать, является ли данный язык аспектно-ориентированным. Название работы говорит само за себя: ``Aspect-oriented programming is quantification and obliviousness''\footnote{\textit{(англ.)} Аспектно-ориентированное программирование --- это квантификация и незнание.}
Под \term{квантификацией} (quantification) понимается возможность охарактеризовать множество точек присоединения предикатом, записанном на специальном языке. Под \term{незнанием} (obliviousness) подразумевается, что программа, в которою встраиваются \term{советы}, не знает о том, что они есть, то есть никак не зависит от их кода (код советов может зависеть от кода этой программы).

Таким образом, можно говорить о том, что аспекты --- это ``шаблоны наоборот'': не M использует L, дополняя ее своими фрагментами, а L ``сама'' встраивается в M.

\paragraph*{Аспекты как инфраструктурная функциональность.} \tool{AspectJ} статически компилируется в байт-код платформы \tool{Java}\footnote{Это не единственный способ присоединения аспектов к \tool{Java}-программам. Кроме него поддерживается \term{динамическое встраивание}, при котором байт-код модифицируется при загрузке классов во время выполнения}, из которого можно однозначно восстановить исходный код Java-программы. Это преобразование можно представить как трансформацию кода \tool{AspectJ} в код на \tool{Java} с последующей компиляцией. То есть аспекты можно реализовать как элемент инфраструктуры нотации \tool{AspectJ}.

// Не сказать ли про другие языки?


Сложные правила композиции (взаимопроникающие модули, инвазивная композиция): внедрение доп. информации без ведома клиента (слабее зависимости), прозрачность и т.д.
	
	AspectJ, терминология
	АПОЯ
		примеры для разных доменов
		примеры для грамматик


\section{Распространение рассмотренных механизмов композиции}

табличка: что где есть

мы рассмотрели вот эти языки. эти фичи есть почти везде, значит их приходится часто реализовывать, значит это надо автоматизировать.

\section{Диалекты}

// Рассказать про задачу разработки диалектов трех типов
// Сослаться на статьи про эволюцию языков
