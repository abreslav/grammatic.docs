\chapter{Понятие языка}

Несмотря на то, что концепции мета-моделирования и ПОЯ развивались независимо, они тесно связаны между собой, поскольку мета-модели логично рассматривать как языки описания моделей (а мета-мета-модель, соответственно, как язык описания мета-моделей). Таким образом, \tool{Ecore} (MOF, KM3 и т. д.) можно рассматривать как ПОЯ для описания ПОЯ. Эта точка зрения приобретает все большую популярность \cite{}.

Для более глубокого понимания взаимосвязей мета-моделирования и ПОЯ требуется определить само понятие ``язык''. В разных областях математики, логики и компьютерных наук это делается по-разному \cite{???}, например в математической логике термин ``язык'' часто используется как синоним термина ``множество''; нередко имеется в виду множество, описанное определенным образом \cite{}. Здесь и далее мы не будем говорить о языках ``вообще'', а ограничим наше рассмотрение \term{языками моделей}:

\newcommand{\Lang}[1]{\mathcal{L}\left(#1\right)}%
\newcommand{\LMM}[1]{\Lang{\MM{#1}}}%

\begin{Def}
Пусть задана мета-модель $\MM{M}$. Будем называть множество всех моделей, являющихся экземплярами $\MM{M}$, \term{языком, порожденным этой мета-моделью}, и обозначать $\Lang{\MM{M}}$.
\end{Def}

Это определение позволяет описывать как языки моделирования, такие как UML \cite{UML}, которые изначально задаются с помощью мета-моделей, так и языки в более традиционном понимании. Например, в теории формальных языков \cite{???} принято определять язык как множество строк над конечным алфавитом; под наше определение подпадают те из языков, определенных таким образом, для которых есть конечное описание в виде (не обязательно контекстно-свободной) грамматики \cite{???}. Мета-модель, соответствующая грамматике состоит из классов, описывающих структуры термов соответствующей индуцированной алгебры \cite{???}.


\section{Шаблоны}

В предыдущем разделе мы видели, в какой мере модули могут быть выражены как инфраструктура нотации. Общий вывод таков: статическая композиция выражается легко, а динамическая --- не выражается. Это вполне естественно, поскольку само понятие инфраструктуры нотации основывается на \emph{статической} композиции, а не на динамической. Грубо говоря, инфраструктура описывает часть программы, которая может быть полностью вычислена во время компиляции.

Модули представляют собой самый простой механизм композиции. В данном разделе мы рассмотрим механизм \term{макроопределений} (или ``шаблонов''), который, не котором смысле обобщает механизм модулей и предоставляет возможности для более гибкого повторного использования.

\paragraph*{Происхождение термина ``шаблон''.} Термин ``шаблон'' (template) позаимствован из языка программирования \tool{C++} \cite{???}. Этот язык позволяет программисту определять не только классы и функции, но и шаблоны классов и функций --- параметризованные определения, которые можно \term{инстанцировать}, указав значения параметров. Как правило, параметрами являются типы, но можно использовать и константы. Изначально шаблоны были введены в язык для того, чтобы поддержать параметрический полиморфизм \cite{???}, который необходим для реализации удобной библиотеки контейнеров \cite{???}, однако оказалось, что шаблоны позволяют сделать гораздо больше \cite{???}, например, и их помощью можно вычислить во время компиляции любую рекурсивную функцию \cite{???}, то есть компилятор \tool{C++} представляет собой интерпретатор вычислительно универсального языка, основными элементами которого являются шаблоны.

Так или иначе, шаблоны являются частью инфраструктуры нотации языка, поскольку на этапе компиляции каждое упоминание шаблона разворачивается в результате подстановки аргументов на место параметров, и становится обыкновенной функцией или классом. Здесь необходимо заметить, что вследствие вычислительной универсальности шаблонов, процесс их разворачивания может никогда не закончиться (можно написать ``программу'' на шаблонах, порождающую бесконечную цепь рекурсивных обращений шаблонов к самим себе), этот сценарий мы будем считать ошибкой компиляции, то есть функция $Meaning$ для такого входа возвращает $\bot$.

// Haskell \textbf{Template} Meta-programming

\paragraph*{Происхождение термина ``макроопределение''.} Термин ``макроопределение'' (macro-definition или macro\footnote{В некоторых русскоязычных источниках можно встретить слово ``макрос'' (как единственное число существительного мужского рода в именительном падеже), которое образовано транслитерацией слова ``macros'', являющегося формой множественного числа. В силу его грамматической несогласованности, мы избегаем использования этого термина.}) восходит к языкам семейства \tool{Lisp} \cite{???}. Так называется определение в программе, часто --- параметризованное, на которое можно сослаться по имени как на функцию, но оно будет заменено в тексте программы до его выполнения. Например, в языке, где параметры функциям передаются по значению, повторно используемую подпрограмму для обмена переменных местами можно реализовать в виде макроопределения \cite{???}.

\begin{lstlisting}[language=Lisp,label=scheme_swap]
 (define-syntax-rule (swap x y)
    (let ([tmp x])
      (set! x y)
      (set! y tmp)))
\end{lstlisting}

Обращение к этому определению будет заменено на фрагмент программы, меняющий местами значения двух переменных, тогда как вызов функции менял бы местами значения их локальных копий в стеке.

Макроопределения (как и шаблоны) часто используются для создания встроенных предметно-ориентированных языков \cite{???}, поскольку они позволяют в некотором смысле расширить язык программирования новыми конструкциями (то есть, в каком-то смысле, добавить в нотацию новые инфраструктурные элементы).

Очевидны сходства макроопределений \tool{Lisp} с шаблонами \tool{C++}: и те, и другие являются параметризованными фрагментами программ, которые разворачиваются во время компиляции. 

\paragraph*{Обработка идентификаторов при разворачивании макроопределений и шаблонов.}
Разворачивание макроопределений (и шаблонов) связано с проблемой повторения идентификаторов. Если обратиться к макроопределению, меняющему местами значение двух переменных через переменную \code{tmp}, дважды, имя \code{tmp} будет объявлено дважды, что во многих языках вызовет ошибку. В других языках это может привести к изменению значения другой переменной, имя которой случайно совпало с \code{tmp}.

В некоторых системах (как, например, в упоминавшемся выше препроцессоре языка \tool{C}, поддерживающем также и макроопределения) решение этих проблем полностью возлагается на программиста: его внимательность и осторожность. Более совершенные системы гарантируют обнаружение подобных ошибок во время компиляции.

В случае шаблонов \tool{C++} задача относительно проста, поскольку тело шаблона (функция или класс) является пространством имен, поэтому необходимо лишь отслеживать отсутствие повторений в именах шаблонов, а также обеспечить различение результатов развертывания с различными параметрами. Так, компилятор считает использования одного и того же шаблона класса \code{std::vector<int>} и \code{std::vector<string>} разными типами, несмотря на то, что имя шаблона повторяется. Таким образом, идентификатором результата развертывания является имя шаблона и его аргументы. При многократном упоминании одного и того же идентификатора (например, \code{std::vector<string>}) шаблон разворачивается только один раз. Можно говорить о том, что в \tool{C++} проблема именования при развертывании шаблона решена \emph{ad hoc}, за счет ограничения набора элементов, которые могут быть результатом развертывания.

В \tool{Lisp}\footnote{Речь идет о семействе \tool{Lisp} 2 \cite{???}} эта проблема решается в более общем виде: с помощью \term{генерирования свежих имен} и \term{гигиены}. Генерирование свежих имен реализовано специальной операцией \code{gensym}, которая порождает имя, не занятое в текущей области видимости. ``Гигиеной'' (hygiene) называется система средств, позволяющих во время развертывания макроопределения проверять, определено ли уже то или иное имя, и переименовывать элементы в случае необходимости.

// Подробнее



Те же модули, но с параметрами (полиморфные или обобщенные)
	то есть включение, но с внедрением пользовательской информации. Контроль на стороне клиента
	LISP
	макросы в C
	С++
	m4/ST/Vel
	Haskell Template Meta-programming
	Nemerle
	Macros as MultiStage Computations: TypeSafe,Generative, Binding Macros in MacroML

\section{Аспекты}

Если смотреть на модули и шаблоны (макроопределения) как на механизмы композиции, они являются последовательными этапами на пути придания гибкости процессу комбинации фрагментов программы. Пусть есть два фрагмента: M (от Main, основная программа) и L (от Library, библиотека), и M должен использовать часть функциональности L. В этом случае, при использовании простых модулей, M должен выбрать фрагменты L, которые ему нужны, и использовать их. В случае шаблонов, M не только выбирает нужные ему фрагменты, но и может модифицировать их, подставляя собственные значения шаблонным параметрам. Сказанное иллюстрируется \figref{Composition}.

\begin{figure}[htbp]
// Картинка: кружочек, кружочек с дырками, подписано, что L, а что M
\caption{Виды композиции}\label{Composition}
\end{figure}

Развитие этой линии приводит нас к следующему механизму композиции: M вообще не обязан выбирать сам, L может самостоятельно определить, каким частям программы понадобятся те или иные элементы. Такой механизм является дополнительным к описанным выше; он лежит в основе \term{аспектно-ориентированного программирования} (АОП, \cite{AOP}).

\paragraph*{Язык \tool{AspectJ}.} АОП получило распространение благодаря языку \tool{AspectJ} \cite{AspectJ}, созданному на основе \tool{Java}, добавляя конструкции для нового способа композиции (сразу видно, что речь во многом идет об инфраструктурной функциональности). Основными концепциями в новом языке стали \term{точки присоединения} (join points), \term{срезы} (point-cuts) и \term{советы} (advice). Все эти элементы определяются внутри структурных элементов, называемых \term{аспектами}. Аспекты определяют в себе черты классов, объединяющих взаимосвязанные функции и данные, и модулей, хранящих независимые элементы, одновременно.

Аспектно-ориентированная композиция заключается в том, что код \term{совета} встраивается в основную программу. Например, для записи информации о ходе выполнения в журнал, требуется вписать однотипный код во множество мест в программе. Аспекты позволяют решить эту задачу, написав необходимый фрагмент кода только один раз.

Позиции, в которые код может встраиваться, называются \term{точками присоединения}. В \tool{AspectJ} это позиции перед и после вызовов функций, присваиваний, создания объектов и т. д. Для того, чтобы присоединить \term{совет} сразу ко множеству точек, это множество задается с помощью выражений, называемых \term{срезами}. Срезы описывают статическое или динамическое положение точки в программе, например ``вызов метода a()'' или ``создание объекта класса, имя которого начинается на A, которое происходит в потоке управления метода x()''. При присоединении \term{совета} к срезу указывается относительное положение: \term{совет} может присоединяться \term{до} (before), \term{после} (after) или \term{вместо} (around) каждой точки присоединения, соответствующей срезу.

Частным случаем такого подхода является добавление аспектом полей и методов в существующие классы, причем исходный код самих этих классов не изменяется. Этот механизм носит название ITD (Inter-Type Declarations). Например, специальный аспект может реализовывать методы \code{toString} для нескольких классов в одном файле, объединяя таким образом эту функциональность в одном модуле:

\begin{lstlisting}[language={[AspectJ]Java}]
aspect ToString {
	public String A.toString() {
		return "A: " + data;
	}

	public String B.toString() {
		return "B: " + data;
	}

	public String C.toString() {
		return "B: " + data + " " + moreData;
	}
}
\end{lstlisting}

\paragraph*{Характеристические свойства АОП.} С момента появления языка \tool{AspectJ} разработано множество концепций, так или иначе ``напоминающих'' идеи, заложенные в этом языке. В 2000 году в работе \cite{Obliviousness} была предпринята попытка выработать определение АОП, чтобы иметь эффективный критерий, позволяющий сказать, является ли данный язык аспектно-ориентированным. Название работы говорит само за себя: ``Aspect-oriented programming is quantification and obliviousness''\footnote{\textit{(англ.)} Аспектно-ориентированное программирование --- это квантификация и незнание.}
Под \term{квантификацией} (quantification) понимается возможность охарактеризовать множество точек присоединения предикатом, записанном на специальном языке. Под \term{незнанием} (obliviousness) подразумевается, что программа, в которою встраиваются \term{советы}, не знает о том, что они есть, то есть никак не зависит от их кода (код советов может зависеть от кода этой программы).

Таким образом, можно говорить о том, что аспекты --- это ``шаблоны наоборот'': не M использует L, дополняя ее своими фрагментами, а L ``сама'' встраивается в M.

\paragraph*{Аспекты как инфраструктурная функциональность.} \tool{AspectJ} статически компилируется в байт-код платформы \tool{Java}\footnote{Это не единственный способ присоединения аспектов к \tool{Java}-программам. Кроме него поддерживается \term{динамическое встраивание}, при котором байт-код модифицируется при загрузке классов во время выполнения}, из которого можно однозначно восстановить исходный код Java-программы. Это преобразование можно представить как трансформацию кода \tool{AspectJ} в код на \tool{Java} с последующей компиляцией. То есть аспекты можно реализовать как элемент инфраструктуры нотации \tool{AspectJ}.

// Не сказать ли про другие языки?


Сложные правила композиции (взаимопроникающие модули, инвазивная композиция): внедрение доп. информации без ведома клиента (слабее зависимости), прозрачность и т.д.
	
	AspectJ, терминология
	АПОЯ
		примеры для разных доменов
		примеры для грамматик


\section{Распространение рассмотренных механизмов композиции}

табличка: что где есть

мы рассмотрели вот эти языки. эти фичи есть почти везде, значит их приходится часто реализовывать, значит это надо автоматизировать.

\section{Диалекты}

// Рассказать про задачу разработки диалектов трех типов
// Сослаться на статьи про эволюцию языков
