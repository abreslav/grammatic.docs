\chapter{Объектно-ориентированные модели}

!Почему такое название. Отсылки к MOF и UML. EMF. 
почему Объектно-ориентированные: мы фактически описывает общие правила типизации данных в современных ОО-языках.

!Почему мы используем модели: 
1) это близко к практике в мейнстримовых языках, поскольку модели хорошо отображаются на способы представления информации в ООП. 
2) это достаточно формально, чтобы мы могли строго доказывать свои утверждения.

\section{Понятие модели}

!Мы вводим понятие модели, начиная со структурного представления и постепенно вводя ограничения (аналогично $\lambda$-исчислениям).


\begin{Def}[Модельный терм]
Для некоторого конечного алфавита $\Sigma$
\[
\begin{array}{rrl}
	\ModelTerm & ::= & \Object{\ModelTerm_{id}}{\ModelTerm_{cl}}{\ModelTerm_{p_1}=\ModelTerm_{v_1},\ldots,\ModelTerm_{p_n}=\ModelTerm_{v_n}}, n \ge 0 \\ 
	           &   | & \Ref{\ModelTerm_{id}} \\ 
	           &   | & \List{MT_1,\ldots,MT_n}, n \ge 0 \\ 
	           &   | & \Set{MT_1,\ldots,MT_n}, n \ge 0 \\ 
	           &   | & \Null \OR  \StringT \OR \IntegerT \OR \BooleanT, \\
\end{array}
\]
где $\BooleanT = \left\{ \True, \False \right\}$.
\end{Def}

Примеры:
$1$

$\Set{null, abc, \Ref{239}}$

$\Set{\Object{a}{\Ref{a}}{b=\False}, \Ref{x}}$

!Синтаксически вводятся понятия идентификатора объекта, класса, свойства и значения свойства.

\begin{Def}
Отношение \emph{конгруэнтности} на модельных термах, \mbox{$\MCong \;\subset \ModelTerm \times \ModelTerm$}, есть минимальное отношение эквивалентности, обладающее следующими свойствами:
\begin{enumerate}
\item (Константы) $x \MCong x$, для любого $x \in \left\{\ \Null \right\} \cup \IntegerT \cup \BooleanT \cup \StringT$;
\item (Ссылки) $\Ref{x} \MCong \Ref{y}$, если $x \MCong y$;
\item (Списки) $\List{x_1, \ldots, x_n} \MCong \List{y_1, \ldots, y_n}$, если $x_i \MCong y_i$ для любого $i \in [1; n]$;
\item (Объекты) Если $id_1 \MCong id_2$, а также $c_1 \MCong c_2$, и существует перестановка $\pi$ размера $n$ такая, что $x_i \MCong x_{\pi(i)}$ и $y_i \MCong y_{\pi(i)}$ для наборов модельных термов $\left\{ x \right\}_1^n$ и $\left\{ y \right\}_1^n$, то 
$$ 
\Object{id_1}{c_2}{
	\mbox{\small$\begin{array}{c}
		x_1=y_1,\\ 
		\ldots,\\ 
		x_n=y_n
	\end{array}$}
} \MCong \Object{id_2}{c_2}{
	\mbox{\small$\begin{array}{c}
		x_{\pi(1)}=y_{\pi(1)},\\
		\ldots,\\
		x_{\pi(n)}=y_{\pi(n)}	
	\end{array}$}
}
$$
\item (Множества) Аналогично для множеств: $\Set{x_1, \ldots, x_n} \MCong \Set{x_{\pi(1)}, \ldots, x_{\pi(n)}}$.
\end{enumerate}
\end{Def}

Другими словами, множества являются конгруэнтными, если они совпадают с точностью до порядка элементов, объекты --- с точностью до порядка свойств, а прочие термы --- только в случае попарной конгруэнтности соответствующих подтермов.
\begin{Def}
Модельный терм $t$ называется \emph{правильно сформированным}, если выполняются следующие условия:\SideNote{Нужно ли здесь писать "несовпадающих"?}
\begin{enumerate}
\item Внутри $t$ не существует двух несовпадающих объектов с конгруэнтными идентификаторами;
\item Внутри $t$ не существует объекта, содержащего два несовпадающих свойства с конгруэнтными именами;
\item Внутри $t$ не существует множества, содержащего два несовпадающих конгруэнтных элемента.
\end{enumerate}
\end{Def}
\SideNote{???
- identities and property names are not objects and don't contain objects\\
}

\begin{Def}[Ссылочный контекст]
Будем называть \emph{ссылочным контекстом} функцию 
\mbox{$\RContext : \ModelTerm \rightarrow \ModelTerm$}, обладающую следующим свойством: 

Если $\RContext(id)$ определено, то $\RContext(id) = \left\{\Object{id}{\ldots}{\ldots}\right\}$
\end{Def}

Другими словами, ссылочный контекст ``находит'' объект по его идентификатору. Для удобства мы будем писать $\RContext(id)=\bot$ в случае, если $\RContext(id)$ не определено.

\begin{Def}
Будем называть 
\end{Def}
\begin{Def}[Пред-модель]
все ссылки показывают на объекты
каждая id использована ровно один раз
\end{Def}

