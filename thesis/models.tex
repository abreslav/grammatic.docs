\chapter{Объектно-ориентированные модели}

!Почему такое название. Отсылки к MOF и UML. EMF. 
почему Объектно-ориентированные: мы фактически описывает общие правила типизации данных в современных ОО-языках.

!Почему мы используем модели: 
1) это близко к практике в мейнстримовых языках, поскольку модели хорошо отображаются на способы представления информации в ООП. 
2) это достаточно формально, чтобы мы могли строго доказывать свои утверждения.

\section{Синтаксис моделей}

!Мы вводим понятие модели, начиная со структурного представления и постепенно вводя ограничения (аналогично $\lambda$-исчислениям).

\begin{Def}[Модельный терм]
\emph{Модельным термом} называется синтаксическая конструкция, удовлетворяющая следующим правилам:
\[
\begin{array}{rrl}
	\ModelTerm & ::= & \Object{\ModelTerm_{id}}{\ModelTerm_{cl}}{\ModelTerm_{p_1}=\ModelTerm_{v_1},\ldots,\ModelTerm_{p_n}=\ModelTerm_{v_n}}, n \ge 0 \\ 
	           &   | & \Ref{\ModelTerm_{id}} \\ 
	           &   | & \List{MT_1,\ldots,MT_n}, n \ge 0 \\ 
	           &   | & \Set{MT_1,\ldots,MT_n}, n \ge 0 \\ 
	           &   | & \Null \OR  \CharT \OR \StringT \OR \IntegerT \OR \BooleanT, \\
\end{array}
\]
где $\CharT$ --- некоторый конечный алфавит, \mbox{$\StringT = \Sigma*$}, а $\BooleanT = \left\{ \True, \False \right\}$.
\end{Def}

Примеры:
$1$

$\Set{null, abc, \Ref{239}}$

$\Set{\Object{a}{\Ref{a}}{b=\False}, \Ref{x}}$

!Синтаксически вводятся понятия идентификатора объекта, класса, свойства и значения свойства.

\begin{Def}
Отношение \emph{конгруэнтности} на модельных термах, \mbox{$\MCong \;\subset \ModelTerm \times \ModelTerm$}, есть минимальное отношение эквивалентности, обладающее следующими свойствами:
\begin{enumerate}
\item (Константы) $x \MCong x$, для любого $x \in \left\{\ \Null \right\} \cup \IntegerT \cup \BooleanT \cup \StringT \cup \CharT$;
\item (Ссылки) $\Ref{x} \MCong \Ref{y}$, если $x \MCong y$;
\item (Списки) $\List{x_1, \ldots, x_n} \MCong \List{y_1, \ldots, y_n}$, если $x_i \MCong y_i$ для любого $i \in [1; n]$;
\item (Объекты) Если $id_1 \MCong id_2$, а также $c_1 \MCong c_2$, и существует перестановка $\pi$ размера $n$ такая, что $x_i \MCong x_{\pi(i)}$ и $y_i \MCong y_{\pi(i)}$ для наборов модельных термов $\left\{ x \right\}_1^n$ и $\left\{ y \right\}_1^n$, то 
$$ 
\Object{id_1}{c_2}{
	\mbox{\small$\begin{array}{c}
		x_1=y_1,\\ 
		\ldots,\\ 
		x_n=y_n
	\end{array}$}
} \MCong \Object{id_2}{c_2}{
	\mbox{\small$\begin{array}{c}
		x_{\pi(1)}=y_{\pi(1)},\\
		\ldots,\\
		x_{\pi(n)}=y_{\pi(n)}	
	\end{array}$}
}
$$
\item (Множества) Аналогично для множеств: $\Set{x_1, \ldots, x_n} \MCong \Set{x_{\pi(1)}, \ldots, x_{\pi(n)}}$.
\end{enumerate}
\end{Def}

Другими словами, множества являются конгруэнтными, если они совпадают с точностью до порядка элементов, объекты --- с точностью до порядка свойств, а прочие термы --- только в случае попарной конгруэнтности соответствующих подтермов.

Введем функцию $\Objects{t}$, вычисляющую множество всех объектов, являющихся подтермами терма $t$:
$$
	\Objects{t} = \left\{
\begin{array}{ll}
%
\multicolumn{2}{l}{\{t\} \cup \Objects{id} \cup \Objects{c} \cup \bigcup\limits_i \Objects{p_i} \cup \Objects{v_i},} \\
&          t = \Object{id}{c}{p_1=v_1, \ldots, p_n=v_n}\\
%
\Objects{r},& t = \Ref{r}\\
%
\bigcup\limits_i\Objects{x_i},& t = \List{x_1, \ldots, x_n}\\
%
\bigcup\limits_i\Objects{x_i},& t = \Set{x_1, \ldots, x_n}\\
%
\emptyset, & \mbox{ в остальных случаях}
\end{array}	
	\right.
$$

Аналогично вводятся функция $\Sets{t}$, вычисляющая множество всех множеств-подтермов $t$, и функция $\Refs{t}$, вычисляющая множество всех ссылок-подтермов $t$.

\begin{Def}
Модельный терм $t$ называется \emph{правильно сформированным}, если выполняются следующие условия:\SideNote{Нужно ли здесь писать "несовпадающих"?}
\begin{enumerate}
\item В $\Objects{t}$ не существует двух несовпадающих объектов с конгруэнтными идентификаторами;
\item В $\Objects{t}$ не существует объекта, содержащего два несовпадающих свойства с конгруэнтными именами;
\item В $\Sets{t}$ не существует множества, содержащего два несовпадающих конгруэнтных элемента.
\end{enumerate}
\end{Def}
\SideNote{???
- identities and property names are not objects and don't contain objects\\
}

\begin{Def}[Ссылочный контекст]
Будем называть \emph{ссылочным контекстом} функцию 
\mbox{$\RContext : \ModelTerm \rightarrow \ModelTerm$}, обладающую следующими свойствами: 
\begin{enumerate}
\item если $\RContext(id)$ определено, то $\RContext(id) = \left\{\Object{id'}{\ldots}{\ldots}\right\}$, где $id \MCong id'$;
\item $\RContext(id) \MCong \RContext(id')$ тогда и только тогда, когда $id \MCong id'$.
\end{enumerate}
\end{Def}

Другими словами, ссылочный контекст ``находит'' объект по его идентификатору. Для удобства мы будем писать $\RContext(id)=\bot$ в случае, если $\RContext(id)$ не определено.

Обозначим множество всех объектов, \emph{упомянутых} в контексте $\RContext$ (то есть являющихся подтермами элементов области определения $\RContext$ и/или области значений $\RContext$) за $\Objects{\RContext}$. Аналогично вводится множество ссылок $\Refs{\RContext}$.

\begin{Def}
Будем называть ссылочный контекст $\RContext$ \emph{замкнутым}, если 
$$
	o=\Object{id}{\ldots}{\ldots} \in \Objects{\RContext} \Rightarrow \RContext(id)=o
$$
и
$$
	r=\Ref{id} \in \Refs{\RContext} \Rightarrow \RContext(id) \neq \bot
$$
\end{Def}

Все объекты, упомянутые в замкнутом контексте, могут быть получены по своим идентификаторам, и каждая ссылка ссылается на существующий объект. Из этого, в частности, следует, что в таком контексте каждому объекту присвоен уникальный идентификатор.

\begin{Def}
Пусть $\RContext_1$ и $\RContext_2$ -- ссылочные контексты с непересекающимися областями определения ($\forall x \in D(\RContext_1), y \in D(\RContext_2): x \nMCong y$). Тогда их \emph{объединение} определяется следующей формулой:
$$
	\left(\RContext_1 \cup \RContext_2\right)(id) = \left\{
	\begin{array}{ll}
		\RContext_1(id), & \RContext_1(id) \neq \bot \\
		\RContext_2(id), & \mbox{ в противном случае} \\
	\end{array}
	\right.
$$
\end{Def}

По модельному терму $t$ можно построить ссылочный контекст, упоминающий все объекты, входящие в $t$:
$$
	\RContext_t = \left\{ id \mapsto o \;|\; o = \Object{id}{\ldots}{\ldots} \in \Objects{t}\right\}
$$

\begin{Def}[Пред-модель]
Будем называть правильно сформированный модельный терм $t$ \emph{пред-моделью в контексте $\RContext_0$}, если контекст $\RContext_0 \cup \RContext_t$ является замкнутым.
\end{Def}

Пред-модель обладает важным свойством: любой объект в ней однозначно определяется своим идентификатором, и любая ссылка указывает на известный объект.

\section{Мета-модели и типизируемость}

!На практике для удобства навигации по моделям и контроля над их корректностью вводятся дополнительные ограничения (в виде системы типов), регулирующие структуру моделей. Сами эти ограничения также записываются в виде моделей...

\begin{Def}[Класс]
\emph{Классом} называется кортеж $\langle id, S, P \rangle$, где 
\begin{enumerate}
\item $id$ --- \emph{идентификатор} класса,
\item $S$ --- множество классов, называемых \emph{предками} данного класса (\emph{суперклассов},
\item $P$ --- множество пар вида $p : \tau$, где $p$ --- \emph{идентификатор} свойства, а $\tau$ --- \emph{тип} свойства (множество типов определяется ниже).
\end{enumerate}
Множество $P$ не содержит различных пар, в которых совпадают идентификаторы свойств.
\end{Def}

Для удобства, мы будем обозначать класс $\langle id, S, P \rangle$ через \mbox{$\Class{id}{S}{P}$}. 

\begin{Def}
Множество типов $\Types$ описывается следующим образом:
$$
\begin{array}{rrl}
\Types &::=& \CharT \OR \StringT \OR \IntegerT \OR \BooleanT \\
         &|& \AnyT \\
         &|& \ClassT{c}, \mbox{ где $c$ --- идентификатор некторого класса} \\
         &|& \RefT{c}, \mbox{ где $c$ --- идентификатор некторого класса} \\
         &|& \NullableT{\Types} \\
         &|& \SetT{\Types^+} \OR \SetT{\Types^*}\\
         &|& \ListT{\Types^+} \OR \ListT{\Types^*}
\end{array}
$$
\end{Def}
\noindent Поясним интуитивное значение типов:
\begin{itemize}
\item $\CharT, \StringT, \IntegerT, \BooleanT$ --- примитивные типы: символы, строки, целые числа, булевские значения;
\item $\ClassT{c}$ --- агрегирующая ссылка на класс $c$;
\item $\RefT{c}$ --- неагрегирующая ссылка на класс $c$;
\item $\tau^?$ --- величина, которая может принимать значение $\Null$;
\item $\SetT{\tau^*}$ ($\ListT{\tau^*}$) --- множество (список), содержащее ноль или более элементов;
\item $\SetT{\tau^*}$ ($\ListT{\tau^*}$)  --- множество (список), содержащееодин или более элементов;
\item $\AnyT$ (``Top'') --- супертип всех остальных типов (см. ниже).
\end{itemize}

Для типа $\tau$, множество упомянутых в данном типе классов определяется следующим образом:
$$
	\Classes{\tau} = \left\{
	\begin{array}{ll}
		\{c\}, & \tau \in \left\{\ClassT{c}, \RefT{c}\right\}\\
		\Classes{\sigma}, & \tau \in \left\{\ListT{\sigma^+}, \ListT{\sigma^*}, \SetT{\sigma^+}, \SetT{\sigma^*}, \NullableT{\sigma}\right\}\\
		\emptyset, & \mbox{в остальных случаях}\\
	\end{array}
	\right.
$$

Пусть дано множество классов 
$$
C = \{\Class{id_i}{S_i}{p^i_j : \tau^i_j \OR j \in [1;m_i]}\OR i \in [1;n]\},
$$
обозначим $\AllSuperclasses{C} = C \cup \AllSuperclasses{\bigcup_1^n S_i}$ множество всех классов из $C$, их предков, предков их предков и т.д.

Аналогично вводится множество всех свойств класса $c = \Class{id}{S}{p_i : \tau_i}$. Кроме свойств $p_i$, объявленных в самом $c$, рассматриваются также свойства, \emph{унаследованные} из суперклассов:  $\AllProps{C} = \bigcup\limits_{i = 1}^n\{p^i_j : \tau^i_j \OR j \in [1;m_i]\} \cup \AllProps{\AllSuperclasses{C}}$.

\begin{Def}
Конечный набор классов $C$ называется \emph{корректным}, если выполняются следующие свойства:
\begin{enumerate}
\item Все предки классов из $C$ содержатся в $C$: $\AllSuperclasses{C} = C$.
\item Все типы свойств классов из $C$ упоминают только классы из $C$: пусть $\AllProps{C} = \left\{p_i : \tau_i\right\}$, тогда $\bigcup_i \Classes{\tau_i} \subseteq C$.
\item Никакой класс из $C$ не является прямым или непрямым предком самого себя: если $c = \Class{id}{S}{\ldots} \in C$, то $c \notin \AllSuperclasses{S}$.
\end{enumerate}
\end{Def}

На типах, порожденных корректным набором классов $C$, вводится отношение ``подтип'' ($\subtype$) --- это наименьшее транзитивное рефлексивное отношение, обладающее следующими свойствами:
$$
\infer[subclass]{
\type{\mbox{TO}}{c} \subtype \type{\mbox{TO}}{s}
}{
	\Class{c}{S}{\ldots} \in C &
	s \in S & 
	\mbox{TO} \in \{\valts,\, \refts\}
}
$$  $$
\infer[option]{
	\tau \subtype \NullableT{\tau}
}{}
\quad
\infer[multiplicity]{
+ < *
}{}
$$ $$
\infer[set]{
	\SetT{\tau^\iota} \subtype \SetT{\sigma^\kappa}
}{
	\tau \subtype \sigma &
	\iota, \kappa \in \{+, *\} &
	\iota \le \kappa
}
\quad
\infer[list]{
	\ListT{\tau^\iota} \subtype \ListT{\sigma^\kappa}
}{
	\tau \subtype \sigma &
	\iota, \kappa \in \{+, *\} &
	\iota \le \kappa
}
$$

!Мета-модель накладывает ограничения на структуру объектов через типы и кратность ссылок и атрибутов. Эти ограничения мы записываем в виде системы типов, которая связывает мета-модель и объект отношением $\Vdash$. Запись $\fromMM x : \tau$ следует читать как ``\term{объект $x$ удовлетворяет ограничениям мета-модели $\MM{M}$ и имеет тип $\tau$}''.

!Enums!!!!

\begin{figure}[htbp]
	\centering
$$
	\infer[object]{
		\fromMM \Object{id}{C}{p_i = v_i} : \ClassT{C}
	}{
		\Class{C}{S}{P} \in \MM{M}&
		\AllProps{C} = \{p_i : \tau_i\}&
		\fromMM v_i : \tau_i
	}
$$
$$
\infer[ref]{
	\fromMM \Ref{id} : \RefT{C}
}{
	\fromMM \RContext(id) : \ClassT{C}
}
\quad
\infer[null]{
	\fromMM \Null : \NullableT{\tau}
}{}
$$
$$
\infer[elist]{
	\fromMM \List{\,} : \ListT{\tau^*}
}{}
\quad
\infer[list]{
	\fromMM \List{x_1, \ldots, x_n} : \List{\type{\mbox{TO}}{\tau}^+}
}{
	\forall i\in[1:n]. \; \fromMM x_i : \type{\mbox{TO}}{\tau} &
	\mbox{TO} \in \{\valts,\, \refts\}
}
$$
$$
\infer[eset]{
	\fromMM \Set{\,} : \SetT{\tau^*}
}{}
\quad
\infer[set]{
	\fromMM \Set{x_1, \ldots, x_n} : \SetT{\type{\mbox{TO}}{\tau}^+}
}{
	\forall i\in[1:n]. \; \fromMM x_i : \type{\mbox{TO}}{\tau} &
	\mbox{TO} \in \{\valts,\, \refts\}
}
$$
$$
\infer[subtype]{
	\fromMM x : \sigma
}{
	\fromMM x : \tau &
	\tau \subtype \sigma
}
$$
$$
\infer[enum]{
	\forall i \in [1:n]. \; \fromMM T.L_i : T
}{
	\mathbf{enum}\;T\{L_1,\ldots,L_n\} \in \MM{M}
}
\quad
\infer[primitive]{
	\fromMM x : \Types_P
}{
	x \in \Types_P & 
	\Types_P = \{\IntegerT, \CharT, \StringT, \BooleanT\}
}
$$
	\caption{Структурная корректность объектов}\label{TypesMM}
\end{figure}


