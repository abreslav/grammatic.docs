\chapter{Объектно-ориентированные модели}

Объектно-ориентированные модели (для краткости, ниже мы будем писать просто ``модели'') были предложены в начале 1990-х годов \cite{Booch, Rumbaugh} и с течением времени были описаны консорциумом OMG (Object Managenemt Group, \cite{OMG}) в виде ряда промышленных стандартов. Наибольшую известность среди ``модельно-ориентированных'' подходов получил унифицированный язык моделирования --- UML (Unified Modelling Language, \cite{UML}); также очень широко используется библиотека EMF (Eclipse Modelling Framework, \cite{EMF}), основанная на принципах основанная на принципах MOF (Meta-Object Factility, \cite{MOF}), являющейся частью UML (Infractructure). По сути, объектно-ориентированные модели --- это не привязанные к конкретному языку программирования структуры, представляющие данные (и способы их обработки) в объектно-ориентированном стиле.

Следуя работам \cite{Fowler, xText}, в последующих разделах мы будем использовать модели как универсальный способ описания предметно-ориентированных языков, однако на этом пути нас ждет небольшое затруднение: промышленные стандарты, упомянутые выше, не предоставляют математической базы для работы с моделями. В литературе описаны различные подходы к формализации этой области \cite{TypeMOF, MaudeMOF, FormalizingMOF}, в основном нацеленные на описание полной MOF. Использование этих формализаций затруднительно в первую очередь потому, что MOF --- это довольно объемная система, а следовательно, и формальные теории, ее описывающие, получаются достаточно громоздкими. С другой стороны, на практике, при реализации предметно-ориентированных языков, как правило, используется не вся MOF, а лишь небольшая ее часть, ``ядро'', которое называется EMOF (Essential MOF, \cite{EMOF}), именно ей соответствует реализация моделей, предоставляемая популярной библиотекой EMF, упомянутой выше. В данном разделе строится формальная теория, описывающая объектно-ориентированные модели, соответствующие EMOF.

\section{Синтаксис моделей}

Чтобы строго определить понятие модели, мы вводим ряд вспомогательных определений, начиная со структурного представления и постепенно вводя ограничения.

\begin{Def}[Модельный терм]
\emph{Модельным термом} называется формула, построенная по следующим правилам\footnote{
Для краткости мы пишем $t_1, \ldots, t_n$ вместо использования рекурсивных продукций вида $$tList ::= t \OR t \;,\; tList$$
}:
\[
\begin{array}{rrl}
	\ModelTerm & ::= & \Object{\ModelTerm_{id}}{\ModelTerm_{cl}}{\Property_1,\ldots,\Property_n}, n \ge 0 \\ 
	           &   | & \Ref{\ModelTerm_{id}} \\ 
	           &   | & \List{MT_1,\ldots,MT_n}, n \ge 0 \\ 
	           &   | & \Set{MT_1,\ldots,MT_n}, n \ge 0 \\ 
	           &   | & \Null \OR \Sigma^* \OR \mathbb{Z} \OR \mathbb{B}, \\
	\Property & ::= & \ModelTerm_{p}=\ModelTerm_{v}\\
\end{array}
\]
где $\mathbb{Z}$ --- множество целых чисел, $\Sigma$ --- некоторый конечный алфавит символов, а $\mathbb{B} = \left\{ \True, \False \right\}$.
\end{Def}

Записывая модельные термы, мы, как правило, не будем заключать строки в кавычки, а будем лишь выделять их шрифтом, чтобы отличать от \emph{метапеременных}: так, $\String{abc}$ --- это строка из трех символов, а $x$ --- метапеременная, которая, в частности может принимать значение $\String{abc}$.

Для различных видов модельных термов мы будем использовать специальные названия. Приведем примеры таких термов и обозначим названия:
\begin{itemize}
\item $\Set{\String{abc}, 239, \Null}$ --- \emph{множество}, состоящее из трех констант: строки, числа и специального значения $\Null$;
\item $\List{1, 2, 3}$ --- \emph{список} из трех чисел;
\item $\Ref{\String{x}}$ --- \emph{ссылка} на идентификатор $\String{x}$.
\item $\Object{\String{a}}{\Ref{\String{b}}}{\String{c}=\False}$ --- \emph{объект}, где $\String{a}$ --- \emph{идентификатор}, $\Ref{\String{b}}$ --- \emph{ссылка на класс}, а $\String{c} = \False$ --- \emph{свойство} с \emph{маркером} $\String{c}$ и  \emph{значением} $\False$.
\end{itemize}

\emph{Метапеременные} позволяют кратко описать множества термов, обладающих схожей структурой. Если в модельном терме используется метапеременная $a$, это означает, что на вместо нее может быть подставлен любой подтерм, синтаксически допустимый в данном контексте. Так, например, запись $\Set{a, b}$ описывает все термы-множества, состоящие из двух элементов, а $\Ref{a}$ --- ссылки на все возможные идентификаторы.

Модельные термы удобны для представления структур абстрактного синтаксиса различных языков \cite{Fowler, xText}. В качестве примера рассмотрим $\lambda$-исчисление \cite{Lambda}. Абстрактный синтаксис $\lambda$-исчисления задается тремя конструкторами: 
$$
\begin{array}{|rrl|c|}
\hline
\multicolumn{3}{|c|}{\mbox{Конструктор}} & \mbox{Пример конкретного синтаксиса}\\
\hline
LT &::=& \mathbf{Abs}(v, LT) & \lambda \, x\,.\,t\\
\hline
   &|  & \mathbf{App}(LT_1, LT_2) & (f\, x)\\
\hline
   &|  & \mathbf{Var}(v) & x\\
\hline
\end{array}
$$
где $v$ --- алфавит имен переменных. Например, $\lambda$-терм $\lambda \, x\,.\,x\,x$ в абстрактном синтаксисе записывается как $\mathbf{Abs}(x, \mathbf{App}(\mathbf{Var}(x), \mathbf{Var}(x)))$, что соответствует \emph{абстрактному синтаксическому дереву} (Abstract Syntax Tree, AST \cite{ViennaMethod}) для данного терма. То же самое AST можно представить также в виде объекта; см. \figref{lambda-as-mt}.

\begin{figure}[h!]
$$
\begin{array}{l}
	\ObjectH{\String{t1}}{\Ref{\String{Abstraction}}}\, \{\\
\quad
	\String{var} = \Object{\String{x}}{\Ref{\String{Variable}}}{\String{name}=\String{x}},\\
\quad
	\String{body} = \ObjectH{\String{t2}}{\Ref{\String{Application}}} \,\{\\
	\quad\quad \String{funciton} = \Object{\String{t3}}{\Ref{\String{Usage}}}{\String{var} = \Ref{\String{x}}}, \\
	\quad\quad \String{argument} = \Object{\String{t4}}{\Ref{\String{Usage}}}{\String{var} = \Ref{\String{x}}} \\
	\quad \}\\
	\}
\end{array}
$$
\caption{Представление AST для терма $\lambda \, x\,.\,x\,x$ в виде объектов}\label{lambda-as-mt}
\end{figure}

Из \figref{lambda-as-mt} видно, что объекты модельного терма образуют дерево, соответствующее абстрактному синтаксическому представлению $\lambda$-терма, причем роль конструкторов выполняют ссылки на классы. Обратите внимание на использование ссылок в объектах $\String{t3}$ и $\String{t4}$: значения свойства $\String{var}$ является \emph{ссылкой} на идентификатор объекта, соответствующего определению переменной $\String{x}$. 

Модельный терм можно рассматривать как граф: объекты являются вершинами, а отношение вложенности и ссылки --- ребрами. AST является остовным деревом в этом графе --- в нем участвуют только ребра вложенности объектов.

\subsection{Графическая нотация для модельных термов}

Наравне с нотацией, введенной выше, мы будем использовать для изображения объектов графическую нотацию, основанную на диаграммах объектов языка \tool{UML} \cite{UML}. На \figref{simplerlambda} в виде такой диаграммы изображены объекты, приведенные на \figref{lambda-as-mt}.

\figdef{simplerlambda}{Графическое представление для терма $\lambda \, x\,.\,x\,x$}

Объекты обозначаются прямоугольниками. В верхней части прямоугольника располагается подчеркнутая надпись: это идентификатор объекта и \emph{имя класса}. О классах подробно говорится ниже, а пока лишь заметим, что объекты, относящиеся к одному классу, имеют одинаковую структуру. Значения свойств изображаются либо под горизонтальной чертой в самом прямоугольнике (как для объекта $\String{x}$), либо в виде ребер графа. Ближе к концу ребра написано имя свойства, а в начале ребра изображается ромб: незакрашенный, если ребро соответствует ссылке\footnote{Что соответствует \emph{агрегации} в терминах UML.}, и закрашенный, если значением свойства является объект, то есть имеет место \emph{встраивание}\footnote{\emph{Композиция} --- в терминах UML} --- один объект является частью другого. Таким образом, если рассматривать только ребра с закрашенными ромбами, из графа объектов выделяется дерево, соответствующее текстовой нотации, введенной выше (см. \figref{lambda-as-mt}).

\figdef{listnotation}{Графическое представление упорядоченных списков}

Если значением свойства является множество, оно изображается несколькими ребрами с одинаковой пометкой. В случае списка важен порядок следования элементов, поэтому мы отклоняемся от нотации UML и вводим промежуточный блок с индексами, от ячеек которого отходят ребра к элементам списка. Пример использования данной нотации приведен на \figref{listnotation}: список чисел $\String{list1}$ записан непосредственно в теле объекта, а список (встраиваемых) объектов $\String{list2}$ изображен графически.

\subsection{Конгруэнтность и правильно построенные термы}

\begin{Def}
Отношение \emph{конгруэнтности} на модельных термах, \mbox{$\MCong \;\subset \ModelTerm \times \ModelTerm$}, есть минимальное отношение эквивалентности, обладающее следующими свойствами:
\begin{enumerate}
\item Константы конгруэнтны сами себе:\\
 \mbox{$x \MCong x$}, для любого $x \in \left\{\ \Null \right\} \cup \mathbb{Z} \cup \mathbb{B} \cup \Sigma^*$;
\item Ссылки на конгруэнтные индентификаторы конгруэнтны: \\
$\Ref{x} \MCong \Ref{y}$, если $x \MCong y$;
\item Списки сравниваются поэлементно: \\
$\List{x_1, \ldots, x_n} \MCong \List{y_1, \ldots, y_n}$, если $x_i \MCong y_i$ для любого $i \in [1; n]$;
\item Множества сравниваются поэлементно, без учета порядка:\\
 $\Set{x_1, \ldots, x_n} \MCong \Set{x'_{\pi(1)}, \ldots, x'_{\pi(n)}}$, если существует перестановка $\pi$ размера $n$ такая, что \mbox{$x_i \MCong x'_{\pi(i)}$} при \mbox{$i \in [1;n]$}.
\item Объекты сравниваются без учета порядка свойств:
$$ 
\Object{id_1}{c_2}{
	\mbox{\small$\begin{array}{c}
		p_1=v_1,\\ 
		\ldots,\\ 
		p_n=v_n
	\end{array}$}
} \MCong \Object{id_2}{c_2}{
	\mbox{\small$\begin{array}{c}
		p'_{\pi(1)}=v'_{\pi(1)},\\
		\ldots,\\
		p'_{\pi(n)}=v'_{\pi(n)}	
	\end{array}$}
},
$$
если $id_1 \MCong id_2$, а также $c_1 \MCong c_2$, и существует перестановка $\pi$ размера $n$ такая, что $p_i \MCong p'_{\pi(i)}$ и $v_i \MCong v'_{\pi(i)}$.
\end{enumerate}
\end{Def}

Приведем несколько примеров:
\begin{itemize}
\item $\Ref{abc} \MCong \Ref{abc}$, поскольку идентификаторы конгруэнтны;
\item $\List{1, 2} \red{\nMCong}  \List{2, 1}$, при сравнении списков порядок элементов важен;
\item а при сравнении множеств --- не важен: $\Set{1, 2} \MCong \Set{2, 1}$;
\item также не важен порядок свойств при сравнении объектов:
$$
\Object{abc}{\Ref{c}}{\mbox{
\small$\begin{array}{rcl}
a &=& b\\
c &=& d\\
\end{array}$
}} \MCong  \Object{abc}{\Ref{c}}{\mbox{
\small$\begin{array}{rcl}
c &=& d\\
a &=& b\\
\end{array}$
}},$$
\item но значения свойств важны:
$$
\Object{abc}{\Ref{c}}{\mbox{
\small$\begin{array}{rcl}
a &=& b\\
c &=& d\\
\end{array}$
}} \red{\nMCong}  \Object{abc}{\Ref{c}}{\mbox{
\small$\begin{array}{rcl}
c &=& \red{b}\\
a &=& \red{d}\\
\end{array}$
}}.
$$
\end{itemize} 

Введем функцию $\Subterms{t}$, вычисляющую множество всех подтермов терма $t$:
$$
	\Subterms{t} = \{t\} \cup \left\{
\begin{array}{ll}
%
\multicolumn{2}{l}{\Subterms{id} \cup \Subterms{c} \cup \bigcup\limits_i \Subterms{p_i} \cup \bigcup\limits_i \Subterms{v_i},} \\
&          t = \Object{id}{c}{p_1=v_1, \ldots, p_n=v_n}\\
%
\Subterms{r},& t = \Ref{r}\\
%
\bigcup\limits_i\Subterms{x_i},& t = \List{x_1, \ldots, x_n} \mbox{ или } t = \Set{x_1, \ldots, x_n}\\
%
\emptyset, & \mbox{ в остальных случаях}
\end{array}	
	\right.
$$
Пример: $\Subterms{\Object{\String{a}}{\Ref{\String{b}}}{1=\List{\Null, \False}}} = \{$\vspace{-10pt}
$$
\begin{array}{l}
\qquad\qquad
\qquad\qquad
\String{a},\quad
\Ref{\String{b}},\quad
\String{b},\quad
1,\\
\qquad\qquad
\qquad\qquad
\List{null, false},\quad
\Null,\quad
\False\\
\qquad\qquad
\qquad\qquad
\left.
\Object{\String{a}}{\Ref{\String{b}}}{1=\List{null, false}}\right\}.
\end{array}
$$

Как правило, нам будут нужны множества подтермов какого-то определенного вида, например, множество подтермов терма $t$, являющихся ссылками, мы будем обозначать
$\Refs{t}$. 
Пример: 
$$\Refs{\Object{\String{a}}{\Ref{\String{b}}}{1=\List{\Null, \False}}} = \{\Ref{\String{b}}\}.$$
Аналогично $\Sets{t}$~--- для подтермов-множеств и $\Objects{t}$ --- для подтермов-объектов.

\begin{Def}
Модельный терм $t$ называется \emph{правильно построенным}, если выполняются следующие условия:
\begin{enumerate}
\item Среди подтермов $t$ не существует двух объектов с конгруэнтными идентификаторами; \label{a}
\item В $\Objects{t}$ не существует объекта, содержащего два свойства с конгруэнтными именами; \label{b}
\item В $\Sets{t}$ не существует множества, содержащего два конгруэнтных элемента. \label{c}
\end{enumerate}
\end{Def}

Так, например, терм $\List{\Object{\red{a}}{\Ref{c}}{}, \Object{\red{a}}{\Ref{c}}{x=y}}$ не является правильно построенным (пункт \ref{a}). Терм $\Object{a}{\Ref{c}}{\red{a} = b, \red{a} = c}$ тоже не является правильно построенным, но по другой причине см. пункт \ref{b}. Согласно пункту \ref{c}, терм $\Set{\red{1}, 2, \red{1}}$ также не является правильно построенным.

\subsection{Ссылочные контексты и пред-модели}

\begin{Def}[Ссылочный контекст]
Будем называть \emph{ссылочным контекстом} частичную функцию 
\mbox{$\RContext : \ModelTerm \rightarrow \ModelTerm$}, обладающую следующими свойствами: 
\begin{enumerate}
\item Если $\RContext(id)$ определено, то $\RContext(id) = \left\{\Object{id'}{\ldots}{\ldots}\right\}$, где $id \MCong id'$;
\item $\RContext(id) \MCong \RContext(id')$ тогда и только тогда, когда $id \MCong id'$.
\end{enumerate}
\end{Def}

Другими словами, ссылочный контекст ``находит'' объект по его идентификатору. Для удобства мы будем писать $\RContext(id)=\bot$ в случае, если $\RContext(id)$ не определено.

Обозначим множество всех подтермов, \emph{упомянутых} в контексте $\RContext$, то есть являющихся подтермами элементов области определения $\RContext$ и/или области значений $\RContext$, через $\Subterms{\RContext}$. Аналогично вводятся $\Refs{\RContext}$ и $\Objects{\RContext}$.

\begin{Def}\label{RContext}
Будем называть ссылочный контекст $\RContext$ \emph{замкнутым}, если 
$$
	o=\Object{id}{\ldots}{\ldots} \in \Objects{\RContext} \Rightarrow \RContext(id)=o
$$
и
$$
	r=\Ref{id} \in \Refs{\RContext} \Rightarrow \RContext(id) \neq \bot
$$
\end{Def}

Все объекты, упомянутые в замкнутом контексте, могут быть получены по своим идентификаторам, и каждая ссылка ссылается на существующий объект. Из этого, в частности, следует, что в таком контексте каждому объекту присвоен уникальный идентификатор. Так, например, следующий контекст является замкнутым (здесь функция рассматривается как множество пар вида ``аргумент $\mapsto$ результат''):
\begin{equation*}
	\RContext(id) = \left\{
		a \mapsto \Object{a}{\Ref{a}}{} \right\}
\end{equation*}
Приведем также пример незамкнутого контекста:
\begin{equation*}
	\RContext(id) = \left\{
		a  \mapsto  \Object{a}{\red{\Ref{b}}}{c = \red{\Object{b}{\Ref{a}}{}}}
\right\}
\end{equation*}
в последнем примере нарушаются оба требования определения \ref{RContext}: 
\begin{itemize}
\item объект, упомянутый в контексте, не принадлежит области его значений;
\item ссылка, упомянутая в контексте, не принадлежит его области определения.
\end{itemize}

\begin{Def}
Пусть $\RContext_1$ и $\RContext_2$ -- ссылочные контексты с непересекающимися областями определения ($\forall x \in \mathbf{dom}(\RContext_1), y \in \mathbf{dom}(\RContext_2): x \nMCong y$). Тогда их \emph{объединение} определяется следующей формулой:
$$
	\left(\RContext_1 \cup \RContext_2\right)(id) = \left\{
	\begin{array}{ll}
		\RContext_1(id), & \RContext_1(id) \neq \bot \\
		\RContext_2(id), & \RContext_2(id) \neq \bot \\
		\bot,            & \mbox{в противном случае.}
	\end{array}
	\right.
$$
\end{Def}

По модельному терму $t$ можно построить ссылочный контекст, упоминающий все объекты, входящие в $t$:
$$
	\RContext_t = \left\{ id \mapsto o \;|\; o = \Object{id}{\ldots}{\ldots} \in \Objects{t}\right\}
$$

\begin{Def}[Пред-модель]
Будем называть правильно построенный модельный терм $t$ \emph{пред-моделью в контексте $\RContext_0$}, если контекст $\RContext_0 \cup \RContext_t$ является замкнутым.
\end{Def}

Пред-модель обладает важным свойством: любой объект в ней однозначно определяется своим идентификатором, и любая ссылка указывает на известный объект.

\section{Классы и типы}

!На практике для удобства навигации по моделям и контроля над их корректностью вводятся дополнительные ограничения (в виде системы типов), регулирующие структуру моделей. Сами эти ограничения также записываются в виде моделей...

\begin{Def}[Класс]
\emph{Классом} называется кортеж $\langle abs, id, S, P \rangle$, где 
\begin{enumerate}
\item $abs$ --- признак абстрактного класса, принимает значения $\True$ или $\False$; Если $abs = \False$, класс называется \emph{конкретным}, иначе --- \emph{абстрактным},
\item $id$ --- \emph{идентификатор} класса (имя),
\item $S$ --- множество классов, называемых \emph{предками} данного класса (\emph{суперклассов}),
\item $P$ --- множество пар вида $p : \tau$, где $p$ --- \emph{идентификатор} свойства, а $\tau$ --- \emph{тип} свойства (множество типов определяется ниже).
\end{enumerate}
Множество $P$ не содержит различных пар, в которых совпадают идентификаторы свойств.
\end{Def}

Для удобства, мы будем обозначать конкретный класс $\langle \False, id, S, P \rangle$ через \mbox{$\CClass{id}{S}{P}$}, а абстрактный класс $\langle \True, id, S, P \rangle$ --- через \mbox{$\AClass{id}{S}{P}$}. Когда значения признака абстрактного класса не важно или однозначно определяется из контекста, мы будем использовать обозначение \mbox{$\Class{id}{S}{P}$}.

\begin{Def}
Множество типов $\Types$ описывается следующим образом:
$$
\begin{array}{rrl}
\Types &::=& \CharT \OR \StringT \OR \IntegerT \OR \BooleanT \\
         &|& \NullableT{\Types} 
         \OR \SetT{\Types^+} \OR \SetT{\Types^*}
         \OR \ListT{\Types^+} \OR \ListT{\Types^*}\\
         &|& \ClassT{c} \OR \RefT{c}, \mbox{ где $c$ --- идентификатор некоторого класса} \\
         &|& \AnyT \\
\end{array}
$$
\end{Def}
\noindent Поясним интуитивное значение данного определения:
\begin{itemize}
\item $\CharT$, $\StringT$, $\IntegerT$, $\BooleanT$ обозначают примитивные типы: символы, строки, целые числа и булевские значения соответственно.
\item Тип $\NullableT{\tau}$ допускает значение $\Null$ или значение типа $\tau$, например, $\NullableT{\CharT}$ соответствует множеству значений $\Sigma \cup \{\Null\}$.
\item $\SetT{\tau^*}$ обозначает тип множеств, содержащих ноль или более элементов типа $\tau$. Например, $\SetT{\StringT^*}$ --- 
это множества строк, а $\SetT{\Set{\IntegerT^*}^*}$ --- множества множеств целых чисел. 
\item Аналогично, $\ListT{\tau^*}$ обозначает списки. 
\item Если вместо ``*'' используется ``+'', то множество или список должны содержать не менее одного элемента. Например, $\SetT{\tau^+}$~--- непустые множества, составленные из элементов $\tau$. 
\item $\ClassT{c}$, где $c$ --- некоторый класс (точнее, его идентификатор), соответствует \emph{встраиваемому} объекту класса $c$. Напомним, \emph{встраиванием} называется ситуация, при которой один объект входит в другой как подтерм, например: $\Object{a}{\Ref{c}}{a = \Object{b}{\Ref{c}}{}}$.
\item $\RefT{c}$ обозначает тип ссылок на объекты класса $c$, то есть значений вида $\Ref{a}$, где $a$ --- идентификатор объекта, принадлежащего к классу $c$ (см. ниже).
\item $\AnyT$ (``Top'') --- супертип всех остальных типов (см. ниже).
\end{itemize}

\subsection{Графическая нотация для классов}

Наравне с текстовой, мы будем использовать для классов графическую нотацию, основанную на диаграммах классов языка \tool{UML} (см. \figref{classes}). Класс обозначается прямоугольником, разделенным на две секции: верхняя секция содержит имя класса (\emph{курсивом} в случае абстрактного класса), а нижняя --- его свойства. Как и в случае с объектами, некоторые свойства могут обозначаться ребрами (вместо или одновременно с записью в теле класса), причем имя свойства пишется ближе к концу ребра, причем для обозначения множеств и списков используется нотация, схожая с текстовой: 
\begin{itemize}
\item \texttt{\small\{set*\}} --- обозначает свойство с именем \texttt{\small{}set} и типом $\SetT{\tau^*}$,
\item \texttt{\small[list+]} --- обозначает свойство с именем \texttt{\small{}list} и типом $\ListT{\tau^+}$.
\end{itemize}
\figdef{classes}{Графическая нотация для классов}
\noindent Начало ребра обозначается черным или белым ромбом --- для агрегации ($\ClassT{\tau}$) и ссылок ($\RefT{\tau}$) соответственно. 

Для обозначения отношения ``подкласс-суперкласс'' или \emph{наследования} на диаграммах используются ребра с треугольником на конце, обозначающем суперкласс. Заметим, что циклов по наследованию и агрегации на диаграмме классов быть не должно.

\subsection{Типы как множества значений}

Для типа $\tau$, множество упомянутых в данном типе классов определяется следующим образом:
$$
	\Classes{\tau} = \left\{
	\begin{array}{ll}
		\{c\}, & \tau \in \left\{\ClassT{c}, \RefT{c}\right\}\\
		\Classes{\sigma}, & \tau \in \left\{\ListT{\sigma^+}, \ListT{\sigma^*}, \SetT{\sigma^+}, \SetT{\sigma^*}, \NullableT{\sigma}\right\}\\
		\emptyset, & \mbox{в остальных случаях}\\
	\end{array}
	\right.
$$

Пусть дано множество классов 
$$
C = \{\Class{id_i}{S_i}{p^i_j : \tau^i_j \OR j \in [1;m_i]}\OR i \in [1;n]\},
$$
обозначим $\AllSuperclasses{C} = C \cup \AllSuperclasses{\bigcup_1^n S_i}$ множество всех классов из $C$, их предков, предков их предков и т.д.

Аналогично определяется множество всех свойств класса $c = \Class{id}{S}{p_i : \tau_i}$. Кроме свойств $p_i$, объявленных в самом $c$, рассматриваются также свойства, \emph{унаследованные} из суперклассов:  $\AllProps{C} = \bigcup\limits_{i = 1}^n\{p^i_j : \tau^i_j \OR j \in [1;m_i]\} \cup \AllProps{\AllSuperclasses{C}}$.
Определим также множество всех классов, агрегируемых в $C$: 
$$\begin{array}{ll}
\Aggregated{C} = \left\{C' \OR  \right.&\exists (p : \tau) \in \AllProps{C},\\
&\left.\mbox{где } \tau \in \left\{\ClassT{C'}, \SetT{\ClassT{C'}^+}, \ListT{\ClassT{C'}^+}\right\}
\right\}.
\end{array}$$

\begin{Def}
Конечный набор классов $C$ называется \emph{корректным}, если выполняются следующие свойства:
\begin{enumerate}
\item Все предки классов из $C$ содержатся в $C$: $\AllSuperclasses{C} = C$.
\item Все типы свойств классов из $C$ упоминают только классы из $C$: пусть $\AllProps{C} = \left\{p_i : \tau_i\right\}$, тогда $\bigcup_i \Classes{\tau_i} \subseteq C$.
\item Никакой класс из $C$ не является прямым или непрямым предком самого себя: если $c = \Class{id}{S}{\ldots} \in C$, то $c \notin \AllSuperclasses{S}$.
\item Никакой класс из $C$ прямо или косвенно не агрегируется сам в себе: $c \notin \Aggregated{c}$.
\end{enumerate}
\end{Def}

На типах, порожденных корректным набором классов $C$, вводится отношение ``подтип'' ($\subtype$) --- это наименьшее транзитивное рефлексивное отношение, обладающее следующими свойствами:
$$
\infer[subclass]{
\type{\mbox{TO}}{c} \subtype \type{\mbox{TO}}{s}
}{
	\Class{c}{S}{\ldots} \in C &
	s \in S & 
	\mbox{TO} \in \{\valts,\, \refts\}
}
$$  
Другими словами, подклассы порождают подтипы. Кроме того, 
$$
\infer[option]{
	\tau \subtype \NullableT{\tau}
}{}
\quad
$$
\noindent то есть добавление значения $\Null$ ``расширяет'' тип. Аналогично для списков и множеств:
 $$
\infer[set]{
	\SetT{\tau^\iota} \subtype \SetT{\sigma^\kappa}
}{
	\tau \subtype \sigma &
	\iota, \kappa \in \{+, *\} &
	\iota \le \kappa
}
\quad
\infer[list]{
	\ListT{\tau^\iota} \subtype \ListT{\sigma^\kappa}
}{
	\tau \subtype \sigma &
	\iota, \kappa \in \{+, *\} &
	\iota \le \kappa
}
$$
Здесь отношение порядка на знаках $+$ и $*$ определяется правилом $$+ < *.$$

Классы и типы используются для описания допустимых конфигураций модельных термов. 
Пусть зафиксирован замкнутый ссылочный контекст $\RContext$. 
Ниже мы определим функцию $\denotRCC{\bullet} : \Types \rightarrow 2^{\ModelTerm}$, которая для корректного набора классов $C$ сопоставляет каждому типу множество его значений. Для этого мы сначала введем вспомогательную функцию $\semRC{\bullet} : \Types \rightarrow 2^{\ModelTerm}$, которая возвращает все модельные термы, упомянутые в контексте $\RContext$, принадлежащие к данному типу и ни к какому другому, то есть не согласует отношение ``подтип'' с отношением вложенности множеств. Эта функция задается следующим образом. Типу $\ClassT{c}$ ставится в соответствие множество $\semRC{\ClassT{c}}$ всех объектов из $\Objects{\RContext}$, в которых ссылкой на класс является терм $\Ref{c}$, и имеющих все свойства из множества $\AllProps{c}$ и только их, причем значение каждого свойства имеет тип, указанный для данного свойства в классе:
$$
\infer[objects]{
	\semRC{\ClassT{c}} = \left\{
		\Object{id}{\Ref{c}}{p_i = v_i} \in \Objects{\RContext}
		\,|\,
		v_i \in \denotRCC{\tau_i} 
	\right\}
}{
	\Class{c}{S}{\ldots}&
	\AllProps{c} = \left\{p_1 : \tau_1, \ldots, p_n : \tau_n\right\}
}
$$ 
Другие типы характеризуются следующим образом:
$$
\infer[refs]{
	\semRC{\RefT{c}} = \left\{ \Ref{id} \in \Refs{\RContext} \,|\, \RContext(id) \in \semRC{\ClassT{c}} \right\}
}{
	\Class{c}{S}{\ldots}
}
$$ $$
\infer[set]{
	\semRC{\SetT{\tau^+}} = \left\{ \Set{x_1,\ldots,x_n} \,|\, x_i \in \semRC{\tau}\right\}
}{
}
$$ $$
\infer[list]{
	\semRC{\ListT{\tau^+}} = \left\{ \List{x_1,\ldots,x_n} \,|\, x_i \in \semRC{\tau}\right\}
}{
}
$$ $$
\infer[eset]{
	\semRC{\SetT{\tau^*}} = \semRC{\SetT{\tau^+}} \cup \left\{ \Set{} \right\}
}{}	
\quad
\infer[elist]{
	\semRC{\ListT{\tau^*}} = \semRC{\ListT{\tau^+}} \cup \left\{ \List{} \right\}
}{}	
$$ $$
\infer[null]{
	\semRC{\NullableT{\tau}} = \semRC{\tau} \cup \{\Null\}
}{
}
\quad
\infer[primitive]{
	\sem{\Types_P} = \Types_P
}{
	\Types_P \in \{\IntegerT, \CharT, \StringT, \BooleanT\}
}
\quad
$$

Теперь нам осталось лишь ``склеить'' значения функции $\semRC{\bullet}$ согласно отношению $\subtype$, чтобы получить $\denotRCC{\bullet}$:
$$
\begin{array}{rcl}
	\denotRCC{\tau} &=& \semRC{\tau} \cup \bigcup_{\sigma \subtype \tau} \semRC{\sigma}\\
	\denotRCC{\top} &=& \bigcup\limits_\tau \semRC{\tau}\\
\end{array}	
$$

\begin{Def}
Будем называть объекты, входящие в множество $\denotRCC{\ClassT{c}}$, \emph{экземплярами} класса $c$.
\end{Def}

Мы будем изображать объекты и классы на одной диаграмме, проводя пунктирные ребра от экземпляров к классам. Чтобы не загромождать рисунки, мы будем проводить лишь некоторые такие ребра. Так, например, на \figref{classesandinstances} к объектам с \figref{simplerlambda} добавлены некоторые классы с \figref{classes}.
%
\figdef{classesandinstances}{Классы и их экземпляры}%
%
Обратите внимание не то, что один и тот же объект может являться экземпляром сразу нескольких классов: $\String{t4}$ является экземпляром классов $\String{Usage}$ и $\String{Term}$ одновременно. Заметим, что все экземпляры одного имеют общий набор свойств, описанный в классе: все экземпляры класса $\String{Term}$ разделяют пустой набор свойств, а все экземпляры $\String{Usage}$ --- набор из одного свойства $\String{var}$. Таким образом, классы \emph{регламентируют структуру своих экземпляров}, гарантируя наличие тех или иных свойств у объектов.

\section{Модели и мета-модели}

Выше мы потребовали, чтобы экземпляры класса $C = \Class{c}{S}{P}$, имели вид $\Object{id}{\Ref{c}}{\ldots}$, то есть содержали ссылку на идентификатор класса $c$. Если класс $C$ сам не является объектом, то контекст, в котором упоминаются его экземпляры, не может быть замкнутым. Для того, чтобы устранить это неудобство, мы представим классы в виде объектов и сделаем, таким образом, синтаксис модельных термов замкнутым.

На \figref{metametamodel} приведена диаграмма, охватывающая основные аспекты представления классов в виде объектов: приведены представления класса $\String{Class}$, экземпляры которого обозначают классы, класса $\String{Type}$ --- для типов и $\String{Property}$ --- для свойств. Пунктирные ребра на этой диаграмме проведены не между классами и объектами, а между объектами, представляющими классы, и объектами, являющимися экземплярами этих классов. Также проведено пунктирное ребро между ребром, изображающим одно из значений свойства $\Ref{\String{properties}}$ объекта $\String{Class}$, и объектом описывающим это свойство.
%
\figdef{metametamodel}{Классы как объекты}%
%
Обратите внимание на то, что идентификаторы свойств на этой диаграмме имеют вид $\Ref{x}$, то есть являются ссылками на объекты, описывающие сами свойства. Такое кодирование наиболее удобно, поскольку позволяет, например, узнать тип свойства, просто получив описывающий его объект по идентификатору.

У некоторых объектов на диаграмме \figref{metametamodel} не указаны идентификаторы. Это сделано для краткости: эти идентификаторы нигде не используются, соответственно, единственное, что требуется --- это чтобы они не совпадали ни с какими другими идентификаторами объектов. Поскольку такие несовпадающие идентификаторы всегда можно выбрать, мы можем позволить себе не изображать их на рисунке.

Формальное правило для преобразования объектного представления в классы, описанные выше, записывается довольно длинно и довольно тривиально, поэтому мы не приводим его целиком. Основная идея состоит в том, что объекты вида $\Object{c}{\Ref{\String{Class}}}{p}$ преобразуются в классы вида $\Class{c}{S}{P}$, где $S$, $P$ и признак абстрактности вычисляются из значений соответствующих свойств из $p$.

Представление типов приведено на \figref{types} и \figref{nullableprimitiveenum}.
%
\figdef{types}{Классы для типов (I)}
%
Оно также непосредственно трансформируется в типы, определенные выше.
%
\figdef{nullableprimitiveenum}{Классы для типов (II)}
%

\begin{Def}[Типовый контекст]
Пусть $m$ является пред-моделью в некотором ссылочном контексте $\RContext_0$, и $\RContext = \RContext_0 \cup \RContext_m$. Если по множеству всех экземпляров класса $\String{Class}$, упомянутых в $\RContext$, строится корректный набор классов $C$, то функция 
\begin{equation*}
\TContext_m(t) = \begin{cases}
	\tau, & \mbox{где } t \in \denotRCC{\tau},\\
	\bot, & \mbox{в противном случае},\\
\end{cases}
\end{equation*}
называется \emph{типовым контекстом}, порожденным $m$. Термы $t$ для которых $\TContext_m(t) \neq \bot$, называются \emph{типизируемыми} в контексте $\TContext_m$.
\end{Def}

Основная идея данного определения в том, что ``правильные'' термы являются типизируемыми. В дальнейшем мы будем работать только с такими термами. Введем понятие \emph{модели}, соответствующее замкнутому типизируемому терму:

\begin{Def}[Модель]
Пред-модель $m$, всякий подтерм в которой типизируется в контексте $\TContext_m$, называется \emph{моделью}.
\end{Def}

\begin{Prop}\label{MMM}
Модельные термы, изображенные на \figref{metametamodel}, \figref{types} и \figref{nullableprimitiveenum} является моделью в пустом ссылочном контексте.
\end{Prop}
\begin{proof}
Данное утверждение проверяется непосредственно.
\end{proof}

Данная модель имеет фундаментальное значение, поскольку с ее помощью можно описывать классы, позволяющие типизировать термы в других моделях, поэтому для нее используется специальный термин и обозначение:
\begin{Def}
Модель, изображенная на \figref{metametamodel}, \figref{types} и \figref{nullableprimitiveenum} называется \emph{метаметамоделью} и обозначается $\MMM$.
\end{Def}
Таким образом, утверждение \ref{MMM} можно записать как $$\TContext_\MMM(\MMM) \neq \bot.$$
\SideNote{Вообще-то это надо доказать}

!!!Enums

\begin{figure}[htbp]
	\centering
$$
	\infer[object]{
		\fromMM \Object{id}{\Ref{c}}{p_i = v_i} : \ClassT{c}
	}{
		\Class{c}{S}{P} \in \MM{M}&
		\AllProps{c} = \{p_i : \tau_i\}&
		\fromMM v_i : \tau_i
	}
$$
$$
\infer[ref]{
	\fromMM \Ref{id} : \RefT{c}
}{
	\fromMM \RContext(id) : \ClassT{c}
}
\quad
\infer[null]{
	\fromMM \Null : \NullableT{\tau}
}{}
$$
$$
\infer[elist]{
	\fromMM \List{\,} : \ListT{\tau^*}
}{}
\quad
\infer[list]{
	\fromMM \List{x_1, \ldots, x_n} : \List{\tau^+}
}{
	\fromMM x_i : \tau & \forall i\in[1:n]
}
$$
$$
\infer[eset]{
	\fromMM \Set{\,} : \SetT{\tau^*}
}{}
\quad
\infer[set]{
	\fromMM \Set{x_1, \ldots, x_n} : \SetT{\tau^+}
}{
	\fromMM x_i : \tau & \forall i\in[1:n]
}
$$
$$
\infer[subtype]{
	\fromMM x : \sigma
}{
	\fromMM x : \tau &
	\tau \subtype \sigma
}
$$
$$
\infer[enum]{
	\forall i \in [1:n]. \; \fromMM T.L_i : T
}{
	\mathbf{enum}\;T\{L_1,\ldots,L_n\} \in \MM{M}
}
\quad
\infer[primitive]{
	\fromMM x : \Types_P
}{
	x \in \Types_P & 
	\Types_P \in \{\IntegerT, \CharT, \StringT, \BooleanT\}
}
$$
	\caption{Структурная корректность объектов}\label{TypesMM}
\end{figure}


