\chapter{Автоматическое построение языков, поддерживающих аспекты}

\section{Базовый язык аспектов}
общая мета-модель аспектов

\begin{lstlisting}
class Aspect {
	rules : AspectRule*;
}
class AspectRule {
	pointcut : Application;
	advice : Application;
	subrules : AspectRule*; // scoped by variables?
}
class Wildcard extends Term {
	type : Type;
}
\end{lstlisting}

общий синтаксис
 -- добавить wildcards (во что?):
\begin{lstlisting}
term : '<' '?' n=NAME type? '>'
	instead n : n?;
	after type? : ('=' term)?;
\end{lstlisting}

 -- добавить bindings !!! 
 -- чем отличается variable reference от wildcard
\begin{lstlisting}
aspect : aspectRule*;
aspectRule : 'on' aspectTerm 'perform' substRule* ;
aspectTerm : 
substRule : 'instead' NAME ':' term ;
\end{lstlisting}

специализированная мета-модель образцов (получение из шаблонов)

   Ничего не надо

\section{Алгоритм сопоставления с образцом}

\subsection{Мульти-среды}

Понятие среды, введенное при формализации шаблонов, необходимо расширить для случая аспектов, поскольку в этом случае одной переменной может быть сопоставлено несколько значений, которые являются \term{структурно идентичными} (обозначается $\cong$), то есть либо совпадают, либо являются точными копиями друг друга. Такие структуры будем называть \term{мульти-средами} и обозначать $\ME$.

Основная операция на мульти-средах --- извлечение элемента, она возвращает (возможно, пустое) множество элементов, сопоставленных данной переменной: $\ME(var) = \{e_1,\ldots,e_n\}$.
Для построения мульти-сред будем использовать два конструктора и две операции композиции. Простейшая мульти-среда --- пустая --- обозначается конструктором $\meempty$, при этом $$\forall v :\; \meempty(v) = \emptyset.$$ 
Мульти-среда, сопоставляющая переменной $v$ одно значение $e$ обозначается конструктором $\meitem{v}{e}$, при этом 
$$
\left\{\begin{array}{ll}
\meitem{v}{e}(v) = \{e\}&\\
\meitem{v}{e}(x) = \emptyset, & \mbox{при } x \neq v
\end{array}\right..
$$
Более сложные мульти-среды строятся с помощью операций \term{объединения}  $\mejoin$ и \term{замены} $\mereplace$, заданных следующими правилами: 
$$\left(\ME_1 \mejoin \ME_2\right)(v) = \ME_1(v) \cup \ME_2(v)$$
$$(\ME_1 \mereplace \ME_2)(v) = \left\{\begin{array}{ll}
\ME_2(v), & \mbox{если } \ME_2(v) \neq \bot\\
\ME_1(v), & \mbox{если } \ME_2(v) = \bot\\
\end{array}\right.$$

Специальный элемент $\bot$ не является мульти-средой, но операции композиции доопределяются на нем следующим образом: 
$$\begin{array}{rclcl}
\ME &\mejoin& \bot &=& \bot\\
\bot &\mejoin& \ME &=& \bot\\
\ME &\mereplace& \bot &=& \bot\\
\bot &\mereplace& \ME &=& \bot\\
\end{array}
$$

\term{Уплотнением} мульти-среды $\ME$ называется среда $\meflatten{\ME}$ такая, что $$
\forall v, \, e \in \ME(v): \; \meflatten{\ME}(v) \cong e.
$$
Уплотнение соответствует ``склеиванию'' нескольких значений для каждой переменной в одно, в результате из мульти-среды получается обыкновенная среда.

\subsection{Операция сопоставления с образцом}

\term{Операция сопоставления} объекта $x$ с образцом $P$ в мульти-среде $\ME$ обозначается
$\match[\ME]{e}{P}$ и возвращает мульти-среду $\ME'$ в случае успеха и $\bot$ в случае неудачи. Семантика этой операции представлена на \figref{MatchSem}.

\begin{figure}[htbp]
	\centering

$$
\myinfer[match-var-e]{
	\match[\ME]{x}{\ang{?v}} = \ME \mejoin \meitem{v}{[x]}
}{
	\meflatten{\ME}(v) = [e]
	&
	e \cong x
}
$$	
$$
\myinfer[match-var-P]{
	\match[\ME]{x}{\ang{?v}} = (\match[\ME]{x}{P}) \mereplace \meitem{v}{[x]}
}{
	\meflatten{\ME}(v) = \ang{P}
}
$$	
$$
\myinfer[match-app]{
	\match[\ME]{x}{\ang{T\, a_1,\ldots,a_n}} 
		= \match[
			\ME'
		]{x}{B}
}{
	\mathbf{template}\left(
		T \, \ang{p_1, \ldots, p_n} \, \{ B \}
	\right)
	&
	\ME' = \left(\MEjoin\limits_{i} \meitem{p_i}{\ang{a_i}} \right) 
	           \mejoin \ME
}
$$	
$$
\myinfer[match-wc]{
	\match[\ME]{x}{\ang{? : C}} = \ME
}{
	x = \obj{C}{id}{f_i = v_i}
}
\quad
\myinfer[match-wc-?]{
	\match[\ME]{x}{\ang{? : C^?}} = \ME
}{
	\match[\ME]{x}{\ang{? : C}} = \ME
}
$$
$$
\myinfer[match-null]{
	\match[\ME]{NULL}{\ang{? : C^?}} = \ME
}{
}
$$		
$$
\myinfer[match-ds]{
	\match[\ME]{x}{\obj{\TC{C}}{id'}{f_i = P_i}} 
		= \left(\MEjoin\limits_i \ME_i \right) \mejoin \ME
}{
	x = \obj{C}{id}{f_i = v_i}
	&
	\match[\ME]{v_i}{P_i} = \ME_i
}
$$
$$
\myinfer[match-list]{
	\match[\ME]{x}{P} = matchList_{\ME}(x,\, P)
}{
	x = [x_1, \ldots, x_n]
	&
	P = [P_1, \ldots, P_m]
}
$$
$$
\myinfer[match-set]{
	\match[\ME]{x}{P} = matchSet_{\ME}(x,\, P)
}{
	x = \{x_1, \ldots, x_n\}
	&
	P = \{P_1, \ldots, P_m\}
}
$$
$$
\myinfer[match-prim]{
	\match[\ME]{x}{x} 
		= \ME
}{
	x \mbox{ --- значение примитивного типа}
}
$$
	\caption{Семантика операции сопоставления с образцом}\label{MatchSem}
\end{figure}


Сопоставление переменных и отличи шаблонов в мульти-среде от значений

-- функция возвращает ассоциированный с переменной терм
$$
\begin{array}{c}
\infer[wcard]{
	(\match{x}{\wcard{?var}{\tau}}) = \meitem{var}{x}
}{RTT(x) = \tau}
\\
\infer[var]{
	(\match{x}{?var = P_x}) = \ME_x \mejoin \meitem{var}{x}
}{
\match{x}{P_x} = \ME_x
}
\\
\infer[mvar]{
	(\match{x}{?var}) = \ME \mejoin \meitem{var}{x}
}{
\meflatten{\ME}(?var) \cong x
}
\end{array}
$$

\section{Семантика применения аспектов}

\begin{Def}
\term{Аспектным правилом} (или \term{атомарным аспектом}) называется тройка
$\mathcal{R} = \langle P, T, V \rangle$, где
\begin{itemize}
\item $P$ --- образец (срез), связывающий переменные $v_1,\ldots,v_m$;
\item $T$ --- наиболее конкретный тип элемента, который может быть успешно сопоставлен с $P$;
\item $V$ --- набор \term{правил замены}, то есть кортежей $\langle v_i, t_i \rangle$, где
	\begin{itemize}
		\item $v$ --- переменная;
		\item $t$ --- шаблонное выражение, содержащее ссылки на переменные $v_1,\ldots,v_m$ как на шаблонные параметры.
	\end{itemize}
\end{itemize}
\end{Def}
\newcommand{\rapply}[2]{#1@#2}
\term{Аспект} представляет собой множество аспектных правил. Применение аспекта к грамматике сводится к последовательному применению составляющих его аспектных правил. Каждое правило применяется следующим образом: последовательно перебираются все объекты $e$ типа $T$, представленные в данной грамматике, на каждом из них происходит \term{применение} аспектного правила (обозначается $\rapply{\mathcal{R}}{e}$), определенное ниже.

\newcommand{\subst}[2]{ #1 \mapsto #2 }
\newcommand{\apply}[2]{\left( #1 \right) \triangleright #2}
Для определения применения аспектного правила, нам потребуется операция \term{подстановки}, которая заменяет одни объекты внутри модели другими. Элементарная подстановка заменяет всего один объект и обозначается $\subst{x_1}{x_2}$. Применение подстановки $\sigma$ к модели $m$ обозначается $\apply{\sigma}{m}$ и для элементарного случая $\subst{x_1}{x_2}$ определяется следующим образом: все ссылки на объект $x_1$ заменяются ссылками на $x_2$.
Неэлементарные подстановки строятся с помощью операции \term{композиции}: $\apply{\sigma_1 \sqcup \sigma_2}{m}$ соответствует последовательному применению двух подстановок $\apply{\sigma_2}{\left( \apply{\sigma_1}{m} \right)}$.

\begin{Note}
Композиция подстановок в общем случае не коммутативна, что приводит к проблеме, взаимодействия советов (advice interaction), присущей всем аспектно-ориентированным языкам (см., например, \cite{JAMI}, где эта проблема рассмотрена очень подробно). Ниже мы введем в язык аспектов некоторые расширения, которые позволят в той или иной степени справиться с этой проблемой.
\end{Note}

Теперь определим операцию применения аспектного правила.
Пусть $\match{P}{e} = \ME \neq \bot$, \\$V = \left\{\langle v_i, t_i \rangle \,|\, i = 1..m \right\}$,  $\ME(v_i) = [e^i_1, \ldots, e^i_{n_i}]$, тогда
	$$\mathcal{R}@e
		= \apply{\bigsqcup\limits_{i=1}^{m} \bigsqcup\limits_{j=1}^{n_i}
			\subst{e^i_j}{\Inst{\meflatten{\ME}}{t_i}}}{e}$$
Фактически, результат сопоставления образца преобразуется в подстановку, заменяющую все значения, сопоставленные каждой переменной, результатами разворачивания соответствующих шаблонов, где средой является уплотнение результата сопоставления.

\begin{Note}
Определение аспектного правила, которое мы ввели, непосредственно соответствует советам с ключевым словом \code{instead}, поскольку происходит только замена. Ниже мы покажем, как реализовать два других типа советов.
\end{Note}


\section{Система типов}

Применение подстановки может нарушить структуру модели, например, если объект типа \code{Symbol} (не \code{SymbolReference}) заменяется объектом типа \code{Expression}. Проблема в том, что общий супертип заменяемого и заменяющего объектов не удовлетворяет требованию мета-модели (не является подтипом \code{Symbol}). Для того, чтобы исключить такие случаи, мы используем в аспектных правилах систему типов, основные правила которой приведены на \figref{AspTypes}. Эти правила не описывают процедуры \term{вывода типов} (type inference), то есть написаны в предположении, что для каждой переменной тип указан явно. Вывод типов мы опишем ниже.
\begin{figure}[htbp]
	\centering
$$
\begin{array}{ccc}
	\infer[wcard]{ \vdash \wcard{?v}{\tau} : \tau}{}
	&\quad&
	\infer[vref]{ \vdash ?(v : \tau) : \tau}{}\\
	&&\,\\
	\infer[vdef]{ \vdash ?(v : \tau) = P : \sigma}{
		 \vdash P : \tau & \tau \preceq \sigma	
	}
	&&
	\infer[subtype]{ \vdash e : \sigma}{
		 \vdash e : \tau & \tau \preceq \sigma	
	}\\
	&&\,\\
	\multicolumn{3}{c}{
	\infer[seq]{ \vdash e_1 \, e_2 : \mathtt{Sequence}}{
		 \vdash e_1 : \mathtt{Expression} & 
		 \vdash e_2 : \mathtt{Expression} & 
	}}\\
	&&\,\\
	\multicolumn{3}{c}{
	\infer[sym]{ \vdash (N : e) : \mathtt{Symbol}}{
		 \vdash N : \mathtt{Identifier} & 
		 \vdash e : \mathtt{Expression} & 
	}}\\
	\,\\
	\multicolumn{3}{c}{
	\infer[sym]{ \vdash (N : e) : \mathtt{Symbol}}{
		 \vdash N : \mathtt{Identifier} & 
		 \vdash e : \mathtt{Expression} & 
	}}\\
\end{array}
$$
	\caption{Структурная типизация в образцах}\label{AspTypes}
\end{figure}

Как и ранее, основной интерес представляют правила, связанные с переменными, а остальные --- лишь выражают типы более сложных конструкций через типы более простых. Типизация переменных дополнительно регламентируется правилами, приведенными на \figref{VarTypes}.
\newcommand{\tcomp}{\diamond}
\begin{figure}[htbp]
	\centering
$$
	\infer{\emptyset \tcomp \tau = \tau}{}
	\quad
	\infer{\tau \tcomp \emptyset = \tau}{}
	\quad
	\infer{\tau \tcomp \tau = \tau}{}
$$
$$
	\infer{\wcard{?v}{\tau} \vdash x : \emptyset}{v \neq x}
	\quad
	\infer{?(v : \tau) \vdash x : \emptyset}{v \neq x}
	\quad
	\infer{?(v : \tau) = e \vdash x : \sigma}{v \neq x & e \vdash x : \sigma}
$$
$$
	\infer{\wcard{?v}{\tau} \vdash v : \tau}{}
	\quad
	\infer{?(v : \tau) \vdash v : \tau}{}
	\quad
	\infer{?(v : \tau_2) = e \vdash v : \tau_1 \tcomp \tau_2}{
		e \vdash v : \tau_1 & 
		\tau_1 \tcomp \tau_2 \neq \bot &
		\vdash e : \sigma & \sigma \preceq \tau_2
	}
$$
$$
	\infer[seq]{e_1 \, e_2 \vdash v : \tau_1 \tcomp \tau_2}{
		e_1 \vdash v : \tau_1 & 
		e_2 \vdash v : \tau_2 & 
		\tau_1 \tcomp \tau_2 \neq \bot
	}
$$
$$
	\infer[symbol]{N : e \vdash v : \tau_1 \tcomp \tau_2}{
		N \vdash v : \tau_1 & 
		e \vdash v : \tau_2 & 
		\tau_1 \tcomp \tau_2 \neq \bot
	}
$$
$$
	\infer[ann]{e\{a\} \vdash v : \tau_1 \tcomp \tau_2}{
		e \vdash v : \tau_1 & 
		a \vdash v : \tau_2 & 
		\tau_1 \tcomp \tau_2 \neq \bot
	}
$$
	\caption{Определение типов переменных внутри образца}\label{VarTypes}
\end{figure}
В совокупности эти правила определяют, какие типы могут быть приписаны переменным и как тип переменной определяется внутри выражения. Для нужд описания используется вспомогательная функция объединения типов $\tcomp$, которая обеспечивает поглощение специального ``типа'' $\emptyset$, который приписывается переменным, не известным в данном контексте.

Теперь мы можем выписать правило, ограничивающее соотношение типов переменных в аспектном правиле и сопоставляемых им шаблонов. Для этого нам понадобится определить функцию $\Gamma(p)$, которая по образцу $p$ строит контекст $\Gamma$, соответствующий \figref{TempTypes}. Эта функция определяется так: $\Gamma(p)$ возвращает множество всех утверждений $v : \tau$, таких что переменная $v$ определена внутри $p$, и $p \vdash v : \tau \neq \emptyset$. С использованием этой функции типизация аспектных правил выглядит так:
$$
	\infer[aspect]{
		(\mathbf{instead} \; v \, : \, t) \in Allowed(\mathcal{R})
	}{
		\mathcal{R} = \langle p, T, V \rangle &
		p \vdash v : \tau &
		\Gamma(p) \vdash t : \sigma &
		\sigma \preceq \tau
	}
$$
Здесь $Allowed(\mathcal{R})$ обозначает множество всех пар $\langle v, t\rangle$, которые разрешены к использованию в $V$. Данное правило требует, чтобы тип результата шаблонного выражения (в контексте $\Gamma(p)$) был подтипом типа соответствующей переменной. Поскольку переменную можно заменить на любой объект ее типа, не нарушив структурной корректности, все такие правила допустимы.

\begin{Lemm}
Если $\match{e}{p} \neq \bot$, $\vdash e : \tau$ и $\vdash p : \sigma$, то $\tau \preceq \sigma$.
\end{Lemm}

\begin{Lemm}
Если $\match{e}{p} = \ME \neq \bot$, $e \vdash v : \tau$ и $x \in \ME(v)$, то $\vdash x : \tau$.
\end{Lemm}

\begin{Lemm}
Если $\match{e}{p} = \ME \neq \bot$ и $\Gamma(p) \vdash t : \tau$, то $\vdash \Inst{\meflatten{\ME}}{t} : \tau$.
\end{Lemm}

\begin{Def}
Элементарная подстановка $\subst{x}{y}$ называется \term{безопасной} в мета-модели $\MM{M}$, если в данной мета-модели любая ссылка, которая может указывать на $x$, может указывать также и на $y$.

Неэлементарная подстановка называется безопасной, если она получена композицией безопасных подстановок.
\end{Def}

\begin{Th}
Если $\mathcal{R}$ таково, что $V \subseteq Allowed(\mathcal{R})$, то в результате применения $\mathcal{R}@e$ не нарушаются структурные ограничение, накладываемые мета-моделью.
\end{Th}
\begin{proof}
Согласно определению операции применения, данное утверждение можно переформулировать так: подстановка
$$
\bigsqcup\limits_{i=1}^{m} \bigsqcup\limits_{j=1}^{n_i}
			\subst{e^i_j}{\Inst{\meflatten{\ME}}{t_i}}
$$
является безопасной.
\end{proof}

\subsection{Советы ``до'' и ``после''}

Ключевые слова \code{before} и \code{after} выражаются через замену. Например, вместо ``\code{before v : t}'' можно написать ``\code{instead v : t v}''. Единственное отличие состоит в том, что \code{t} в этом случае обязано иметь тип \code{Expression}, а переменную \code{v} должно быть разрешено заменить на объект типа \code{Sequence}. Этот факт описывается следующим образом:
$$
	\infer[before]{
		(\mathbf{before} \; v \, : \, t) \in Allowed(\mathcal{R})
	}{
		\mathcal{R} = \langle p, T, V \rangle &
		p \vdash v : \tau &
		\Gamma(p) \vdash t : \mathtt{Expression} &
		\mathtt{Sequence} \preceq \tau
	}
$$
Правило для \code{after} абсолютно аналогично.

\subsection{Вывод типов переменных}

Указывать типы переменных, кроме тех, которые определяются в подстановочных знаках, не обязательно, поскольку выражение в правой части определения имеет тип само по себе, и его можно сопоставить переменной автоматически. При этом необходимо помнить, что тип переменной определяет, какими объектами ее можно заменить, поэтому нужно учитывать не только (и не столько) определение переменной, но и контекст, в котором она используется. При этом нас интересует наиболее широкий тип. Например, переменная \code{b}, определенная следующим образом:
\begin{lstlisting}
a ?b='abc' d*
\end{lstlisting}
при определении получает тип \code{Literal}, но ее контекст позволяет использовать любой объект типа \code{Expression}, поэтому именно этот тип должен быть выведен.

Общее правило для вывода типов выглядит следующим образом: переменная получает \term{начальный} тип, соответствующий правой части в ее определении, далее для каждого вхождения этой переменной в образец (включая само определение) рассматривается тип ссылки в мета-модели, по которой переменная связана с объемлющим объектом. Если этот тип шире начального, он устанавливается как текущий. Если текущий тип уже был установлен, то предварительно проверяется чтобы очередной тип не был шире текущего. Такой же метод применяется и для переменных, определенных в подстановочных знаках.

\subsection{Контроль над недетерминированным поведением}

\begin{Def}
Класс $C$ в мета-модели $\MM{M}$ называется \term{допускающим локальную замену}, если в данной мета-модели все ссылки, имеющие типом этот класс и все его подклассы и суперклассы, являются агрегирующими.
\end{Def}
Например, в целевой мета-модели \tool{Grammatic} класс \texttt{Expression} и все его подклассы допускают локальную замену. По сути, это свойство означает, что для замены объекта класса $C$ при подстановке достаточно изменить всего одну ссылку в модели, поскольку всякий объект может одновременно указывать не более одной агрегирующей ссылки.

\begin{Def}
Подстановки $\subst{x}{y}$ и $\subst{z}{w}$ называются \term{совместимыми}, если $y$ и $z$ --- разные объекты и $x$ и $w$ --- разные объекты.

Композиция совместимых подстановок называется \term{правильной}.
\end{Def}

\begin{Lemm}
Пусть класс $C$ допускает локальную замену, тогда для любого объекта $x$ этого класса, безопасной подстановки $\subst{x}{y}$ и совместимой с ней безопасной подстановкой $\sigma$, операция композиции допускает перемену мест аргументов:
$$
	\subst{x}{y} \sqcup \sigma \equiv \sigma \sqcup \subst{x}{y} 
$$
\end{Lemm}
\begin{proof}
Введем обозначения:
$$\alpha := \subst{x}{y} \sqcup \sigma$$
$$\beta := \sigma \sqcup \subst{x}{y}$$
Две подстановки эквивалентны, если их применение к одной и той же модели всегда дает один и тот же результат. Пусть модель $m$ не содержит $x$, тогда
$$\apply{\alpha}{m} = \apply{\beta}{m} = \apply{\sigma}{m},$$
поскольку из-за требования совместимости $\sigma$ не может добавить $x$ в модель.
Если $m$ содержит $x$, то на него есть не более одной ссылки, то есть объекты, которые появляются после подстановок, не имеют ссылок на $x$. Следовательно, результат обеих подстановок будет одинаков.
\end{proof}

\begin{Lemm}
Все элементарные подстановки, составляющие 
$$
\bigsqcup\limits_{i=1}^{m} \bigsqcup\limits_{j=1}^{n_i}
			\subst{e^i_j}{\Inst{\meflatten{\ME}}{t_i}}
$$
попарно совместимы.
\end{Lemm}
\begin{proof}
Результат применения шаблона всегда является новым объектом и, следовательно, не может совпадать ни с одним из объектов в левой части подстановок.
\end{proof}

\begin{Th}
Результат применения аспектного правила, оперирующего только объектами классов допускающих локальную замену, не зависит от порядка объединения элементарных подстановок.
\end{Th}
\begin{proof}
Утверждение теоремы следует из двух предыдущих лемм.
\end{proof}

Аспектные правила применяются в порядке следования в аспекте.

Если происходит замена переменной, тип которой допускает неоднозначность, выдается предупреждение.

Дополнительный контроль во время выполнения: множественность сопоставления. 

// Расширить
