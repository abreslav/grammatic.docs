\chapter{Автоматическое построение языков, поддерживающих аспекты}

В настоящем разделе описан метод расширения языков механизмом композиции на основе аспектов. Данный метод базируется на методе построения языков шаблонов, описанном выше.

\section{Базовый язык аспектов}

Основные понятия языка аспектов двойственны понятиям языка шаблонов.
Шаблонное выражение соответствует образцу (используется класс \code{Term}), но, в отличие от случая шаблонов, вместо того, чтобы подставлять значения вместо переменных, требуется решать обратную задачу: найти значения переменных, при которых результат разворачивания данного шаблона будет структурно эквивалентен данному объекту. 

Напомним, что в образцах переменные связываются с выражениями. Так в \GRM{} можно записать \code{'x' ?e=(?a='z' ';')}, и переменной \code{e} будут сопоставляться последовательности вида ``\code{'z' ';'}'', при этом символ \code{'z'} будет сопоставлен переменной \code{a}. При использовании шаблонных выражений это достигается за счет использования применений шаблонов. Данный пример соответствует выражению \code{<T1  <T2 'z'{>}>}, где шаблоны \code{T1} и \code{T2} определены следующим образом:
\begin{lstlisting}
template T1 <e> { 'x' <?e> }
template T2 <a> { <?a> ';'}
\end{lstlisting}

За счет такой аналогии, для аспектов удается использовать тот же способ расширения мета-модели, что и в случае шаблонов, а также соответствующую систему типов. Дополнительно в базовую мета-модель вводятся классы для аспекта и аспектного правила, сопоставляющего одному срезу набор советов (см. \figref{AspectMM}). Кроме того, базовый набор шаблонных выражений пополняется классом \code{Wildcard}, представляющим подстановочные знаки, которым нет аналога в языке шаблонов.

\begin{lstlisting}[label=AspectMM,float=htbp,caption=Классы базовой мета-модели языка аспектов]
class Aspect {
	rules : AspectRule*;
}
class AspectRule {
	pointcut : Term;
	advice : Map<Variable, Term>;
}
class Wildcard extends Term {
	type : Type;
}
\end{lstlisting}
//	subrules : AspectRule*; // scoped by variables?

Конкретный синтаксис строится следующим образом: к синтаксису шаблонов добавляются конструкции для описания срезов (нетерминальный символ \code{aspectTerm}):
\begin{lstlisting}[language=Grammatic]
aspectTerm 
	: genericAspectTerm
	: <?domainSpecificTerm> ;
genericAspectTerm
	: aspectVariable type? '=' aspectTerm // Определение переменной
	: aspectVariable                      // Ссылка на переменную
	: '<' '?' type '>' ;                  // Подстановочный знак
aspectVariable : '?' NAME;
\end{lstlisting}
\begin{itemize}
\item Определение переменной имеет форму \code{?имя : Тип = выражение}, где указание типа можно опустить.
\item Ссылка на переменную имеет форму \code{?имя}.
\item Подстановочный знак имеет форму \code{<? : Тип>}.
\end{itemize}
Кроме того, добавляются конструкции для описания аспектных правил:
\begin{lstlisting}
aspect : aspectRule*;
aspectRule : 'on' aspectTerm 'perform' substRule* ;
substRule : 'instead' NAME ':' term ;
\end{lstlisting}
``Операторные скобки'' \code{on...perform} введены для того, чтобы избежать синтаксической неоднозначности, возникновение которой весьма вероятно в данном случае. Это, безусловно, не гарантирует отсутствия неоднозначности, поэтому, как и в случае шаблонов, конкретные синтаксические конструкции могут требовать ручной доработки. Смысл аспектного правила таков: если образец между \code{on} и \code{perform} успешно сопоставляется с объектом в модели, то все советы \code{instead} применяются следующим образом: значения переменной в левой части заменяются результатом разворачивания шаблонного выражения в правой. Шаблонное выражение может содержать ссылки на переменные, связанные в образце.

Дополнительная генерация специализированных конструкций в случае аспектов не требуется: они уже сгенерированы при добавлении шаблонов.

\section{Семантика сопоставления с образцом}

Семантика языка аспектов описывается двумя алгоритмами: сопоставления с образцом описано в данном подразделе, а применение аспектного правила --- в следующем.

\subsection{Мульти-среды}

Понятие среды, введенное при формализации шаблонов, необходимо расширить для случая аспектов, поскольку в этом случае одной переменной может быть сопоставлено несколько значений, которые являются \term{структурно идентичными} (обозначается $\cong$), то есть либо совпадают, либо являются точными копиями друг друга. Такие структуры будем называть \term{мульти-средами} и обозначать $\ME$.

Основная операция на мульти-средах --- извлечение элемента, она возвращает (возможно, пустое) множество элементов, сопоставленных данной переменной: $\ME(var) = \{e_1,\ldots,e_n\}$.
Для построения мульти-сред будем использовать два конструктора и две операции композиции. Простейшая мульти-среда --- пустая --- обозначается конструктором $\meempty$, при этом $$\forall v :\; \meempty(v) = \emptyset.$$ 
Мульти-среда, сопоставляющая переменной $v$ одно значение $e$ обозначается конструктором $\meitem{v}{e}$, при этом 
$$
\left\{\begin{array}{ll}
\meitem{v}{e}(v) = \{e\}&\\
\meitem{v}{e}(x) = \emptyset, & \mbox{при } x \neq v
\end{array}\right..
$$
Более сложные мульти-среды строятся с помощью операций \term{объединения}  $\mejoin$ и \term{замены} $\mereplace$, заданных следующими правилами: 
$$\left(\ME_1 \mejoin \ME_2\right)(v) = \ME_1(v) \cup \ME_2(v)$$
$$(\ME_1 \mereplace \ME_2)(v) = \left\{\begin{array}{ll}
\ME_2(v), & \mbox{если } \ME_2(v) \neq \bot\\
\ME_1(v), & \mbox{если } \ME_2(v) = \bot\\
\end{array}\right.$$

Специальный элемент $\bot$ не является мульти-средой, но операции композиции доопределяются на нем следующим образом: 
$$\begin{array}{rclcl}
\ME &\mejoin& \bot &=& \bot\\
\bot &\mejoin& \ME &=& \bot\\
\ME &\mereplace& \bot &=& \bot\\
\bot &\mereplace& \ME &=& \bot\\
\end{array}
$$

\term{Уплотнением} мульти-среды $\ME$ называется среда $\meflatten{\ME}$ такая, что $$
\forall v, \, e \in \ME(v): \; \meflatten{\ME}(v) \cong e.
$$
Уплотнение соответствует ``склеиванию'' нескольких значений для каждой переменной в одно, в результате из мульти-среды получается обыкновенная среда.

\subsection{Операция сопоставления с образцом}

\term{Операция сопоставления} объекта $x$ с образцом $P$ в мульти-среде $\ME$ обозначается
$\match[\ME]{e}{P}$ и возвращает мульти-среду $\ME'$ в случае успеха и $\bot$ в случае неудачи. Семантика этой операции представлена на \figref{MatchSem}.

\begin{figure}[htbp]
	\centering

$$
\myinfer[match-var-e]{
	\match[\ME]{x}{\ang{?v}} = \ME \mejoin \meitem{v}{[x]}
}{
	\meflatten{\ME}(v) = [e]
	&
	e \cong x
}
$$	
$$
\myinfer[match-var-P]{
	\match[\ME]{x}{\ang{?v}} = (\match[\ME]{x}{P}) \mereplace \meitem{v}{[x]}
}{
	\meflatten{\ME}(v) = \ang{P}
}
$$	
$$
\myinfer[match-app]{
	\match[\ME]{x}{\ang{T\, a_1,\ldots,a_n}} 
		= \match[
			\ME'
		]{x}{B}
}{
	\mathbf{template}\left(
		T \, \ang{p_1, \ldots, p_n} \, \{ B \}
	\right)
	&
	\ME' = \left(\MEjoin\limits_{i} \meitem{p_i}{\ang{a_i}} \right) 
	           \mejoin \ME
}
$$	
$$
\myinfer[match-wc]{
	\match[\ME]{x}{\ang{? : C}} = \ME
}{
	x = \obj{C}{id}{f_i = v_i}
}
\quad
\myinfer[match-wc-?]{
	\match[\ME]{x}{\ang{? : C^?}} = \ME
}{
	\match[\ME]{x}{\ang{? : C}} = \ME
}
$$
$$
\myinfer[match-null]{
	\match[\ME]{NULL}{\ang{? : C^?}} = \ME
}{
}
$$		
$$
\myinfer[match-ds]{
	\match[\ME]{x}{\obj{\TC{C}}{id'}{f_i = P_i}} 
		= \left(\MEjoin\limits_i \ME_i \right) \mejoin \ME
}{
	x = \obj{C}{id}{f_i = v_i}
	&
	\match[\ME]{v_i}{P_i} = \ME_i
}
$$
$$
\myinfer[match-list]{
	\match[\ME]{x}{P} = \matchList{\ME}{x}{P}
}{
	x = [x_1, \ldots, x_n]
	&
	P = [P_1, \ldots, P_m]
}
$$
$$
\myinfer[match-set]{
	\match[\ME]{x}{P} = \matchSet{\ME}{x}{P}
}{
	x = \{x_1, \ldots, x_n\}
	&
	P = \{P_1, \ldots, P_m\}
}
$$
$$
\myinfer[match-prim]{
	\match[\ME]{x}{x} 
		= \ME
}{
	x \mbox{ --- значение примитивного типа}
}
$$
	\caption{Семантика операции сопоставления с образцом}\label{MatchSem}
\end{figure}

Согласно правилам \rref{match-var-e}, \rref{match-var-е} и \rref{match-app} мульти-среда может хранить два вида значений: первоначально в нее помещается образец, соответствующий данной переменной (обозначается $\ang{P}$), а когда этот шаблон применяется первый раз, значение заменяется соответствующим объектом (обозначается $[e]$). В дальнейшем мульти-среда пополняется объектами, структурно эквивалентными данному.

Задача сопоставления с образцом хорошо изучена. В частности известно, что она NP-полна, если в образцах разрешается использовать переменные и ассоциативно-коммутативные операции (в нашем случае таким операциям эквивалентны неупорядоченные коллекции, то есть множества) \cite{???}. Таким образом, алгоритм сопоставления имеет экспоненциальную трудоемкость, однако, как показала практика использования \GRM{}, на практике образцы, для которых сопоставление работает долго, не встречаются. Для полноты изложения мы приводим ниже краткое описание операции сопоставления для списков и множеств.

Основная вычислительная сложность операции сопоставления лежит в алгоритмах $\matchList{\ME}{x}{P}$ и $\matchSet{\ME}{x}{P}$. Функция $\matchList{\ME}{x}{P}$ использует перебор с возвратами для того, чтобы корректно обрабатывать подстановочные знаки кратности ``+'' и ``*''. 
Обнаруживая такой подстановочный знак, функция $\matchList{}{}{}$ ``пробует'' сопоставить ему 0, 1, 2 и т. д. элементов списка, вызывая себя рекурсивно на оставшихся данных. Если одно из сопоставлений прошло успешно, перебор заканчивается. 

Идея алгоритма достаточно проста, и чтобы не загромождать текст деталями, мы приводим только его схематичное описание для случая непустых списков. Наше описание не полностью учитывает обработку переменных: мы рассматриваем только случай, когда очередной элемент образца является подстановочным знаком, но он может являться ссылкой на переменную, которой сопоставлен подстановочный знак. В этом случае необходимо запомнить, что в случае удачного сопоставления в мульти-среду нужно записать соответствующее значение для данной переменной. Этот технический момент не меняет сути алгоритма, поэтому он не отражен в следующем псевдокоде, описывающим основные шаги алгоритма сопоставления списков:

%\begin{algorithm}[htbp]
\begin{algorithmic}
\STATE $(x_h : x_t) \gets x$ \COMMENT{$x_h$ --- голова списка, $x_t$ --- остальные элементы}
\STATE $(P_h : P_t) \gets P$
\IF {$P_h$ --- подстановочный знак кратности $m \in \{+,*\}$}
	\STATE $n_0 \gets \left\{\begin{array}{ll}
			1,&\mbox{если }m = +\\
			0,&\mbox{если }m = *\\
			\end{array}\right.$
	\FORALL{$n \gets n_0$ до $length(x)$}
		\STATE $tail \gets$ список $x$, кроме первых $n$ элементов
		\STATE $\ME' \gets \matchList{\ME}{tail}{P_t}$
		\IF{$\ME' \neq \bot$}
			\RETURN $\ME'$
		\ENDIF
	\ENDFOR
	\RETURN $\bot$
\ELSE
	\STATE $\ME' = \match[\ME]{x_h}{P_h}$
	\RETURN{$\matchList{\ME'}{x_t}{P_t}$}
\ENDIF
\end{algorithmic}
%\end{algorithm}

Функция $\matchSet{\ME}{x}{P}$ несколько сложнее, поскольку порядок сопоставления не зафиксирован, а из-за наличия переменных его нельзя взять произвольными: от того, какая переменная будет сопоставлена первой, может зависеть, удастся ли найти значения для остальных. Задача сопоставления в этом случае сводится к перебору максимальных паросочетаний в двудольном графе \cite{Cormen}. Граф $G$ строится следующим образом: одну долю образуют элементы множества $x$, другую --- $P$, элементы $x_i$ и $P_j$ соединены ребром, если $\matchNV[\ME]{x_i}{P_j} \neq \bot$. Операция $\matchNV{}{}$ игнорирует переменные, подставляя на их место соответствующие им образцы. Общая схема дальнейшей работы такова: если максимальное паросочетание связывает все элементы множества $x$, то есть шанс, что, перебирая такие паросочетания (их может быть несколько), и выполняя сопоставление согласно ребрам в них, мы найдем значения для всех переменных. Это отражено в следующем псевдокоде:
%
\newcommand{\matchM}[2]{\mathsf{matchM}(#1,\, #2)}%
%
\begin{algorithmic}
%\STATE \textbf{function} $\matchSet{\ME}{x}{P}$
\STATE $M_0 \gets$ максимальное паросочетание в $G$
\IF {$|M_0| < |x|$}
	\RETURN $\bot$
\ENDIF
\FORALL {$M \gets$ максимальное паросочетание в $G$}
	\STATE\COMMENT{Попытка сопоставления согласно $M$}
	\STATE $\ME' \gets \ME$
	\STATE\COMMENT{Перебор ребер в паросочетании}
	\FORALL {$(x_i, P_j) \gets M$} 
		\STATE $\ME' \gets \match[\ME']{x_i}{P_j}$
	\ENDFOR
	\IF {$\ME' \neq \bot$} 
		\RETURN $\ME'$ \COMMENT{Cопоставление удачно}
	\ENDIF
\ENDFOR
\RETURN $\bot$
\end{algorithmic}



\section{Семантика применения аспектов}

\begin{Def}
\term{Аспектным правилом} (или \term{атомарным аспектом}) называется тройка
$\mathcal{R} = \langle P, T, V \rangle$, где
\begin{itemize}
\item $P$ --- образец (срез), связывающий переменные $v_1,\ldots,v_m$ и не имеющий свободных переменных;
\item $T$ --- наиболее конкретный тип элемента, который может быть успешно сопоставлен с $P$, то есть тип $P$ (см. \figref{TempTypes});
\item $V$ --- набор \term{правил замены}, то есть кортежей $\langle v_i, t_i \rangle$, где
	\begin{itemize}
		\item $v_i$ --- переменная;
		\item $t_i$ --- шаблонное выражение, содержащее ссылки на переменные $v_1,\ldots,v_m$ как на шаблонные параметры.
	\end{itemize}
\end{itemize}
\end{Def}
\newcommand{\rapply}[2]{#1@#2}
\term{Аспект} представляет собой множество аспектных правил. Применение аспекта к грамматике сводится к последовательному применению составляющих его аспектных правил. Каждое правило применяется следующим образом: последовательно перебираются все объекты $e$ типа $T$, представленные в данной грамматике, на каждом из них происходит \term{применение} аспектного правила (обозначается $\rapply{\mathcal{R}}{e}$), определенное ниже.

\newcommand{\subst}[2]{ #1 \mapsto #2 }
\newcommand{\apply}[2]{\left( #1 \right) \triangleright #2}
Для определения применения аспектного правила, нам потребуется операция \term{подстановки}, которая заменяет одни объекты внутри модели другими. Элементарная подстановка заменяет всего один объект и обозначается $\subst{x_1}{x_2}$. Применение подстановки $\sigma$ к модели $m$ обозначается $\apply{\sigma}{m}$ и для элементарного случая $\subst{x_1}{x_2}$ определяется следующим образом: все ссылки на объект $x_1$ заменяются ссылками на $x_2$.
Неэлементарные подстановки строятся с помощью операции \term{композиции}: $\apply{\sigma_1 \sqcup \sigma_2}{m}$ соответствует последовательному применению двух подстановок $\apply{\sigma_2}{\left( \apply{\sigma_1}{m} \right)}$.

\begin{Note}
Композиция подстановок в общем случае не коммутативна, что приводит к проблеме, взаимодействия советов (advice interaction), присущей всем аспектно-ориентированным языкам (см., например, \cite{JAMI}, где эта проблема рассмотрена очень подробно). Ниже мы введем в язык аспектов некоторые расширения, которые позволят в той или иной степени справиться с этой проблемой.
\end{Note}

Теперь определим операцию применения аспектного правила.
Пусть $\match{P}{e} = \ME \neq \bot$, \\$V = \left\{\langle v_i, t_i \rangle \,|\, i = 1..m \right\}$,  $\ME(v_i) = [e^i_1, \ldots, e^i_{n_i}]$, тогда
	$$\mathcal{R}@e
		= \apply{\bigsqcup\limits_{i=1}^{m} \bigsqcup\limits_{j=1}^{n_i}
			\subst{e^i_j}{\Inst{\meflatten{\ME}}{t_i}}}{e}$$
Фактически, результат сопоставления образца преобразуется в подстановку, заменяющую все значения, сопоставленные каждой переменной, результатами разворачивания соответствующих шаблонов, где средой является уплотнение результата сопоставления.

\begin{Note}
Определение аспектного правила, которое мы ввели, непосредственно соответствует советам с ключевым словом \code{instead}, поскольку происходит только замена. Ниже мы покажем, как реализовать два другие типы советов.
\end{Note}


\section{Система типов}

Применение подстановки может нарушить структуру модели, например, тип заменяющего объекта не удовлетворяет требованиям мета-модели для некоторой ссылки на заменяемый объект. Для того, чтобы исключить такие случаи, для аспектных правилах используется система типов, базирующаяся на системе типов для шаблонов, приведенной на \figref{TempTypes}.  Подстановочные знаки, которые не учитываются правилами \figref{TempTypes}, типизируются следующим образом:
$$
	\myinfer[wcard]{ \vdash \wcard{?}{\tau} : \tau}{}
$$

Теперь мы можем выписать правило, ограничивающее соотношение типов переменных в аспектном правиле и сопоставляемых им шаблонов. Для этого нам понадобится определить функцию $\Gamma(p)$, которая по образцу $p$ строит контекст $\Gamma$, соответствующий \figref{TempTypes}. Эта функция определяется так: $\Gamma(p)$ возвращает множество всех параметров шаблонов, использованных внутри $p$, вместе с их типами $(v : \tau)$. С использованием этой функции типизация аспектных правил выглядит так:
$$
	\myinfer[aspect]{
		(\mathbf{instead} \; \ang{?v} \, : \, t) \in Allowed(\mathcal{R})
	}{
		\mathcal{R} = \langle p, T, V \rangle &
		\Gamma(p) \vdash v : \tau &
		\Gamma(p) \vdash t : \sigma &
		\sigma \preceq \tau
	}
$$
Здесь $Allowed(\mathcal{R})$ обозначает множество всех советов, которые разрешены к использованию в $V$. Данное правило требует, чтобы тип результата шаблонного выражения (в контексте $\Gamma(p)$) был подтипом типа соответствующей переменной. Поскольку переменную можно заменить любым объектом того же типа, не нарушив структурной корректности, все такие правила допустимы.

\begin{Lemm}
Если $\match{e}{p} \neq \bot$, $\fromMM e : \tau$ и $\vdash p : \rho$, то $\tau \preceq \rho$.
\end{Lemm}
\begin{proof}
Для доказательства необходимо рассмотреть случаи для возможных значений $\rho$ и показать, что сопоставление может быть успешным только если $\tau$ является подтипом $\rho$. Здесь мы рассмотрим только случай $\rho = C$ в качестве примера.

Последним в дереве вывода $\vdash p : C$ может быть одно из следующих правил:

\hspace{1cm}\parbox{.85\textwidth}{
\begin{itemize}
\item[\rref{ds-type(C)}] --- при сопоставлении применялось правило \rref{match-ds}, следовательно $\fromMM e : C$, а $C \subtype C$;
\item[\rref{wc}] --- применялось правило \rref{match-wc}, рассуждения аналогичны предыдущему случаю;
\item[\rref{subtype}] --- задача сводится к аналогичной при $\sigma \subtype C$, по транзитивности $\subtype$ утверждение леммы верно;
\item[\rref{appl}] --- этому правилу предшествует правило \rref{abstr}, требующее, чтобы тело шаблона $b$ имело тип $\sigma$, то есть задача сводится к аналогичному доказательству утверждения для выражения $b$;
\item[\rref{var}] --- если при сопоставлении применялось правило \rref{match-var-P}, то тип $P$ может быть только подтипом $C$, а если \rref{match-var-e}, то $e \cong e'$, где для сопоставления $e'$ применялось правило \rref{match-var-P}.
\end{itemize}}
В остальных случаях доказательство аналогично.
\end{proof}

\begin{Lemm}
Если $\match{e}{p} = \ME \neq \bot$, $\Gamma(e) \vdash v : \tau$ и $x \in \ME(v)$, то $\fromMM x : \tau$.
\end{Lemm}
\begin{proof}
Значения переменных помещаются в $\ME$ в правилах \rref{match-var-P} и \rref{match-var-e}. В первом случае корректность типа значения следует из предыдущей леммы, так как по правилу \rref{appl} $P$ будет корректно типизрован. Во втором случае результат $x \cong e$, где для $e$ применялось правило \rref{match-var-P}.
\end{proof}

\begin{Lemm}
Если $\match{e}{p} = \ME \neq \bot$ и $\Gamma(p) \vdash t : \tau$, то $\fromMM \Inst{\meflatten{\ME}}{t} : \tau$.
\end{Lemm}
\begin{proof}
Из предыдущей леммы следует, что среда $\meflatten{\ME}$ согласована с контекстом $\Gamma(p)$; отсюда по теореме \ref{ThTP} о сохранении типов, теореме \ref{ThNorm} о нормализации и лемме \ref{LemmNF} о нормальных формах следует утверждение данной леммы.
\end{proof}

\begin{Def}
Элементарная подстановка $\subst{x}{y}$ называется \term{безопасной} в мета-модели $\MM{M}$, если в данной мета-модели любая ссылка, которая может указывать на $x$, может указывать также и на $y$.

Неэлементарная подстановка называется безопасной, если она получена композицией безопасных подстановок.
\end{Def}

\begin{Th}
Если $\mathcal{R}$ таково, что $V \subseteq Allowed(\mathcal{R})$, то в результате применения $\mathcal{R}@e$ не нарушаются структурные ограничение, накладываемые мета-моделью.
\end{Th}
\begin{proof}
Согласно определению операции применения, данное утверждение можно переформулировать так: подстановка
$$
\bigsqcup\limits_{i=1}^{m} \bigsqcup\limits_{j=1}^{n_i}
			\subst{e^i_j}{\Inst{\meflatten{\ME}}{t_i}}
$$
является безопасной. Данное утверждение следует из трех предыдущих лемм.
\end{proof}

\subsection{Контроль над недетерминированным поведением}

\begin{Def}
Класс $C$ в мета-модели $\MM{M}$ называется \term{допускающим локальную замену}, если в данной мета-модели все ссылки, имеющие типом этот класс и все его подклассы и суперклассы, являются агрегирующими.
\end{Def}
Например, в целевой мета-модели \tool{Grammatic} класс \texttt{Expression} и все его подклассы допускают локальную замену. По сути, это свойство означает, что для замены объекта класса $C$ при подстановке достаточно изменить всего одну ссылку в модели, поскольку всякий объект может одновременно указывать не более одной агрегирующей ссылки.

\begin{Def}
Подстановки $\subst{x}{y}$ и $\subst{z}{w}$ называются \term{совместимыми}, если $y$ и $z$ --- разные объекты и $x$ и $w$ --- разные объекты.

Композиция совместимых подстановок называется \term{правильной}.
\end{Def}

\begin{Lemm}
Пусть класс $C$ допускает локальную замену, тогда для любого объекта $x$ этого класса, безопасной подстановки $\subst{x}{y}$ и совместимой с ней безопасной подстановкой $\sigma$, операция композиции допускает перемену мест аргументов:
$$
	\subst{x}{y} \sqcup \sigma \equiv \sigma \sqcup \subst{x}{y} 
$$
\end{Lemm}
\begin{proof}
Введем обозначения:
$$\alpha := \subst{x}{y} \sqcup \sigma$$
$$\beta := \sigma \sqcup \subst{x}{y}$$
Две подстановки эквивалентны, если их применение к одной и той же модели всегда дает один и тот же результат. Пусть модель $m$ не содержит $x$, тогда
$$\apply{\alpha}{m} = \apply{\beta}{m} = \apply{\sigma}{m},$$
поскольку из-за требования совместимости $\sigma$ не может добавить $x$ в модель.
Если $m$ содержит $x$, то на него есть не более одной ссылки, то есть объекты, которые появляются после подстановок, не имеют ссылок на $x$. Следовательно, результат обеих подстановок будет одинаков.
\end{proof}

\begin{Lemm}
Все элементарные подстановки, составляющие 
$$
\bigsqcup\limits_{i=1}^{m} \bigsqcup\limits_{j=1}^{n_i}
			\subst{e^i_j}{\Inst{\meflatten{\ME}}{t_i}}
$$
попарно совместимы.
\end{Lemm}
\begin{proof}
Результат применения шаблона всегда является новым объектом и, следовательно, не может совпадать ни с одним из объектов в левой части подстановок.
\end{proof}

\begin{Th}
Результат применения аспектного правила, оперирующего только объектами классов допускающих локальную замену, не зависит от порядка объединения элементарных подстановок.
\end{Th}
\begin{proof}
Утверждение теоремы следует из двух предыдущих лемм.
\end{proof}

Аспектные правила применяются в порядке следования в аспекте.

Если происходит замена переменной, тип которой допускает неоднозначность, выдается предупреждение.

Дополнительный контроль во время выполнения: множественность сопоставления. 

// Расширить
