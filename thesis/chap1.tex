\part{Предварительные сведения об инженерии компьютерных языков}\label{part1}

В настоящей главе приводится обзор современного состояния инженерии языков. Основное внимание уделяется средствам разработки трансляторов и механизмам композиции.

%\input{chap1metamodeling.tex}

\chapter{Предметно-ориентированные языки}

Одновременно с мета-моделированием развивается концепция \term{предметно-ориентированных языков (ПОЯ)} (Domain-Specific Languages, DSLs \cite{StateMachine}). В рамках этой концепции утверждается, что во многих предметных областях существуют типичные задачи, для решения которых целесообразно разрабатывать специализированные языки, позволяющие легко выразить специфичные для данной области понятия. ПОЯ противопоставляются \term{языкам общего назначения} (General-Purpose Languages, GPLs), таким, например, как популярные языки программирования (\tool{C}, \tool{C++}, \tool{Java}, \tool{C\#} и т.д.). Задачи, специфичные для данной области, можно решать и с помощью языков общего назначения, но при таком подходе решения получаются гораздо большими по объему и содержат много однотипного кода, который не всегда возможно выделить в библиотеку. Кроме того, поскольку ПОЯ оперируют понятиями предметной области, они становятся более доступными для понимания экспертами в этой области, не имеющими навыков программирования, что облегчает процесс общения с заказчиком и позволяет снизить затраты.

В качестве примеров ПОЯ можно привести
\begin{enumerate}
\item издательскую систему \TeX ;
\item язык разметки \tool{HTML};
\item языки, используемые в конфигурационных файлах, например, для веб-сервера \tool{Apache};
\item язык для вывода графики \tool{PostScript};
\item язык описания графов \tool{GraphViz};
\item нотация EBNF для описания контекстно-свободных грамматик;
\item структурированный язык запросов для реляционных баз данных \tool{SQL};
\item и многие другие.
\end{enumerate}

Некоторые ПОЯ, например \TeX , являются универсальными в том смысле, что с их помощью можно описать любое вычисление, однако они спроектированы так, что с их помощью легко решать задачи в соответствующей предметной области, а описывать другие вычисления --- гораздо сложнее (как правило сложнее, чем на языках общего назначения).

\input{chap1language.tex}

%\input{chap1grammartools.tex}
	
\chapter{Автоматизация разработки механизмов композиции}

Из предыдущего раздела видно, что предметно-ориентированные языки (в данном случае --- языки, предназначенные для описания текстового синтаксиса) нуждаются в инфраструктурной функциональности, обеспечивающей композицию, не меньше, чем языки общего назначения. В данном разделе мы рассмотрим инструменты, позволяющие в той или иной степени автоматизировать разработку такой функциональности для предметно-ориентированных языков.

\section{Анализ идентификаторов}

Идентификация элементов является тривиальной задачей для средств разработки графического синтаксиса, поскольку они хранят элементы моделей как объекты в памяти, и могут использовать естественную индивидуальность (identity \cite{OOAD}) этих объектов для идентификации. При сохранении на диск в формате XMI \cite{XMI} также существует стандартизированный механизм идентификации, но получающееся таким образом текстовое представлением неудобно для чтения человеком. Ситуация не облегчается и стандартной нотацией HUTN \cite{HUTN}, поскольку ее синтаксис достаточно громоздок и не очень далек от XMI.

При разработке текстового синтаксиса анализ идентификаторов является третьим этапом создания транслятора \cite{DragonBook}, после лексического и синтаксического анализа. В простых случаях этот механизм легко реализуется с помощью таблицы символов, более сложные случаи требуют усложненных структур данных. Дополнительные трудности накладывает наличие различных пространств имен (например, когда множество имен функций может пересекаться с множеством имен переменных, потому что из синтаксиса всегда ясно, идет ли речь о переменной или о функции) и вложение этих областей. Основанный на атрибутной трансляции инструмент \tool{Eli} \cite{Eli} предоставляет обширную библиотеку для реализации различных вариаций механизма разрешения идентификаторов, но использование этой библиотеки по-прежнему требует написания достаточно большого объема кода.

Генераторы сред разработки, такие как \tool{xText} \cite{xText} и \tool{TCS} \cite{TCS} автоматизируют разрешение имен в простых случаях. \tool{TCS} позволяет определять вложенные области видимости и непересекающиеся пространства имен с помощью специальных директив внутри грамматического определения. 

\section{Механизмы простого цитирования}

Как отмечалось выше, самым простым механизмом композиции являются модули, не использующие параметризацию. Этот механизм позволяет объединять элементы, имеющие идентификаторы, в группы, называемые \term{модулями}. Такой модуль может быть \term{подключен} в некоторой области видимости (как правило в другом модуле), что позволяет использовать объявленные в нем элементы в этой области видимости.

Ряд инструментов, автоматизирующих разработку языков, позволяет добавлять поддержку модулей достаточно легко. Так, инструменты, опирающиеся на графический или псевдотекстовый синтаксис \cite{EMF, Fujaba, MPS} используют для реализации модулей ссылки между моделями, поддерживаемые мета-мета-моделями, использующими XMI \cite{XMI} (например, MOF или \tool{Ecore}), что не требует от разработчика описывать модули дополнительно. Вместе с тем, такая реализация модулей достаточно примитивна, например, она не позволяет вводить \term{атрибуты доступа}, то есть разделять элементы модуля на внутренние (private) и внешние (public).

Для языков с текстовым синтаксисом поддержка модулей реализуется несколько сложнее. Так упоминавшийся выше инструмент \tool{Eli} \cite{Eli} предоставляет библиотеку для реализации нескольких вариантов этого механизма, однако ее использование требует написания большого количества кода. Гораздо более простая реализация имеется в \tool{xText} \cite{xText}: этот инструмент предоставляет ``текстовую оболочку'' для механизма ссылок между моделями, реализованного в \tool{Ecore}, а именно распознает специальное имя атрибута (\code{importURI}) и интерпретирует его как однородный идентификатор ресурса (Uniform Resource Identifier, URI \cite{uri}), который автоматически загружается в текущую область видимости. Как следует из сказанного выше, такой механизм не имеет автоматической поддержки для атрибутов доступа.

Инструменты, позволяющие более полную автоматизацию поддержки модулей, нам не известны, однако ниже мы рассматриваем системы, частично автоматизирующие поддержку шаблонов. Поскольку модули, как мы видели выше, легко представить в виде шаблонов без параметров, можно считать, что средства описания шаблонов поддерживают также и модули.

\section{Шаблоны и макроопределения}

Автоматически шаблоны или макроопределения поддерживают только внутренние (internal) ПОЯ, определенные в языках с поддержкой соответствующих конструкций, таких как \tool{Lisp} или \tool{MacroML}.

Для самостоятельных языков поддержку шаблонов автоматизируют инструменты \tool{COMPOST} \cite{COMPOST} и \tool{Reuseware} \cite{Reuseware}. Последний является развитием первого, поэтому здесь мы опишем только его возможности.
 
Принцип, на котором основывается \tool{Reuseware} его авторы называют инвазивной композицией ПО (Invasive Software Composition, ISC \cite{ISC}). Это методология, определенная для моделей и КС-грамматик, базирующаяся на введение в структуру языка дополнительных элементов, так называемых \term{точек изменения} (variation points), которые подразделяются на следующие типы:
\begin{itemize}
\item \emph{slot} --- помечает выражение в языке для последующей замены, аналогично параметру шаблона со значением по умолчанию \cite{C++};
\item \emph{hook} --- помечает позицию для вставки элементов (возможно, многих), аналогично простому шаблонному параметру;
\item \emph{anchor} --- помечает выражение идентификатором, на который в дальнейшем можно сослаться при описании композиции (см. ниже).
\end{itemize}

Предложения, содержащие точки изменения, называются \term{фрагментами} (Component Fragment). Располагая набором фрагментов, разработчик может описывать их \term{композицию} с помощью специального языка, который определен в инструментах \tool{Reuseware} и имеет графический синтаксис. Композиция заключается в соединении элементов типа \emph{anchor} с элементами двух других типов, причем при присоединении к элементу типа \emph{slot} происходит замена его содержимого, а в случае элемента типа \emph{hook} --- дополнение.

Важной особенностью механизма ISC является тот факт, что он контролирует структурную корректность результата: точки изменения имеют типы (соответствующие классам в мета-модели или нетерминалам в грамматике), и соединение точек с несовместимыми типами запрещено семантикой языка описания композиции, что позволяет гарантировать, что результат не нарушает требований, наложенных целевой мета-моделью. Как мы увидим ниже, те же принципы можно использовать для автоматизированной реализации поддержки аспектов.

Недостатком такого подхода является тот факт, что он \term{незамкнут}: для того, чтобы использовать ``шаблоны'', определенные таким образом, нужно привлекать дополнительный язык, зависящий в свою очередь от инструментов \tool{Reuseware}, то есть расширенная версия исходного языка теряет самостоятельность. Кроме того, способ организации точек изменения гораздо менее локален по сравнению с традиционными шаблонами: ``телом шаблона является вся программа'', что затрудняет инкапсуляцию и делает весь подход менее интуитивным, поскольку теряется аналогия шаблонов с функциями, вычисляемыми во время компиляции \cite{MacroML}.

\section{Аспекты}

Разработку поддержки аспектов в той или иной мере автоматизируют несколько инструментов и методологий. Мы начнем с применения инструментария \tool{Reuseware}, рассмотренного в предыдущем разделе.

Система фрагментов и точек изменения может быть рассмотрена как ``заготовка'' для аспектной композиции. Обеспечить полное \term{незнание} (см. ???) не удается, поскольку точки изменения отмечаются явно, но некоторая степень незнания все же достигается за счет использования внешнего языка композиции. \term{Квантификацию} позволяет обеспечить механизм \term{запросов} (fragment queries), позволяющий коротко описывать множества точек изменения. Этот механизм выполняет функцию срезов. Поиск точек изменения осуществляется по фрагменту имени и типу.  Достоинства этого подхода --- в его универсальности, а недостатки применительно к данной задаче --- в первую очередь, в отсутствии незнания.

Альтернативный подход представлен в работе \cite{VanWyk03}, которая основана на атрибутной трансляции и переписывании. AST, созданное в процессе разбора программы может быть переписано в соответствии с декларативно заданными правилами. При этом поддерживается с \term{перенаправление} атрибутов (forwarding). Идея перенаправления состоит в том, что атрибут элемента AST может быть вычислен путем обращения к атрибуту элемента, полученного в результате переписывания исходного. В такой среде аспекты реализуются следующим образом: срез является предикатом, который определяет применимость того или иного совета для каждого элемента AST (в рамках данного подхода срезы реализуются как функции высшего порядка, написанные на языке Haskell), советы добавляются в код посредством создания новых правил переписывания, а перенаправление позволяет распространить семантические проверки на добавленный таким образом код. Преимуществом этого подхода является возможность добавить аспекты в любой язык независимо от других расширений, причем гарантируется сохранение корректности статических проверок. Основным недостатком является необходимость написания срезов на языке общего назначения, что, как и в случае \tool{Reuseware} делает систему незамкнутой.

Работа \cite{Bagge06} описывает метод, основанный на использовании системы \tool{Stratego/XT} \cite{Stratego/XT} --- широко известного инструмента для трансформации программ, основанного на \emph{стратегическом программировании} (strategic programming), представляющем собой объединение возможностей логического программирования и переписывания термов. Основная идея состоит в том, чтобы описывать применение аспектов как трансформации, во многом аналогично работе \cite{VanWyk03}. В данном случае авторы предлагают вручную реализовать и синтаксис, и семантику аспектов, демонстрируя, что это достаточно легко сделать, располагая инструментами \tool{Stratego/XT} и реализацией самого исходного языка. Строго говоря, эта работа описывает не технологию автоматизации, а метод ручной разработки.

Мы отмечали отсутствие поддержки срезов как недостаток описанных выше подходов. Методология автоматизированного построения системы срезов (но не остальных необходимых элементов аспектного языка) описана в работе \cite{XCPL}. Авторы предлагают использовать ``универсальный'' язык срезов \tool{XCPL}, позволяющий выразить очень широкий класс предикатов над программными конструкциями. Этот язык предлагается сокращать по мере надобности для описания срезов для каждого конкретного языка, при этом необходимо каждый раз разрабатывать конкретный синтаксис сокращенного языка. Семантика \tool{XCPL} также не фиксирована, а должна быть реализована вручную при каждом применении. Таким образом, \tool{XCPL} является просто мета-моделью, позволяющей описывать срезы, и не автоматизирует по-настоящему их разработку.

Необходимо отметить, что существует обширная литература, касающаяся реализации аспектов с точки зрения сред времени выполнения (см., например, \cite{JAMI}). Поскольку мы рассматриваем инфраструктурную функциональность языков, которая по природе своей реализуется во время компиляции, а не во время выполнения, рассмотрение этих работ выходит за пределы нашего обсуждения.
	POPART
	XAspects --- встраивание аспектных языков в AspectJ	
	JAMI --- общий рантайм для DSAL
	
\section{Выводы}

Приведенный обзор средств автоматизации разработки механизмов композиции показывает, что на данный момент ни один из рассмотренных подходов не позволяет автоматически реализовать в замкнутой форме шаблоны, а также аспекты с полной поддержкой квантификации и незнания.

\chapter{Постановка задачи}

Целью данной работы является создание технологии автоматизации разработки языков, поддерживающих автоматизированную реализацию сложных механизмов композиции, а именно
\begin{itemize}
\item шаблонов в замкнутой форме, конструирующих и принимающих в качестве параметров любые элементы языка, и обеспечивающих структурную корректность результатов;
\item аспектов в замкнутой форме, поддерживающие незнание и квантификацию (срезы), и обеспечивающих структурную корректность результатов.
\end{itemize}

Для достижения поставленной цели необходимо детально изучить механизмы композиции, указанные выше и их взаимодействие с другими частями языкового процессора. Для этого создан инструмент автоматизации разработки текстового синтаксиса \tool{Grammatic}, поддерживающий данные механизмы композиции, которые были реализованные вручную. Приемы, примененные при реализации \tool{Grammatic} обобщены для произвольные языки, что позволяет получить требуемую технологию.

Будем:
	- Разрабатывать язык для грамматик, чтобы понять чего и как
	- Обобщим то, что там наработаем
	- Найдем удобный способ описания языков
		- для графики
		- для текста
	- Научимся конвертировать ядро в инфраструктуру