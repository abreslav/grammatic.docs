\part{Предварительные сведения об инженерии компьютерных языков}\label{part1}

// Какие-то вводные слова

\chapter{Мета-моделирование}

К настоящему моменту широкое распространение получили \term{объектно-ориентированные модели программного обеспечения} (Object-Oriented Software Models, \cite{OOSM}) и \term{мета-моделирование} (Meta-Modeling, \cite{MM}). Этот подход используется для проектирования, документирования и автоматического построения ПО. Он получил признание благодаря UML, унифицированному языку моделирования (Unified Modeling Language, \cite{UML}) и MDA, архитектуре, управляемой моделями (Model-Driven Architecture, \cite{MDA}).
Позднее возникли и другие языки и технологии, опирающиеся на те же принципы (MDD, MDE, MOF, ...).

В данном разделе мы приводим основные определения и примеры, необходимые для понимания концепции мета-моделирования. 

\section{Модели}

Одним из центральных понятий в данной области является ``объектно-ориентированная модель''.  Также говорят ``модель предметной области'' или просто ``модель''. Под моделью понимается структурированное описание некоторой сущности реального мира (например, программной или аппаратной системы, инфраструктуры предприятия и т.д.). С формальной точки зрения модель представляет собой граф, вершинами в котором являются типизированные объекты, обладающие типизированными атрибутами \cite{KM3}. Естественным визуальным представлением моделей являются \term{диаграммы}; в качестве примера рассмотрим простую диаграмму модели зависимостей между компонентами ПО (\figref{DiagramExample}).

\begin{figure}[htbp]
// Диаграмма: модель билда с зависимостями
\caption{Модель зависимостей между компонентами ПО}\label{DiagramExample}
\end{figure}

Вершины графа на \figref{DiagramExample} соответствуют компонентам, а ребра --- зависимостям. Каждое ребро направлено от зависимой компоненты (\term{клиента}) к компоненте, от которой она зависит (к \term{серверу}). Таким образом, данная модель состоит из трех объектов, ссылающихся друг на друга. Аналогично объектно-ориентированным языкам программирования \cite{Java}, каждый объект имеет тип, определяемый его классом. В данном случае все три объекта относятся к одному классу \code{Component} (см. \figref{ComponentClass}). 

\begin{figure}[htbp]
// Код, UML-диаграмма и диаграмма объектов для класса Component
class Component {
	attr name : String;
	ref dependsOn : Component[*];
}
\caption{Мета-модель для компонент}\label{ComponentClass}
\end{figure}

На \figref{ComponentClass} (a) приведен псевдокод объявления класса Component. Данный класс декларирует \term{атрибут} \code{name} \term{примитивного типа} \code{String}, значение которого на диаграмме отображается внутри вершины, и \term{ссылку} \code{dependsOn} типа \code{Component}, значения которой на диаграмме отображаются в виде ребер между объектами типа \code{Component}. Поскольку одна компонента может зависеть от нескольких других компонент, ссылка \code{dependsOn} является \term{множественной}, что определяется аннотацией в квадратных скобках (``*'' соответствует кратности (multiplicity) ``ноль или более'').

Во многих объектно-ориентированных языках программирования (\tool{Java}, \tool{C\#}, \tool{SmallTalk} \cite{???}) классы являются также и объектами. В нашем случае мы можем описать класс \code{Component} как модель. Как видно из \figref{ComponentClass} (b), эта модель состоит из следующих объектов: 
\begin{enumerate}
\item самого класса \code{Component};
\item атрибута \code{name};
\item ссылки \code{dependsOn};
\item типа \code{String}.
\end{enumerate}
Все объекты имеют имена, а ссылка \code{dependsOn} -- еще и кратность.
Ребра на диаграмме подписаны в соответствии со связями, которые они отображают: класс владеет атрибутами и ссылками, атрибуты и ссылки имеют типы. 

Одну и ту же модель можно изображать с помощью диаграмм по-разному, так на \figref{ComponentClass} (c) показана та же самая модель для класса Component, отображенная в виде стандартной диаграммы классов языка UML \cite{???}. Как видно из рисунка, эта диаграмма является более компактной за счет того, что атрибут отображаются внутри вершины, соответствующей классу, который ими владеет, а ссылки --- в виде ребер, направленных от класса, который владеет ссылкой, к классу, являющемуся типом ссылки (в UML ссылки моделируются с помощью \term{ассоциаций}, обладающих гораздо более выразительной семантикой, и в частности, позволяющих выразить отношения произвольной арности \cite{???}). Этот пример является очень полезным, поскольку позволяет увидеть, что объект, имеющийся в модели (ссылка), может быть изображен на диаграмме в виде ребра.

\section{Мета-модели и иерархия мета-уровней}

Модель, изображенная на \figref{ComponentClass} описывает типы элементов модели, изображенной на \figref{DiagramExample}, то есть является для нее \term{мета-моделью}. Каждый элемент на диаграмме \figref{ComponentClass} имеет соответствующий элемент в мета-модели (\term{мета-элемент}), и называется его \term{экземпляром}. Отношение ``экземпляр-мета-элемент'' проиллюстрировано на \figref{ConformsToRelation}.

\begin{figure}[htbp]
\caption{Отношение ``экземпляр-мета-элемент''}\label{ConformsToRelation}
\end{figure}

Поскольку в любой модели все объекты типизированы, каждая модель имеет мета-модель  (то есть любая модель является экземпляром некоторой мета-модели). Говорят об ``иерархии мета-уровней'', которые схематически изображены на \figref{ConformsToRelation}  и помечены как $M^1$, $M^2$, $M^3$\ldots Модели уровня $M^{i+1}$ являются мета-моделями для моделей уровня $M^i$. В принципе, иерархия мета-уровней может быть сколь угодно высокой или даже бесконечной, но для практических целей обычно используется иерархия из трех уровней. Это достигается за счет эффекта ``раскрутки'' (bootstrapping, см. \cite{Wirth}): на уровне $M^3$ помещается ровно одна мета-модель, которая типизирует сама себя. Такая модель называется \term{мета-мета-моделью}, именно мета-мета-модели обычно составляют основу модельно-ориентированных инструментов разработки и стандартов, таких как MOF \cite{MOF}, KM3 \cite{KM3}, VPM \cite{VPM} или \tool{Ecore} \cite{EMF}. Большинство используемых на практике мета-мета-моделей эквивалентны по выразительности, то есть существуют автоматизированные средства преобразования между их экземплярами (см. напр. \cite{KM3}). Здесь и далее мы будем использовать мета-мета-модель \tool{Ecore}, которая лежит в основе библиотеки EMF (Eclipse Modeling Framework, \cite{EMF}) и хорошо зарекомендовала себя в качестве платформа для разработки приложений с использованием моделей.

\section{Мета-мета-модель \tool{Ecore}}

\begin{figure}[htbp]
\caption{Мета-мета-модель \tool{Ecore}}\label{Ecore}
\end{figure}

На \figref{Ecore} изображена диаграмма мета-мета-модели \tool{Ecore}. Согласно объектно-ориентированной парадигме, центральным понятием в \tool{Ecore} является класс. Экземпляры \tool{Ecore} (то есть мета-модели) представляют собой наборы классов, организованные в пакеты и связанные отношением ``общее-частное'', аналогичным наследованию в объектно-ориентированных языках программирования \cite{OOP}. На \figref{ComponentClassEcore} показано, как элементы мета-модели, описывающей модели зависимостей между компонентами (такие как \figref{DiagramExample}) связаны с соответствующими мета-элементами в \tool{Ecore}.

Следует обратить внимание на то, что \tool{Ecore} сама состоит из классов, что и позволяет ``оборвать'' иерархию мета-уровней, не используя $M^4$ (в действительности, иерархия не обрывается, просто все уровни, начиная с $M^3$ совпадают между собой и содержат только мета-мета-модель, то есть в нашем случае --- \tool{Ecore}).

В этом разделе мы опишем несколько основных концепций, используемых \tool{Ecore} (и другими мета-мета-моделями), которые будут использованы при изложении дальнейшего материала.

\paragraph*{Классы.} Как мы уже отмечали выше, основными элементами мета-моделей, описанных с помощью \tool{Ecore}, являются классы. Каждый класс имеет имя уникальное в пределах пакета, список суперклассов и список структурных элементов, атрибутов и ссылок. Экземпляры классов хранят значения для всех атрибутов и ссылок, объявленных самим классом и всеми его суперклассами (что соответствует наследованию членов классов в объектно-ориентированных языках). Класс может быть помечен как абстрактный. Такой класс не может иметь непосредственных экземпляров, экземпляры могут иметь только его подклассы, не являющиеся абстрактными.

Заметим, что понятие абстрактного класса в \tool{Ecore} является чисто номинальным, никаких технических препятствий к созданию экземпляра класса (таких как, например в \tool{Java} или \tool{C++}) быть не может, поскольку \tool{Ecore} не определяет тела методов. 

\paragraph*{Примитивные типы и перечисления.} Классы --- не единственное средство типизации в \tool{Ecore}, кроме них используются примитивные типы данных (Data Types) и перечисления (Enums). Примитивный тип данных представляет собой именованную сущность, семантика которой либо не фиксируется, либо определяется тем языком программирования, на котором реализовано моделируемое ПО (в случае \tool{Ecore} это \tool{Java}). 

\tool{Ecore} определяет несколько встроенных типов данных, таких как строки, целые и вещественные числа и т. д.

Перечисления --- это типы имеющие конечное множество значений (литералов).

\paragraph*{Структурные элементы классов: атрибуты и ссылки.} Основное отличие классов и примитивных типов данных --- в их назначении. Классы являются типами объектов, из которых состоят модели, а примитивные типы и перечисления --- типами значений атрибутов этих объектов. Таким образом, ссылки, определяемые классами могут иметь в качестве типа только класс, а атрибуты --- только примитивный тип или перечисление.

В остальном ссылки и атрибуты очень похожи. И те, и другие имеют имя и кратность, которая задается как пара чисел, определяющих нижнюю и верхнюю границу для количества значений, хранимых атрибутом или ссылкой. Так, например, ссылка \code{dependsOn} на \figref{DiagramExample} имеет кратность ``от 0 до $\infty$'', что означает, что компонента может зависеть от нуля или более других компонент. Атрибут \code{name} на том же рисунке имеет кратность ``от 1 до 1'', что означает, что каждая компонента должна иметь имя, причем ровно одно.

Как атрибуты, так и ссылки могут быть помечены как ``упорядоченные''. Этот флаг имеет значение для множественных ссылок и атрибутов (верхняя граница кратности которых больше единицы), и означает, что порядок объектов, на которые указывают ссылки (или значений атрибута) важен. Например, в классе \code{Block}, описывающего блок кода в программе и имеющего ссылку \code{statements}, указывающую на последовательность предложений внутри блока, ссылка \code{statements} должна быть упорядоченной, поскольку нам важно знать, в каком порядке выполнять предложения, из которых состоит блок.

\paragraph*{Перекрестные ссылки и агрегация.} Ссылки в \tool{Ecore} подразделяются на два вида: \term{перекрестные} и \term{агрегирующие}. Различие состоит в том, что на один объект не может быть более одной агрегирующей ссылки, то есть объект, имеющий агрегирующую ссылку, ``владеет'' объектом, на который ссылается. Для перекрестных ссылок таких ограничений нет, на любой объект может быть сколько угодно перекрестных ссылок.

Таким образом, если рассматривать модель как граф, ребрами в котором являются ссылки, то любой цикл обязан проходить хотя бы по одной перекрестной ссылке, а агрегирующие ссылки в модели определяют остовный лес \cite{???}.

Явное выделение агрегирующих ссылок позволяет легко представлять модели в древовидной форме, как показано на \figref{ModelTree}.

\begin{figure}[htbp]
\caption{Представление модели в древовидной форме}\label{ModelTree}
\end{figure}

\paragraph*{Параметризованные типы.} Поскольку \tool{Ecore} развивается на платформе \tool{Java}, с выходом \tool{Java} 5 в мета-мета-модель были добавлены \term{обобщенные типы} (generic types, \cite{Generics, GJ}). Любой класс или тип данных может иметь параметры, которые могут служить типами для структурных элементов.

\chapter{Предметно-ориентированные языки}

Одновременно с мета-моделированием развивается концепция \term{предметно-ориентированных языков (ПОЯ)} (Domain-Specific Languages, DSLs \cite{DSLs}). В рамках этой концепции утверждается, что во многих предметных областях существуют типичные задачи, для решения которых целесообразно разрабатывать специализированные языки, позволяющие легко выразить специфичные для данной области понятия. ПОЯ противопоставляются \term{языкам общего назначения} (General-Purpose Languages, GPLs), таким, например, как популярные языки программирования (\tool{C}, \tool{C++}, \tool{Java}, \tool{C\#} и т.д.). Задачи, специфичные для данной области, можно решать и с помощью языков общего назначения, но при таком подходе решения получаются гораздо большими по объему и содержат много однотипного кода, который не всегда возможно выделить в библиотеку. Кроме того, поскольку ПОЯ оперируют понятиями предметной области, они становятся более доступными для понимания экспертами в этой области, не имеющими навыков программирования, что облегчает процесс общения с заказчиком и позволяет снизить затраты.

В качестве примеров ПОЯ можно привести
\begin{enumerate}
\item издательскую систему \TeX ;
\item язык разметки \tool{HTML};
\item языки, используемые в конфигурационных файлах, например, для веб-сервера \tool{Apache};
\item язык для вывода графики \tool{PostScript};
\item язык описания графов \tool{GraphViz};
\item нотация EBNF для описания контекстно-свободных грамматик;
\item структурированный язык запросов для реляционных баз данных \tool{SQL};
\item и многие другие.
\end{enumerate}

Некоторые ПОЯ, например \TeX , являются универсальными в том смысле, что с их помощью можно описать любое вычисление, однако они спроектированы так, что с их помощью легко решать задачи в соответствующей предметной области, а описывать другие вычисления --- гораздо сложнее (как правило сложнее, чем на языках общего назначения).

\input{chap1language.tex}

\chapter{Инструменты для автоматизации разработки текстовых языков}

В данном разделе мы рассматриваем существующие инструменты, автоматизирующие разработку языков. В основном, эти инструменты ориентированы на разработку предметно-ориентированных языков, поскольку такие языки необходимо разрабатывать часто, что делает затраты на реализацию даже элементарных возможностей таких языков часто повторяющимися, в результате чего возникает необходимость в максимальном сокращении таких затрат.

В первую очередь нас интересует, насколько существующие подходы позволяют автоматизировать поддержку механизмов композиции, описанных выше, однако мы будем также отмечать и другие особенности этих подходов, в частности, поддержку механизмов композиции в языках, используемых самими инструментами.

\ignore{
\section{Контекстно-свободные грамматики}

--- Описание грамматик
	BNF
	EBNF (шаблоны)
	
	КСГ
	продукция 
	правило 
	правая часть 
	символ 
	терминал 
	нетерминал

	индуцированная алгебра термов
	частичный тип

\section{Атрибутная трансляция}

определения
JustAdd, ITD в нем

	атрибут
	семантическое действие

\section{Синтаксически-управляемая трансляция}

недостаток АТ

определение СУТ, L-атрибутные определения

Генераторы на основе СУТ
	Yacc/Bison и компания
		LALR, только синтез. аттр
	ANTLR
		LL, и те, и те
		
	внедренные семантические действия
}				
\section{Внутренние ПОЯ}

Часто ПОЯ разделяют на \term{внешние} (external) и \term{внутренние} (internal) \cite{???}. Внешними называют языки, имеющие специальные средства обработки, например, транслятор, написанные именно для данного ПОЯ. Внутренние языки, напротив, не имеют специальных средств обработки: они ``встраиваются'' в языки общего назначения, как библиотеки или расширения другого рода. В принципе, любой прикладной программный интерфейс (Application Programing Interface, API) можно рассматривать как внутренний ПОЯ: функции API выполняют роль ``ключевых слов'' внутреннего языка. Как правило, о внутренних языках говорят, если соответствующий язык общего назначения позволяет обращаться к библиотекам, используя достаточно гибкие синтаксические конструкции.

// Пример про fluent interfaces

Популярными языками для встраивания ПОЯ являются, например, \tool{Groovy} \cite{???}, \tool{Haskell} \cite{???}, \tool{Scala} \cite{???} и \tool{Java} \cite{???}. Существуют языки, имеющие специальные механизмы для расширения синтаксиса, позволяющие очень удобно интегрировать внутренние языки, например, \tool{Nemerle} \cite{???} и \tool{PLOT} \cite{???}.
		
\section{Модульность грамматических определений}

Как ни странно, далеко не все популярные инструменты поддерживают повторное использование грамматических определений, например, \tool{Bison} \cite{???}, \tool{CoCo/R} \cite{???} и \tool{JavaCC} \cite{???} не поддерживают никаких механизмов такого рода. Это связано в первую очередь с тем, что грамматические определения ``двумерны'': они содержат как описание синтаксической структуры (продукции КСГ), так и описание вычислений (семантические действия), что затрудняет композицию. Кроме того, специальные классы грамматик (например, $LL(k)$) не замкнуты относительно объединения, что накладывает дополнительные трудности на композицию \cite{???}. Так или иначе, инженерная дисциплина при разработке трансляторов находится на гораздо более низком уровне, чем при разработке других видов ПО \cite{Grammarware}.

В данном разделе мы рассмотрим механизмы повторного использования грамматических определений, основанные на цитировании, то есть модули и шаблоны. Аспектно-ориентированная композиция грамматик рассматривается в следующем разделе.

\subsection{Модули и ограничение видимости} В работе \cite{SysProg-2006} приведен обзор наиболее популярных средств для разработки трансляторов и выполнено сравнение по нескольким критериям, одним из которых является повторное использование.

Простейшая реализация модулей представлена в инструментах \tool{Elkhound} \cite{???} и \tool{ANTLR} версии 3 \cite{???}, который поддерживает директиву \code{include} для подключения определение из других файлов. 

Несколько иной подход использован в генераторе \tool{Menhir} \cite{???}, который, принимая на вход несколько файлов, просто ``склеивает'' их содержимое вместе, но позволяет контролировать, какие символы являются открытыми (public) и могут быть использованы в других файлах, а какие --- нет. Закрытые (private) символы автоматически переименовываются для того, чтобы избежать коллизий. Особенность идеи ``склеивания'' файлов состоит в отсутствии директивы цитирования (\code{include} или \code{import}), что облегчает реализацию механизма, но делает зависимости между модулями \emph{невидимыми}: читая отдельный файл, трудно понять, какие из упоминаемых символов определены в других модулях, а главное --- нет никакой возможности определить, в каких именно модулях они определены.

Более традиционным образом модули организованы в системе \tool{ASF+SDF} \cite{???}: аналогично подходу, принятому в языках программирования, каждый модуль имеет имя, соответствующее имени файла, в котором он определен, элементы, объявленные в модуле, делятся на открытые (\code{exports}) и закрытые (\code{hidden}), причем другие модули могут использовать только открытые элементы, что обеспечивает инкапсуляцию. Директива цитирования \code{import} позволяет подключать модули друг к другу. При импортировании может оказаться, что символ, объявленный в одном модуле имеет то же имя, что и символ объявленный в другом. Как мы видели выше, в некоторых языках эта проблема решается с помощью квалифицированных имен (среди инструментов разработки трансляторов такого подхода придерживается \tool{Rats!} \cite{???}); в \tool{ASF+SDF} используется другой подход: директива цитирования позволяет при необходимости \term{переименовать} символ, импортируемый из данного модуля, например:

\begin{lstlisting}
module example/Example

imports library/Lib[ A => B ]
\end{lstlisting}

Теперь внутри модуля \code{example/Example} символ \code{A}, определенный в \code{library/Lib} будет иметь имя \code{B}.

\subsection{Наследование в грамматических определениях}
% Compiler generation based on grammar inheritance
Идея \term{наследования грамматик} была впервые предложена в работе \cite{???}, и основывается на том, что грамматика может наследоваться от другой грамматики, добавляя новые правила и переопределяя старые. Первоначальная реализация была выполнена на языке \tool{Smalltalk} для рабочей станции \tool{Sun 3}, и не получила широкого распространения, однако в дальнейшем наследование грамматик было реализовано в других инструментах.

В \tool{ANTLR} версии 2 \cite{???} наследование грамматик является единственным механизмом их повторного использования. Грамматика может быть унаследована от не более, чем одной родительской грамматики, при этом возможно переопределение правил, а именно: изменение семантических действий (при сохранении синтаксической структуры),  добавление новых альтернатив к существующим правилам. Кроме переопределения, также можно определять и совершенно новые правила (которые могут ссылаться на символы, определенные в родительской грамматике). К недостаткам такого подхода к повторному использованию можно отнести тот факт, что наследование является одиночным, и у разработчика нет возможности использовать несколько независимых модулей при разработке одного языка. Создатели \tool{ANTLR} 2 в качестве основного сценария использования наследования грамматик указывали создание нескольких диалектов одного языка\cite{???}.
% http://www.antlr2.org/doc/inheritance.html

Множественное наследование атрибутных грамматик предложено в работе \cite{???} и реализовано в инструменте \tool{LISA}. %http://portal.acm.org/citation.cfm?id=606666.606678
Авторы уделили больше внимание повторному использованию семантических действий, но и синтаксическая структура может быть унаследована, дополнена и частично переопределена.
Важным дополнением к наследованию грамматик в \tool{LISA} являются \term{шаблоны}.

В некоторых объектно-ориентированных языках (таких, например, как \tool{Scala} \cite{???}) альтернативой наследованию является ``подмешивание'' (mixins). Похожий механизм для грамматик реализует инструмент \tool{xText} \cite{???}. Результирующий механизм близок к множественному наследованию грамматик, но более строго и просто определяет поведение системы в случае ``ромбовидного наследования'' \cite{???}. Mixin в \tool{xText} может добавлять новые правила или продукции, а также переопределять существующие.

Единственным известным нам инструментом, позволяющим не только добавлять, но и удалять продукции, является \tool{Rats!} \cite{???}. Этот инструмент не используем явным образом метафору наследования для грамматик: авторы говорят лишь о ``модификации импортируемых модулей'', однако функциональность, реализованная этой операцией схожа с тем, что в других инструментах достигается с помощью наследования грамматик: есть возможность добавить продукцию, заменить или даже удалить ее.


\paragraph*{Параметризованные определения (шаблоны).}
Идею использования шаблонов (макроопределений для продукций или правил) при описании формальных грамматик легко проиллюстрировать на следующем примере: в синтаксисе языков программирования очень часто встречаются списки --- последовательности элементов (например, имен переменных), разделенных специальным символом (например, запятой). Элементы и разделители разнятся в зависимости от контекста. В грамматике языка \tool{Java} \cite{???} такие конструкции встречаются не менее 14 раз. Для того, чтобы решить проблему списков однажды и навсегда, можно определить следующий шаблон:

\begin{lstlisting}
	list<item, sep> -> item (sep item)*;
\end{lstlisting}

В результате возникает возможность коротко описывать такие разные языковые конструкции как вызов функции и арифметическое выражение:

\begin{lstlisting}
	functionCall -> NAME '(' list<expression, ','> ')';
	arithExpr -> list<product, plusOrMinus>;
\end{lstlisting}

Действительно, в скобках при вызове функции указывается список выражений, разделенных запятыми, а арифметическое выражение --- это алгебраическая сумма произведений, то есть список произведений, разделенных плюсами или минусами.

Стандартизированная нотация EBNF \cite{???} имеет поддержку таких несложных шаблонов, хотя большинство инструментов реализует шаблоны по-своему. Прообразом грамматик с шаблонами можно считать двухуровневые грамматики \cite{???} использованные при описании \tool{Algol68} \cite{???}, однако они не получили широкого распространения: идея была упрощена и приспособлена для понимания инженерами.

Реализация шаблонов в \tool{Menhir} наиболее близка к требованиям стандарта EBNF: индивидуальные правила могут иметь параметры, которым сопоставляются значения при использовании. В \tool{LISA} поддерживаются шаблоны для семантических действий: параметрами являются вхождения атрибутов.

Еще один способ использования шаблонов при описании грамматик состоит в определении не отдельных правил или продукций с параметрами, а в параметризации целой грамматики. Этот подход может служить хорошей альтернативой наследованию грамматик (он, фактически, аналогичен \term{делегированию} в объектно-ориентированных языках \cite{???}). Например, грамматика, определяющая арифметические выражения, может принимать синтаксическую форму для атомарных выражений в виде параметра:

\begin{lstlisting}
grammar template Arith<atom> {
	sum    -> mult (('+' | '-') mult)*;
	mult   -> factor ('*' factor)*;
	factor -> '(' sum ')';
	       -> <atom>;
}
\end{lstlisting}

Этот шаблон позволяет порождать грамматики для арифметических выражений над разными (атомарными) объектами, например, над целочисленными константами и переменными:

\begin{lstlisting}
grammar Arith<INT | VAR>;

INT -> [0-9]+;
VAR -> [a-zA-Z_][a-zA-Z_0-9]*;
\end{lstlisting}

Или над комплексными константами:

\begin{lstlisting}
grammar Arith<complex>;

complex -> '(' FLOAT ',' FLOAT ')';
FLOAT   -> INT '.' INT;
\end{lstlisting}

Параметризацию модулей поддерживают инструменты \tool{ASF+SDF} и \tool{Rats!}, но эти возможности реализованы в них по-разному. \tool{Rats!} позволяет использовать в качестве параметров только модули целиком: параметризованный модуль может импортировать модуль-параметр и обращаться к символам внутри этого модуля. Такой подход в наибольшей степени схож с идеей делегирования в ООП: модуль рассматривается как класс, а набор имен символов --- как интерфейс\footnote{Здесь правомерно говорить об аналогии со ``статическим полиморфизмом'' в \tool{C++} \cite{???}.}. В \tool{ASF+SDF}, напротив, модуль не может быть параметром, в качестве таковых используются только отдельные символы. 

Оба подхода имеют свои недостатки: в \tool{Rats!}, чтобы передать всего один символ в качестве параметра, придется создать модуль, а в \tool{ASF+SDF} неудобно передавать много символов за один раз. Кроме того, шаблоны отдельных правил и выражений в этих инструментах создавать нельзя. Нам не известно о существовании инструмента, поддерживающего все три способа параметризации.
	
\section{Аспектно-ориентированные грамматические определения}

Следующим шагом в развитии средств повторного использования грамматических определений является поддержка аспектов.

// Переписать рассуждения про то, откуда croscutting concerns в грамматиках
// Добавить объяснения про то, что grammar duplication и entanglement при генерации специфических тулов

% Separation of concerns in compiler development using aspect-orientation --- 2006
В работе \cite{???} отмечается, что даже использование аспектно-ориентированного языка общего назначения (\tool{AspectJ}) облегчает разработку трансляторов. Многие инструменты интегрировали поддержку аспектов с более традиционной функциональностью, описанной выше.

Широкую известность получил подход, использованный в системе \tool{JastAdd} \cite{???}, основанной на расширенном определении атрибутных грамматик. В рамках этого подхода (использованного также и в других работах, см. \cite{???}) типы вершин AST рассматриваются как классы, а атрибуты определяются как методы с помощью механизма ITD.

Системы \tool{Silver} \cite{???} и \tool{AspectLISA} \cite{???} также используют аспекты для присоединения семантических действий к продукциям грамматики. Однако, если \tool{JastAdd} позволяет ссылаться лишь на имена символов и не имеет, строго говоря, механизма срезов (point-cuts), что делает квантификацию (см. раздел ???) довольно примитивной, то эти инструменты уже используют срезы для определения точек присоединения. \tool{Silver} позволяет цитировать целиком текст продукции, что гораздо слабее полноценного механизма срезов, используемого в \tool{AspectLISA}: этот инструмент позволяет использовать подстановочные знаки и параметры при определении срезов, аналогично тому как это сделано в \tool{AspectJ}.

Механизм срезов присутствует и в расширении \tool{ASF+SDF}, названном \tool{AspectASF} \cite{???}. Этот язык реализует вычисления над AST с помощью переписывающих правил \cite{???}; срезы сопоставляют левые части и имена правил, а советы позволяют расширить функциональность, добавляя действия либо перед, либо после обработки правила.

\tool{AspectG} \cite{???} также поддерживает срезы. Этот язык является аспектно-ориентированным расширением входного языка генератора СУТ \tool{ANTLR} \cite{???}. Особенность \tool{AspectG} состоит в том, что он поддерживает срезы, описывающие как грамматическую структуру, так и код семантических действий. Необходимо заметить, что семантические действия в \tool{ANTLR} задаются в виде простых строк, структура которых практически не анализируется, поэтому срезы для таких действий основываются на поиске образца в строке. Советы в \tool{AspectG}, как и рассмотренных ранее инструментах, позволяют только добавлять семантические действия, не изменяя грамматической структуры.

Полноценную модификацию грамматической структуры, как было отмечено выше, позволяет только \tool{Rats!}. Механизм использованный в этом инструменте можно описать как аспектно-ориентированный, основанный на примитивных срезах: все продукции в \tool{Rats!} поименованы, и обращение происходит по имени продукции.

% JastAdd vs Polyglot: Modularity First: A Case for Mixing AOP and Attribute Grammars '08

% AspectG va AspectLisa: Domain-specific aspect languages for modularising crosscutting concerns in grammar

\section{Выводы}

// Добавить мотивацию для Grammatic

Приведенный выше обзор показывает, что, несмотря на то, что всевозможные механизмы композиции успешно опробованы в разных инструментах, автоматизирующих разработку текстового синтаксиса, ни один из них не поддерживает одновременно все наиболее успешные методы композиции, а именно:
\begin{enumerate}
\item модули с поддержкой атрибутов видимости;
\item шаблоны всех элементов нотации (не только модулей, и не только выражений), параметризуемые любыми элементами нотации (не только модулями, и не только символами);
\item аспекты, поддерживающие полноценные срезы, и позволяющие не только оперировать семантическими действиями, но и модифицировать правила грамматики.
\end{enumerate}

Появление инструмента, поддерживающего все эти возможности, удовлетворило бы одновременно потребности разработчиков очень многих языков. Разработка такого инструмента входит в задачи данной работы.
	
\chapter{Автоматизация разработки механизмов композиции}

Из предыдущего раздела видно, что предметно-ориентированные языки (в данном случае --- языки, предназначенные для описания текстового синтаксиса) нуждаются в инфраструктурной функциональности, обеспечивающей композицию, не меньше, чем языки общего назначения. В данном разделе мы рассмотрим инструменты, позволяющие в той или иной степени автоматизировать разработку такой функциональности для предметно-ориентированных языков.

\section{Анализ идентификаторов}

Идентификация элементов является тривиальной задачей для средств разработки графического синтаксиса, поскольку они хранят элементы моделей как объекты в памяти, и могут использовать естественную индивидуальность (identity \cite{???}) этих объектов для идентификации. При сохранении на диск в формате XMI \cite{???} также существует стандартизированный механизм идентификации, но получающееся таким образом текстовое представлением неудобно для чтения человеком. Ситуация не облегчается и стандартной нотацией HUTN \cite{???}, поскольку ее синтаксис достаточно громоздок и не очень далек от XMI.

При разработке текстового синтаксиса анализ идентификаторов является третьим этапом создания транслятора \cite{???}, после лексического и синтаксического анализа. В простых случаях этот механизм легко реализуется с помощью таблицы символов, более сложные случаи требуют усложненных структур данных. Дополнительные трудности накладывает наличие различных пространств имен (например, когда множество имен функций может пересекаться с множеством имен переменных, потому что из синтаксиса всегда ясно, идет ли речь о переменной или о функции) и вложение этих областей. Основанный на атрибутной трансляции инструмент \tool{Eli} \cite{???} предоставляет обширную библиотеку для реализации различных вариаций механизма разрешения идентификаторов, но использование этой библиотеки по-прежнему требует написания достаточно большого объема кода.

Генераторы сред разработки, такие как \tool{xText} \cite{???} и \tool{TCS} \cite{???} автоматизируют разрешение имен в простых случаях. \tool{TCS} позволяет определять вложенные области видимости и непересекающиеся пространства имен с помощью специальных директив внутри грамматического определения. 

\section{Механизмы простого цитирования}

Как отмечалось выше, самым простым механизмом композиции являются модули, не использующие параметризацию. Этот механизм позволяет объединять элементы, имеющие идентификаторы, в группы, называемые \term{модулями}. Такой модуль может быть \term{подключен} в некоторой области видимости (как правило в другом модуле), что позволяет использовать объявленные в нем элементы в этой области видимости.

Ряд инструментов, автоматизирующих разработку языков, позволяет добавлять поддержку модулей достаточно легко. Так, инструменты, опирающиеся на графический или псевдотекстовый синтаксис \cite{EMF Fujaba MPS} используют для реализации модулей ссылки между моделями, поддерживаемые мета-мета-моделями, использующими XMI \cite{XMI} (например, MOF или \tool{Ecore}), что не требует от разработчика описывать модули дополнительно. Вместе с тем, такая реализация модулей достаточно примитивна, например, она не позволяет вводить \term{атрибуты доступа}, то есть разделять элементы модуля на внутренние (private) и внешние (public).

Для языков с текстовым синтаксисом поддержка модулей реализуется несколько сложнее. Так упоминавшийся выше инструмент \tool{Eli} \cite{???} предоставляет библиотеку для реализации нескольких вариантов этого механизма, однако ее использование требует написания большого количества кода. Гораздо более простая реализация имеется в \tool{xText} \cite{???}: этот инструмент предоставляет ``текстовую оболочку'' для механизма ссылок между моделями, реализованного в \tool{Ecore}, а именно распознает специальное имя атрибута (\code{importURI}) и интерпретирует его как однородный идентификатор ресурса (Uniform Resource Identifier, URI \cite{???}), который автоматически загружается в текущую область видимости. Как следует из сказанного выше, такой механизм не имеет автоматической поддержки для атрибутов доступа.

Инструменты, позволяющие более полную автоматизацию поддержки модулей, нам не известны, однако ниже мы рассматриваем системы, частично автоматизирующие поддержку шаблонов. Поскольку модули, как мы видели выше, легко представить в виде шаблонов без параметров, можно считать, что средства описания шаблонов поддерживают также и модули.

\section{Шаблоны и макроопределения}

Автоматически шаблоны или макроопределения поддерживают только внутренние (internal) ПОЯ, определенные в языках с поддержкой соответствующих конструкций, таких как \tool{Lisp} или \tool{MacroML}.

Для самостоятельных языков поддержку шаблонов автоматизируют инструменты \tool{COMPOST} \cite{???} и \tool{Reuseware} \cite{???}. Последний является развитием первого, поэтому здесь мы опишем только его возможности.
 
Принцип, на котором основывается \tool{Reuseware} его авторы называют инвазивной композицией ПО (Invasive Software Composition, ISC \cite{???}). Это методология, определенная для моделей и КС-грамматик, базирующаяся на введение в структуру языка дополнительных элементов, так называемых \term{точек изменения} (variation points), которые подразделяются на следующие типы:
\begin{itemize}
\item \emph{slot} --- помечает выражение в языке для последующей замены, аналогично параметру шаблона со значением по умолчанию \cite{Cpp};
\item \emph{hook} --- помечает позицию для вставки элементов (возможно, многих), аналогично простому шаблонному параметру;
\item \emph{anchor} --- помечает выражение идентификатором, на который в дальнейшем можно сослаться при описании композиции (см. ниже).
\end{itemize}

Предложения, содержащие точки изменения, называются \term{фрагментами} (Component Fragment). Располагая набором фрагментов, разработчик может описывать их \term{композицию} с помощью специального языка, который определен в инструментах \tool{Reuseware} и имеет графический синтаксис. Композиция заключается в соединении элементов типа \emph{anchor} с элементами двух других типов, причем при присоединении к элементу типа \emph{slot} происходит замена его содержимого, а в случае элемента типа \emph{hook} --- дополнение.

Важной особенностью механизма ISC является тот факт, что он контролирует структурную корректность результата: точки изменения имеют типы (соответствующие классам в мета-модели или нетерминалам в грамматике), и соединение точек с несовместимыми типами запрещено семантикой языка описания композиции, что позволяет гарантировать, что результат не нарушает требований, наложенных целевой мета-моделью. Как мы увидим ниже, те же принципы можно использовать для автоматизированной реализации поддержки аспектов.

Недостатком такого подхода является тот факт, что он \term{незамкнут}: для того, чтобы использовать ``шаблоны'', определенные таким образом, нужно привлекать дополнительный язык, зависящий в свою очередь от инструментов \tool{Reuseware}, то есть расширенная версия исходного языка теряет самостоятельность. Кроме того, способ организации точек изменения гораздо менее локален по сравнению с традиционными шаблонами: ``телом шаблона является вся программа'', что затрудняет инкапсуляцию и делает весь подход менее интуитивным, поскольку теряется аналогия шаблонов с функциями, вычисляемыми во время компиляции \cite{???}.

\section{Аспекты}

Разработку поддержки аспектов в той или иной мере автоматизируют несколько инструментов и методологий. Мы начнем с применения инструментария \tool{Reuseware}, рассмотренного в предыдущем разделе.

Система фрагментов и точек изменения может быть рассмотрена как ``заготовка'' для аспектной композиции. Обеспечить полное \term{незнание} (см. ???) не удается, поскольку точки изменения отмечаются явно, но некоторая степень незнания все же достигается за счет использования внешнего языка композиции. \term{Квантификацию} позволяет обеспечить механизм \term{запросов} (fragment queries), позволяющий коротко описывать множества точек изменения. Этот механизм выполняет функцию срезов. Поиск точек изменения осуществляется по фрагменту имени и типу.  Достоинства этого подхода --- в его универсальности, а недостатки применительно к данной задаче --- в первую очередь, в отсутствии незнания.

Альтернативный подход представлен в работе \cite{VanWyk03}, которая основана на атрибутной трансляции и переписывании. AST, созданное в процессе разбора программы может быть переписано в соответствии с декларативно заданными правилами. При этом поддерживается с \term{перенаправление} атрибутов (forwarding). Идея перенаправления состоит в том, что атрибут элемента AST может быть вычислен путем обращения к атрибуту элемента, полученного в результате переписывания исходного. В такой среде аспекты реализуются следующим образом: срез является предикатом, который определяет применимость того или иного совета для каждого элемента AST (в рамках данного подхода срезы реализуются как функции высшего порядка, написанные на языке Haskell), советы добавляются в код посредством создания новых правил переписывания, а перенаправление позволяет распространить семантические проверки на добавленный таким образом код. Преимуществом этого подхода является возможность добавить аспекты в любой язык независимо от других расширений, причем гарантируется сохранение корректности статических проверок. Основным недостатком является необходимость написания срезов на языке общего назначения, что, как и в случае \tool{Reuseware} делает систему незамкнутой.

Работа \cite{DSAL = Library+Notation} описывает метод, основанный на использовании системы \tool{Stratego/XT} \cite{???} --- широко известного инструмента для трансформации программ, основанного на \emph{стратегическом программировании} (strategic programming), представляющем собой объединение возможностей логического программирования и переписывания термов. Основная идея состоит в том, чтобы описывать применение аспектов как трансформации, во многом аналогично работе \cite{VanWyk03}. В данном случае авторы предлагают вручную реализовать и синтаксис, и семантику аспектов, демонстрируя, что это достаточно легко сделать, располагая инструментами \tool{Stratego/XT} и реализацией самого исходного языка. Строго говоря, эта работа описывает не технологию автоматизации, а метод ручной разработки.

Мы отмечали отсутствие поддержки срезов как недостаток описанных выше подходов. Методология автоматизированного построения системы срезов (но не остальных необходимых элементов аспектного языка) описана в работе \cite{CPL}. Авторы предлагают использовать ``универсальный'' язык срезов \tool{XCPL}, позволяющий выразить очень широкий класс предикатов над программными конструкциями. Этот язык предлагается сокращать по мере надобности для описания срезов для каждого конкретного языка, при этом необходимо каждый раз разрабатывать конкретный синтаксис сокращенного языка. Семантика \tool{XCPL} также не фиксирована, а должна быть реализована вручную при каждом применении. Таким образом, \tool{XCPL} является просто мета-моделью, позволяющей описывать срезы, и не автоматизирует по-настоящему их разработку.

Необходимо отметить, что существует обширная литература, касающаяся реализации аспектов с точки зрения сред времени выполнения (см., например, \cite{???-???}). Поскольку мы рассматриваем инфраструктурную функциональность языков, которая по природе своей реализуется во время компиляции, а не во время выполнения, рассмотрение этих работ выходит за пределы нашего обсуждения.
	POPART
	XAspects --- встраивание аспектных языков в AspectJ	
	JAMI --- общий рантайм для DSAL
	
\section{Выводы}

Приведенный обзор средств автоматизации разработки механизмов композиции показывает, что на данный момент ни один из рассмотренных подходов не позволяет автоматически реализовать в замкнутой форме шаблоны, а также аспекты с полной поддержкой квантификации и незнания.

\chapter{Постановка задачи}

Целью данной работы является создание технологии автоматизации разработки языков, поддерживающих автоматизированную реализацию сложных механизмов композиции, а именно
\begin{itemize}
\item шаблонов в замкнутой форме, конструирующих и принимающих в качестве параметров любые элементы языка, и обеспечивающих структурную корректность результатов;
\item аспектов в замкнутой форме, поддерживающие незнание и квантификацию (срезы), и обеспечивающих структурную корректность результатов.
\end{itemize}

Для достижения поставленной цели необходимо детально изучить механизмы композиции, указанные выше и их взаимодействие с другими частями языкового процессора. Для этого создан инструмент автоматизации разработки текстового синтаксиса \tool{Grammatic}, поддерживающий данные механизмы композиции, которые были реализованные вручную. Приемы, примененные при реализации \tool{Grammatic} обобщены для произвольные языки, что позволяет получить требуемую технологию.

Будем:
	- Разрабатывать язык для грамматик, чтобы понять чего и как
	- Обобщим то, что там наработаем
	- Найдем удобный способ описания языков
		- для графики
		- для текста
	- Научимся конвертировать ядро в инфраструктуру