\chapter{Инструменты для автоматизации разработки текстовых языков}

В данном разделе мы рассматриваем существующие инструменты, автоматизирующие разработку языков. В основном, эти инструменты ориентированы на разработку предметно-ориентированных языков, поскольку такие языки необходимо разрабатывать часто, что делает затраты на реализацию даже элементарных возможностей таких языков часто повторяющимися, в результате чего возникает необходимость в максимальном сокращении таких затрат.

В первую очередь нас интересует, насколько существующие подходы позволяют автоматизировать поддержку механизмов композиции, описанных выше, однако мы будем также отмечать и другие особенности этих подходов, в частности, поддержку механизмов композиции в языках, используемых самими инструментами.

\ignore{
\section{Контекстно-свободные грамматики}

--- Описание грамматик
	BNF
	EBNF (шаблоны)
	
	КСГ
	продукция 
	правило 
	правая часть 
	символ 
	терминал 
	нетерминал

	индуцированная алгебра термов
	частичный тип

\section{Атрибутная трансляция}

определения
JustAdd, ITD в нем

	атрибут
	семантическое действие

\section{Синтаксически-управляемая трансляция}

недостаток АТ

определение СУТ, L-атрибутные определения

Генераторы на основе СУТ
	Yacc/Bison и компания
		LALR, только синтез. аттр
	ANTLR
		LL, и те, и те
		
	внедренные семантические действия
}				
\section{Внутренние ПОЯ}

Часто ПОЯ разделяют на \term{внешние} (external) и \term{внутренние} (internal) \cite{StateMachine}. Внешними называют языки, имеющие специальные средства обработки, например, транслятор, написанные именно для данного ПОЯ. Внутренние языки, напротив, не имеют специальных средств обработки: они ``встраиваются'' в языки общего назначения, как библиотеки или расширения другого рода. В принципе, любой прикладной программный интерфейс (Application Programing Interface, API) можно рассматривать как внутренний ПОЯ: функции API выполняют роль ``ключевых слов'' внутреннего языка. Как правило, о внутренних языках говорят, если соответствующий язык общего назначения позволяет обращаться к библиотекам, используя достаточно гибкие синтаксические конструкции.

// Пример про fluent interfaces

Популярными языками для встраивания ПОЯ являются, например, \tool{Groovy} \cite{Groovy}, \tool{Haskell} \cite{Haskell98}, \tool{Scala} \cite{Odersky2008} и \tool{Java} \cite{JLS}. Существуют языки, имеющие специальные механизмы для расширения синтаксиса, позволяющие очень удобно интегрировать внутренние языки, например, \tool{Nemerle} \cite{Nemerle} и \tool{PLOT} \cite{PLOT}.
		
\section{Модульность грамматических определений}

Как ни странно, далеко не все популярные инструменты поддерживают повторное использование грамматических определений, например, \tool{Bison} \cite{BisonBook}, \tool{CoCo/R} \cite{CocoR} и \tool{JavaCC} \cite{JavaCC} не поддерживают никаких механизмов такого рода. Это связано в первую очередь с тем, что грамматические определения ``двумерны'': они содержат как описание синтаксической структуры (продукции КСГ), так и описание вычислений (семантические действия), что затрудняет композицию. Кроме того, специальные классы грамматик (например, $LL(k)$) не замкнуты относительно объединения, что накладывает дополнительные трудности на композицию \cite{???}. Так или иначе, инженерная дисциплина при разработке трансляторов находится на гораздо более низком уровне, чем при разработке других видов ПО \cite{Grammarware}.

В данном разделе мы рассмотрим механизмы повторного использования грамматических определений, основанные на цитировании, то есть модули и шаблоны. Аспектно-ориентированная композиция грамматик рассматривается в следующем разделе.

\subsection{Модули и ограничение видимости} В работе \cite{SysProg-2006} приведен обзор наиболее популярных средств для разработки трансляторов и выполнено сравнение по нескольким критериям, одним из которых является повторное использование.

Простейшая реализация модулей представлена в инструментах \tool{Elkhound} \cite{Elkhound} и \tool{ANTLR} версии 3 \cite{ANTLR}, который поддерживает директиву \code{include} для подключения определение из других файлов. 

Несколько иной подход использован в генераторе \tool{Menhir} \cite{Menhir}, который, принимая на вход несколько файлов, просто ``склеивает'' их содержимое вместе, но позволяет контролировать, какие символы являются открытыми (public) и могут быть использованы в других файлах, а какие --- нет. Закрытые (private) символы автоматически переименовываются для того, чтобы избежать коллизий. Особенность идеи ``склеивания'' файлов состоит в отсутствии директивы цитирования (\code{include} или \code{import}), что облегчает реализацию механизма, но делает зависимости между модулями \emph{невидимыми}: читая отдельный файл, трудно понять, какие из упоминаемых символов определены в других модулях, а главное --- нет никакой возможности определить, в каких именно модулях они определены.

Более традиционным образом модули организованы в системе \tool{ASF+SDF} \cite{ASF+SDF}: аналогично подходу, принятому в языках программирования, каждый модуль имеет имя, соответствующее имени файла, в котором он определен, элементы, объявленные в модуле, делятся на открытые (\code{exports}) и закрытые (\code{hidden}), причем другие модули могут использовать только открытые элементы, что обеспечивает инкапсуляцию. Директива цитирования \code{import} позволяет подключать модули друг к другу. При импортировании может оказаться, что символ, объявленный в одном модуле имеет то же имя, что и символ объявленный в другом. Как мы видели выше, в некоторых языках эта проблема решается с помощью квалифицированных имен (среди инструментов разработки трансляторов такого подхода придерживается \tool{Rats!} \cite{Rats!}); в \tool{ASF+SDF} используется другой подход: директива цитирования позволяет при необходимости \term{переименовать} символ, импортируемый из данного модуля, например:

\begin{lstlisting}
module example/Example

imports library/Lib[ A => B ]
\end{lstlisting}

Теперь внутри модуля \code{example/Example} символ \code{A}, определенный в \code{library/Lib} будет иметь имя \code{B}.

\subsection{Наследование в грамматических определениях}
% Compiler generation based on grammar inheritance
Идея \term{наследования грамматик} была впервые предложена в работе \cite{GInh}, и основывается на том, что грамматика может наследоваться от другой грамматики, добавляя новые правила и переопределяя старые. Первоначальная реализация была выполнена на языке \tool{Smalltalk} для рабочей станции \tool{Sun 3}, и не получила широкого распространения, однако в дальнейшем наследование грамматик было реализовано в других инструментах.

В \tool{ANTLR} версии 2 \cite{ParrQ95} наследование грамматик является единственным механизмом их повторного использования. Грамматика может быть унаследована от не более, чем одной родительской грамматики, при этом возможно переопределение правил, а именно: изменение семантических действий (при сохранении синтаксической структуры),  добавление новых альтернатив к существующим правилам. Кроме переопределения, также можно определять и совершенно новые правила (которые могут ссылаться на символы, определенные в родительской грамматике). К недостаткам такого подхода к повторному использованию можно отнести тот факт, что наследование является одиночным, и у разработчика нет возможности использовать несколько независимых модулей при разработке одного языка. Создатели \tool{ANTLR} 2 в качестве основного сценария использования наследования грамматик указывали создание нескольких диалектов одного языка \cite{???}.
% http://www.antlr2.org/doc/inheritance.html

Множественное наследование атрибутных грамматик предложено в работе \cite{MAGInh} и реализовано в инструменте \tool{LISA}. %http://portal.acm.org/citation.cfm?id=606666.606678
Авторы уделили больше внимание повторному использованию семантических действий, но и синтаксическая структура может быть унаследована, дополнена и частично переопределена.
Важным дополнением к наследованию грамматик в \tool{LISA} являются \term{шаблоны}.

В некоторых объектно-ориентированных языках (таких, например, как \tool{Scala} \cite{Odersky2008}) альтернативой наследованию является ``подмешивание'' (mixins). Похожий механизм для грамматик реализует инструмент \tool{xText} \cite{xText}. Результирующий механизм близок к множественному наследованию грамматик, но более строго и просто определяет поведение системы в случае ``ромбовидного наследования'' \cite{C++}. Mixin в \tool{xText} может добавлять новые правила или продукции, а также переопределять существующие.

Единственным известным нам инструментом, позволяющим не только добавлять, но и удалять продукции, является \tool{Rats!} \cite{Rats!}. Этот инструмент не используем явным образом метафору наследования для грамматик: авторы говорят лишь о ``модификации импортируемых модулей'', однако функциональность, реализованная этой операцией схожа с тем, что в других инструментах достигается с помощью наследования грамматик: есть возможность добавить продукцию, заменить или даже удалить ее.


\paragraph*{Параметризованные определения (шаблоны).}
Идею использования шаблонов (макроопределений для продукций или правил) при описании формальных грамматик легко проиллюстрировать на следующем примере: в синтаксисе языков программирования очень часто встречаются списки --- последовательности элементов (например, имен переменных), разделенных специальным символом (например, запятой). Элементы и разделители разнятся в зависимости от контекста. В грамматике языка \tool{Java} \cite{JLS} такие конструкции встречаются не менее 14 раз. Для того, чтобы решить проблему списков однажды и навсегда, можно определить следующий шаблон:

\begin{lstlisting}
	list<item, sep> -> item (sep item)*;
\end{lstlisting}

В результате возникает возможность коротко описывать такие разные языковые конструкции как вызов функции и арифметическое выражение:

\begin{lstlisting}
	functionCall -> NAME '(' list<expression, ','> ')';
	arithExpr -> list<product, plusOrMinus>;
\end{lstlisting}

Действительно, в скобках при вызове функции указывается список выражений, разделенных запятыми, а арифметическое выражение --- это алгебраическая сумма произведений, то есть список произведений, разделенных плюсами или минусами.

Стандартизированная нотация EBNF \cite{EBNF} имеет поддержку таких несложных шаблонов, хотя большинство инструментов реализует шаблоны по-своему. Прообразом грамматик с шаблонами можно считать двухуровневые грамматики \cite{???} использованные при описании \tool{Algol68} \cite{Algol68}, однако они не получили широкого распространения: идея была упрощена и приспособлена для понимания инженерами.

Реализация шаблонов в \tool{Menhir} наиболее близка к требованиям стандарта EBNF: индивидуальные правила могут иметь параметры, которым сопоставляются значения при использовании. В \tool{LISA} поддерживаются шаблоны для семантических действий: параметрами являются вхождения атрибутов.

Еще один способ использования шаблонов при описании грамматик состоит в определении не отдельных правил или продукций с параметрами, а в параметризации целой грамматики. Этот подход может служить хорошей альтернативой наследованию грамматик (он, фактически, аналогичен \term{делегированию} в объектно-ориентированных языках \cite{Gamma1995}). Например, грамматика, определяющая арифметические выражения, может принимать синтаксическую форму для атомарных выражений в виде параметра:

\begin{lstlisting}
grammar template Arith<atom> {
	sum    -> mult (('+' | '-') mult)*;
	mult   -> factor ('*' factor)*;
	factor -> '(' sum ')';
	       -> <atom>;
}
\end{lstlisting}

Этот шаблон позволяет порождать грамматики для арифметических выражений над разными (атомарными) объектами, например, над целочисленными константами и переменными:

\begin{lstlisting}
grammar Arith<INT | VAR>;

INT -> [0-9]+;
VAR -> [a-zA-Z_][a-zA-Z_0-9]*;
\end{lstlisting}

Или над комплексными константами:

\begin{lstlisting}
grammar Arith<complex>;

complex -> '(' FLOAT ',' FLOAT ')';
FLOAT   -> INT '.' INT;
\end{lstlisting}

Параметризацию модулей поддерживают инструменты \tool{ASF+SDF} и \tool{Rats!}, но эти возможности реализованы в них по-разному. \tool{Rats!} позволяет использовать в качестве параметров только модули целиком: параметризованный модуль может импортировать модуль-параметр и обращаться к символам внутри этого модуля. Такой подход в наибольшей степени схож с идеей делегирования в ООП: модуль рассматривается как класс, а набор имен символов --- как интерфейс\footnote{Здесь правомерно говорить об аналогии со ``статическим полиморфизмом'' в \tool{C++} \cite{C++}.}. В \tool{ASF+SDF}, напротив, модуль не может быть параметром, в качестве таковых используются только отдельные символы. 

Оба подхода имеют свои недостатки: в \tool{Rats!}, чтобы передать всего один символ в качестве параметра, придется создать модуль, а в \tool{ASF+SDF} неудобно передавать много символов за один раз. Кроме того, шаблоны отдельных правил и выражений в этих инструментах создавать нельзя. Нам не известно о существовании инструмента, поддерживающего все три способа параметризации.
	
\section{Аспектно-ориентированные грамматические определения}

Следующим шагом в развитии средств повторного использования грамматических определений является поддержка аспектов.

// Переписать рассуждения про то, откуда croscutting concerns в грамматиках
// Добавить объяснения про то, что grammar duplication и entanglement при генерации специфических тулов

% Separation of concerns in compiler development using aspect-orientation --- 2006
В работе \cite{Wu06} отмечается, что даже использование аспектно-ориентированного языка общего назначения (\tool{AspectJ}) облегчает разработку трансляторов. Многие инструменты интегрировали поддержку аспектов с более традиционной функциональностью, описанной выше.

Широкую известность получил подход, использованный в системе \tool{JastAdd} \cite{JastAdd}, основанной на расширенном определении атрибутных грамматик. В рамках этого подхода (использованного также и в других работах, см. \cite{Silver}) типы вершин AST рассматриваются как классы, а атрибуты определяются как методы с помощью механизма ITD.

Системы \tool{Silver} \cite{Silver} и \tool{AspectLISA} \cite{LISA} также используют аспекты для присоединения семантических действий к продукциям грамматики. Однако, если \tool{JastAdd} позволяет ссылаться лишь на имена символов и не имеет, строго говоря, механизма срезов (point-cuts), что делает квантификацию (см. раздел ???) довольно примитивной, то эти инструменты уже используют срезы для определения точек присоединения. \tool{Silver} позволяет цитировать целиком текст продукции, что гораздо слабее полноценного механизма срезов, используемого в \tool{AspectLISA}: этот инструмент позволяет использовать подстановочные знаки и параметры при определении срезов, аналогично тому как это сделано в \tool{AspectJ} \cite{AspectJ}.

Механизм срезов присутствует и в расширении \tool{ASF+SDF}, названном \tool{AspectASF} \cite{AspectASF}. Этот язык реализует вычисления над AST с помощью переписывающих правил \cite{TermRewriting}; срезы сопоставляют левые части и имена правил, а советы позволяют расширить функциональность, добавляя действия либо перед, либо после обработки правила.

\tool{AspectG} \cite{AspectG} также поддерживает срезы. Этот язык является аспектно-ориентированным расширением входного языка генератора \tool{ANTLR} \cite{ANTLR}. Особенность \tool{AspectG} состоит в том, что он поддерживает срезы, описывающие как грамматическую структуру, так и код семантических действий. Необходимо заметить, что семантические действия в \tool{ANTLR} задаются в виде простых строк, структура которых практически не анализируется, поэтому срезы для таких действий основываются на поиске образца в строке. Советы в \tool{AspectG}, как и рассмотренных ранее инструментах, позволяют только добавлять семантические действия, не изменяя грамматической структуры.

Полноценную модификацию грамматической структуры, как было отмечено выше, позволяет только \tool{Rats!}. Механизм использованный в этом инструменте можно описать как аспектно-ориентированный, основанный на примитивных срезах: все продукции в \tool{Rats!} поименованы, и обращение происходит по имени продукции.

% JastAdd vs Polyglot: Modularity First: A Case for Mixing AOP and Attribute Grammars '08

% AspectG va AspectLisa: Domain-specific aspect languages for modularising crosscutting concerns in grammar

\section{Выводы}

// Добавить мотивацию для Grammatic

Приведенный выше обзор показывает, что, несмотря на то, что всевозможные механизмы композиции успешно опробованы в разных инструментах, автоматизирующих разработку текстового синтаксиса, ни один из них не поддерживает одновременно все наиболее успешные методы композиции, а именно:
\begin{enumerate}
\item модули с поддержкой атрибутов видимости;
\item шаблоны всех элементов нотации (не только модулей, и не только выражений), параметризуемые любыми элементами нотации (не только модулями, и не только символами);
\item аспекты, поддерживающие полноценные срезы, и позволяющие не только оперировать семантическими действиями, но и модифицировать правила грамматики.
\end{enumerate}

Появление инструмента, поддерживающего все эти возможности, удовлетворило бы одновременно потребности разработчиков очень многих языков. Разработка такого инструмента входит в задачи данной работы.
