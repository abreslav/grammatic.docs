\chapter{Языки как множества моделей}

Традиционно \emph{языком} называется множество строк, составленных символами некоторого конечного алфавита \cite{DragonBook,MotwaniUlman}. Такой подход вполне оправдан при рассмотрении вопросов теории сложности \cite{AroraBarak}, алгебраических свойств операций над языками \cite{Martynenko,MotwaniUlman} и задач синтаксического анализа \cite{DragonBook}. Однако язык, предназначенный для использования человеком, в первую очередь представляет собой \emph{систему понятий и отношений между ними}, и при рассмотрении таких языков целесообразно отталкиваться не от текстового \emph{конкретного} синтаксиса, роль которого обычно весьма важна, но не первостепенна, а от какого-то более структурированного описания, не зависящего от визуального представления предложений языка. Такое структурированное представление, как правило, называют \emph{абстрактным синтаксисом}. Сразу заметим, что этот термин сильно перегружен значениями. Так наиболее распространенное понятие \emph{абстрактного синтаксического дерева} (Abstract Syntax Tree, AST \cite{SGLR,DragonBook}) не соответствует представлениям об абстрактном синтаксисе языка: абстрактное представление даже весьма простых программ, не будет являться деревом (см. \figref{simplerlambda}).

Мы используем следующее определения языка:
\begin{Def}[Язык]
Пусть $M$ --- модель и $\Metainfo(M) = \MMM$ (элементами $M$ являются описания классов, следовательно $M$ может выступать в качестве метамодели). Множество $\Language{M}$, состоящее из всех моделей $m$, таких что 
	$\Metainfo(m) = M$,
называется \emph{языком}, порожденным метамоделью $M$ или просто \emph{языком $M$}.
\end{Def}

!!!!

\begin{Def}[Интерпретирующая семантика]
$P : \Language{M} \times World \rightarrow World \times \{\bot\}$
\end{Def}

Возникает вопрос о том, как связано традиционное определение понятия \emph{язык} с тем, которое используем мы. В данном разделе мы покажем, во-первых, что для любого контекстно-свободного языка существует естественное представление в виде языка, порожденного некоторой метамоделью \cite{Reuseware-something}, а во-вторых, что контекстно-свободная грамматика $G$, снабженная аннотациями определенного вида \cite{xText}, может быть механически преобразована в метамодель $M_G$, такую, что $\Language{M_G}$ является в точности множеством абстрактных синтаксических деревьев для языка, порожденного грамматикой $G$.

\section{Нотация для контекстно-свободных грамматик}

Для описания контекстно-свободных грамматик чаще всего применяется нотация Бэкуса-Наура (Backus-Naur Form, BNF, \cite{BNF}), позволяющая задавать продукции, в правой части которых стоят последовательности терминальных и нетерминальных символов. Поскольку множество контекстно-свободных языков замкнуто относительно регулярных операций объединения и итерации, мы можем рассматривать более удобную для приложений расширенную нотацию Бэкуса-Наура (Extended BNF, EBNF \cite{EBNF}). Существует несколько версий конкретного синтаксиса EBNF, и мы используем вариант, основанный на нотации \tool{ANTLR} \cite{ANTLR}\footnote{Полное описание используемой нами нотации приведено в Приложении \ref{grammar-notation}.}. В этой нотации правая и левая части продукции разделяются двоеточием, и в правой части могут использоваться следующие операции (\code{A} и \code{B} обозначают грамматические выражения):
\begin{itemize}
\item конкатенация: \code{A B};
\item объединение: \code{A | B};
\item итерация Клини: \code{A*} (повторение ноль или более раз);
\item повторение один или более раз: \code{A+};
\item необязательное вхождение: \code{A?};
\item группировка: \code{(A)}.
\end{itemize}
Следуя нотации \tool{ANTLR}, мы пишем названия терминальных символов заглавными буквами (например \code{NAME}), а нетерминальных --- начиная со строчной буквы, согласно конвенции ``CamelCase'' (например, \code{longName}). Ключевые слова и знаки операций, также соответствующие терминальным символам, пишутся в двойных кавычках.

В качестве примера использования данной нотации рассмотрим контекстно-свободную грамматику для упрощенного синтаксиса заголовков методов в языке \tool{Java} \cite{JLS} (см. \lstref{java-method-header}). Метод может быть либо \emph{абстрактным}, тогда он должен быть помечен ключевым словом \code{abstract} и после списка параметров следует точка с запятой, либо \emph{конкретным}, тогда после списка параметров следует \emph{тело} метода в фигурных скобках (для простоты в нашем примере тело всегда пустое). 

\begin{lstlisting}[language=ANTLR,float,label=java-method-header,caption=Упрощенный синтаксис описания методов в языке \tool{Java}.]
methodHeader
  : "abstract" signature ";"
  | signature body
  ;

signature : type NAME "(" parameterList? ")";
  
parameterList : parameter ("," parameter)*;
  
type : "void" | NAME;
  
parameter : type NAME;
  
body : "{" "}" ;
\end{lstlisting}

\figdef{java-method-parse-tree}{Метамодель, соответствующая \figref{java-method-header}.}

\section{Метамодели, эквивалентные грамматикам}

На \figref{java-method-parse-tree} приведена диаграмма метамодели, построенной по грамматике из \lstref{java-method-header}. Эта метамодель получена механически, и ниже мы приведем процедуру построения таких метамоделей, но сначала рассмотрим этот пример. Большинство классов на \figref{java-method-parse-tree} соответствуют нетерминалам грамматики и имеют свойства, соответствующие составляющим правых частей соответствующих продукций, так что экземплярами данной метамодели являются в точности деревья разбора, соответствующие предложениям языка, порождаемого грамматикой из \lstref{java-method-header}. Рассмотрим пример такого предложения:
\begin{lstlisting}[language=Java]
void example(String s) {}
\end{lstlisting}
Соответствующая модель приведена на \figref{java-parse-tree-example}.
\figdefw{1\textwidth}{java-parse-tree-example}{Диаграмма объектов дерева разбора.}
Из рисунка видно, что дерево встраивания объектов прямо соответствует дереву разбора. Объекты класса \code{Token}, занимающие нижний уровень дерева, соответствуют лексемам (каждая лексема хранит текст, из которого она была получена в поле \code{text} и соответствующий терминальный символ в поле \code{type}), а на объекты на остальных уровнях дерева соответствуют применениям продукций.

Заметим, что по дереву разбора легко можно восстановить текст, из которого оно было получено, следовательно можно утверждать, что при преобразовании в модель \emph{сохраняется вся полезная информация}, имевшаяся в исходном тексте\footnote{В нашем примере мы не учитываем пробельные символы, поскольку грамматика их игнорирует, но это легко исправить.}. Отсюда следует Предложение \ref{mm-gr-eq}.
\begin{Prop}\label{mm-gr-eq}
Метамодель на \figref{java-method-parse-tree} в качестве описания языка эквивалентна грамматике из \lstref{java-method-header}.
\end{Prop}

Осталось показать, что по любой контекстно-свободной грамматике можно построить эквивалентную метамодель. Для этого достаточно применить следующую процедуру.

!!!!!!
