\afsubsection{Первая глава} посвящена обзору существующих подходов к автоматизации разработки предметно-ориентированных языков. Долгое время в этой области доминировали инструменты, предназначенные для разработки трансляторов текстовых языков, основанные на принципах синтаксически управляемой атрибутной трансляции. Наиболее популярными инструментами этого семейства являются \tool{Yacc}, \tool{Bison} и \tool{ANTLR}. Такие инструменты подразумевают описание синтаксиса языка с помощью контекстно-свободной грамматики, с продукциями которой ассоциированы правила вычисления атрибутов, описывающих семантические свойства предложений языка. С помощью атрибутов могут быть реализованы все стадии семантического анализа от разрешения имен до преобразования в машинный код. 

Основным недостатком традиционных средств разработки трансляторов применительно к созданию предметно-ориентированных языков является трудоемкость разработки. Это вызвано в первую очередь тем, что такие инструменты создавались как универсальные средства разработки языков программирования и не предназначены для быстрого решения типичных задач, возникающих при создании небольших языков.

Распространенным способом решения проблемы быстрой разработки ПОЯ является встраивание таких языков в языки общего назначения. При этом используются встроенные в язык общего назначения средства мета-программирования или гибкие синтаксические конструкции. Чаще всего ПОЯ встраиваются в динамические языки, такие как \tool{Ruby} или \tool{Groovy}, и в языки с гибкой системой типов, такие как \tool{Haskell} или \tool{Scala}. Основным недостатком данного подхода является привязка к тому или иному языку общего назначения: ПОЯ, легко встраиваемый в один язык, может быть практически невозможно встроить в другой. Это затрудняет повторное использование ПОЯ и приводит к смешиванию уровней абстракции: аспекты реализации сильно влияют на высокоуровневое описание предметной области.

Другое направление в развитии средств разработки языков основано на использовании графического синтаксиса вместо текстового. Толчок к развитию этого направление дал UML, унифицированный язык моделирования. Чаще всего нотации таких языков используют диаграммы, представляющие собой графы с различными типами вершин и ребер, уложенные на плоскости. Такие языки показали высокую эффективность при решении определенного круга задач, но они не заменяют текстовых языков, в частности, потому, что требуют серьезной инструментальной поддержки, что создает трудности с совместимостью и переносимостью. Следует отметить также, что в области графического синтаксиса существует подход, реализованный в проекте \tool{MPS}, объединившим сильные стороны текстового и графического синтаксиса. Однако в настоящее время этот подход также требует серьезной инструментальной поддержки, что создает препятствия к его использованию в индустрии.

С развитием идеи предметно-ориентированных языков стали появляться инструменты, ориентированные на быструю разработку автономного транслятора вместе с интегрированной средой разработки. Преимущества этих инструментов состоят в том, что они, во-первых, позволяют создавать простые трансляторы с минимальными затратами времени, а во-вторых, автоматически генерируют расширения для той или иной интегрированной среды, облегчающие разработчику создание и поддержку программ на новом языке. Как правило, такие инструменты ориентированы на решение типичных проблем, и реализация поддержки более сложных механизмов с их помощью затруднительна, однако на практике оказывается, что простота и скорость разработки являются очень весомым фактором, и именно этим инструментам отдают предпочтение разработчики. Возникает необходимость расширять возможности подобных средств, не увеличивая нагрузки на программиста, то есть идет о полной или практически полной автоматизации разработки тех или иных механизмов в языке. Одним из таких механизмов является композиция, обеспечивающая повторное использование спецификаций, основными примерами универсальных механизмов такого рода являются шаблоны (статически проверяемые макроопределения) и аспекты. Существующие подходы к автоматизации разработки таких механизмов не позволяют автоматически получать языки, поддерживающие их в полном объеме.